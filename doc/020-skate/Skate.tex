%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2015, ETH Zurich.
% All rights reserved.
%
% This file is distributed under the terms in the attached LICENSE file.
% If you do not find this file, copies can be found by writing to:
% ETH Zurich D-INFK, Universitaetstr 6, CH-8092 Zurich. Attn: Systems Group.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt,twoside]{report}
\usepackage{bftn}
\usepackage{calc}
\usepackage{verbatim}
\usepackage{xspace}
\usepackage{pifont}
\usepackage{pxfonts}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{listings}
\usepackage{todonotes}
\usepackage{hyperref}

\title{Skate in Barrelfish}
\author{Barrelfish project}
% \date{\today}   % Uncomment (if needed) - date is automatic
\tnnumber{020}
\tnkey{Skate}


\lstdefinelanguage{skate}{
    morekeywords={schema,typedef,fact,enum},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
}

\presetkeys{todonotes}{inline}{}

\begin{document}
\maketitle      % Uncomment for final draft

\begin{versionhistory}
\vhEntry{0.1}{16.11.2015}{MH}{Initial Version}
\vhEntry{0.2}{20.04.2017}{RA}{Renaming ot Skate and expanding.}
\end{versionhistory}

% \intro{Abstract}    % Insert abstract here
% \intro{Acknowledgements}  % Uncomment (if needed) for acknowledgements
\tableofcontents    % Uncomment (if needed) for final draft
% \listoffigures    % Uncomment (if needed) for final draft
% \listoftables     % Uncomment (if needed) for final draft
\cleardoublepage
\setcounter{secnumdepth}{2}

\newcommand{\fnname}[1]{\textit{\texttt{#1}}}%
\newcommand{\datatype}[1]{\textit{\texttt{#1}}}%
\newcommand{\varname}[1]{\texttt{#1}}%
\newcommand{\keywname}[1]{\textbf{\texttt{#1}}}%
\newcommand{\pathname}[1]{\texttt{#1}}%
\newcommand{\tabindent}{\hspace*{3ex}}%
\newcommand{\Skate}{\lstinline[language=skate]}
\newcommand{\ccode}{\lstinline[language=C]}

\lstset{
  language=C,
  basicstyle=\ttfamily \small,
  keywordstyle=\bfseries,
  flexiblecolumns=false,
  basewidth={0.5em,0.45em},
  boxpos=t,
  captionpos=b
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction and usage}
\label{chap:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Skate}\footnote{Skates are cartilaginous fish belonging to the family 
Rajidae in the superorder Batoidea of rays. More than 200 species have been 
described, in 32 genera. The two subfamilies are Rajinae (hardnose skates) and 
Arhynchobatinae (softnose skates). 
Source: \href{https://en.wikipedia.org/wiki/Skate_(fish)}{Wikipedia}}
is a domain specific language to describe the schema of 
Barrelfish's System Knowledge Base (SKB)~\cite{skb}. The SKB stores all 
statically or dynamically discovered facts about the system. Static facts are 
known and exist already at compile time of the SKB ramdisk or are added through
an initialization script or program. 

Examples for static facts include the device database, that associates known 
drivers with devices or the devices of a wellknown SoC. Dynamic facts, on the 
otherhand, are added to the SKB during and based on hardware discovery. 
Examples for dynamic facts include the number of processors or PCI Express 
devices. 

Inside the SKB, a prolog based constraint solver takes the added facts and 
computes a solution for hardware configuration such as PCI bridge programming,
NUMA information for memory allocation or device driver lookup. Programs can 
query the SKB using Prolog statements and obtain device configuration and PCI 
bridge programming, interrupt routing and constructing routing trees for IPC. 
Applications can use information to determine hardware characteristics such as 
cores, nodes, caches and memory as well as their affinity.


The Skate language is used to define format of those facts. The DSL is then 
compiled into a set of fact definitions and functions that are wrappers arround
the SKB client functions, in particular \texttt{skb\_add\_fact()}, to ensure
the correct format of the added facts.  

The intention when designing Skate is that the contents of system descriptor
tables such as ACPI, hardware information obtained by CPUID or PCI discovery
can be extracted from the respective manuals and easily specified in a Skate 
file. 

Skate complements the SKB by defining a \emph{schema} of the data stored in
the SKB. A schema defines facts and their structure, which is similar to Prolog
facts and their arity. A code-generation tool generates a C-API to populate the
SKB according to a specific schema instance.

The Skate compiler is written in Haskell using the Parsec parsing library. It
generates C header files from the Skate files. In addition it supports the 
generation of Schema documentation.

The source code for Skate can be found in \texttt{SOURCE/tools/skate}.


\section{Command line options}
\label{sec:cmdline}

\begin{verbatim}
$ skate <options> INFILE.skt
\end{verbatim}


Where options is one of
\begin{description}
  \item[-o] \textit{filename} The output file name
  \item[-D] generate documentation
  \item[-H] generate headerfile
\end{description}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lexical Conventions}
\label{chap:lexer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

We initialize a Java-style-like parser for Skate and thus adopt the following
convention. We follow a similar convention as opted by modern day programming 
languages like C and Java.

\begin{description}
\item[Whitespace:]  As in C and Java, Skate considers sequences of
  space, newline, tab, and carriage return characters to be
  whitespace.  Whitespace is generally not significant. 

\item[Comments:] Skate supports C-style comments.  Single line comments
  start with \texttt{//} and continue until the end of the line.
  Multiline comments are enclosed between \texttt{/*} and \texttt{*/};
  anything inbetween is ignored and treated as white space.

\item[Identifiers:] Valid Skate identifiers are sequences of numbers
  (0-9), letters (a-z, A-Z) and the underscore character ``\texttt{\_}''.  They
  must start with a letter or ``\texttt{\_}''.  
  \begin{align*}
    identifier & \rightarrow ( letter \mid \_ ) (letter \mid digit \mid \_)^{\textrm{*}} \\
    letter & \rightarrow (\textsf{A \ldots Z} \mid  \textsf{a \ldots z})\\
    digit & \rightarrow (\textsf{0 \ldots 9})
\end{align*}

  Note that a single underscore ``\texttt{\_}'' by itself is a special,
  ``don't care'' or anonymous identifier which is treated differently
  inside the language. 
  
\item[Integer Literals:] A Skate integer literal is a sequence of
  digits, optionally preceded by a radix specifier.  As in C, decimal (base 10)
  literals have no specifier and hexadecimal literals start with
  \texttt{0x}.  Binary literals start with \texttt{0b}. 

  In addition, as a special case the string \texttt{1s} can be used to
  indicate an integer which is composed entirely of binary 1's. 

\begin{align*}
digit & \rightarrow (\textsf{0 \ldots 9})^{\textrm{1}}\\
hexadecimal & \rightarrow (\textsf{0x})(\textsf{0 \ldots 9} \mid \textsf{A \ldots F} \mid \textsf{a \ldots f})^{\textrm{1}}\\
binary & \rightarrow (\textsf{0b})(\textsf{0, 1})^{\textrm{1}}\\
\end{align*}


\item[Reserved words:] The following are reserved words in Skate:
\begin{alltt}
  \begin{tabbing}
xxxxxxxxx \= xxxxxxxxx \= xxxxxxxxx \= xxxxxxxxx \= xxxxxxxxx \= xxxxxxxxx \kill
fact \> query \> flags \> constants \>  enum \>  \\
  \end{tabbing}
\end{alltt}

\item[Special characters:] The following characters are used as operators,
  separators, terminators or other special purposes in Skate:
\begin{alltt}

  \{ \} [ ] ( ) + - * / ; , . = 

\end{alltt}

\end{description}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Declarations}
\label{chap:declaration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter we define the layout of a skate file, which declarations it
must contain and what other declarations it can have.

\section{The Skate File}
A Skate file must consist of zero or more \emph{import} declarations (see
~\ref{sec:decl:schema}) followed by a single \emph{schema} declaration 
(see~\ref{sec:decl:schema}) which contains the actual fact definitions, etc.
The Skate file typicall has the extension \emph{*.schema}.

\begin{syntax}
(Import)*
SchemaDeclaration
\end{syntax}

%\begin{align*}
%    skatefile & \rightarrow ( Import )^{\textrm{*}} (Schema)
%\end{align*}

\section{Imports}\label{sec:decl:import}
An import statement makes the definitions in a different schema file
available in the current schema definition, as described below.  The
syntax of an import declaration is as follows:

\begin{syntax}
\synbf{import} \synit{schema};
\end{syntax}

\begin{description}
\item[schema] is the name of the schema to import definitions from.  
\end{description}

At compile time, the Skate compiler will try to resolve the imports by 
searching the include paths for an appropriate schema file. Imported files
are parsed at the same time as the main schema file. The Skate compiler will
attempt to parse all the imports of the imported files transitively. 
Cyclic dependencies between device files will not cause errors, but at present 
are unlikely to result in C header files which will successfully compile. 

\section{Schemas}\label{sec:decl:schema}

A schema groups all the facts of a particular topic together. For example, 
a schema could be the PCI Express devices, memory regions or an ACPI table. 
Each schema must have a unique name, which must match the name of the file, and
it must have at least one declaration.

\begin{syntax}
\synbf{schema} \synit{name} "\synit{description}" \verb+{+
  \synit{declaration};
  \ldots
\verb+}+;
\end{syntax}

\begin{description}
\item[name] is an identifier for the Schema type, and will be used to
  generate identifiers in the target language (typically C).  
  The name of the schema \emph{must} correspond to the
  filename of the file, including case sensitivity: for example, 
  the file \texttt{cpuid.schema} will define a schema type
  of name \texttt{cpuid}. 

\item [description] is a string literal in double quotes, which
  describes the schema type being specified, for example \texttt{"CPUID 
  Information Schema"}. 

\item [declaration] one of 
    \begin{itemize}
        \item flags -- Section \ref{sec:decl:flags}
        \item constants -- Section \ref{sec:decl:constants}
        \item enumeration -- Section \ref{sec:decl:enums}
        \item facts -- Section \ref{sec:decl:facts}
        \item namespace -- Section \ref{sec:decl:namespace}
        \item section -- Section \ref{sec:doc:section}
        \item text -- Section \ref{sec:doc:text}
    \end{itemize}


\end{description}

\section{Types}\label{sec:decl:types}

Skate supports the common C-like types such as integers, floats, chars as well 
as boolean values and Strings (character arrays). In addition, Skate treats
the Barrelfish capability reference (\texttt{struct capref}) as a built in 
type.

\subsection{BuiltIn Types}
\begin{syntax}
UInt8, UInt16, UInt32, UInt64, UIntPtr
Int8, Int16, Int32, Int64, IntPtr
Float, Double
Char, String
Bool
Capref
\end{syntax}

\subsection{Declaring Types}

All declarations of Section~\ref{sec:decl:decls} are implicitely types and can
be used within the fact declarations. This allows using fact declarations as 
types for fields in another fact which effectively implements something like
inheritance. 

\todo{allow typedef?}


\section{Declarations}\label{sec:decl:decls}

In this section we define the syntax for all possible flag and type 
declarations supported in Skate. 

\subsection{Flags}
\label{sec:decl:flags}

Flags are unsigned numbers of a specified width where each bit position has a
specific meaning. Flags are declared in a flag group which represents a single
field in the a hardware description. Example for this type are the 
\emph{LapicFlags} of the APIC entry in the ACPI MADT table. Flags are declared 
as follows:

\begin{syntax}
\synbf{flags} \synit{name} \synit{width} "\synit{description}" \verb+{+
    \synit{position1} \synit{name1} [ "\synit{description1}" ] ;
    \ldots
\verb+}+;
\end{syntax}

\begin{description}
    \item[name] the identifier of this flag group. Must be unique for all 
                declarations.
    
    \item [width] The width in bits of this flag group. Defines the maximum 
                  number of flags supported. This is one of 8, 16, 32, 64.
    
    \item [description] description in double quotes is a short explanation of
                        what the flag group represents.
    
    \item [name1] identifier of the flag. Must be unique within the flag 
                  group. 
    
    \item [position1] integer defining which bit position the flag sets
    
    \item [description1] description of this particular flag.
\end{description}

\subsection{Constants}
\label{sec:decl:constants}

Compared to flags, constants can take up arbitrary values. An example of a 
constant may be the vendor ID of a PCI express device or the version number
of a generic interrupt controller. The actual constants are declared in a 
constant group which has a defined type. All constants within this group 
must have this type.

\begin{syntax}
\synbf{constants} \synit{name} \synit{builtintype} "\synit{description}" \verb+{+
    \synit{name1} = \synit{value1} [ "\synit{description1} "] ;
    \ldots
\verb+}+;
\end{syntax}

\begin{description}
    \item[name] the identifier of this constants group. Must be unique for all 
                declarations.
    
    \item [builtintype] the type of the constant group. Must be one of the 
                        builtin types as defined in~\ref{sec:decl:types}
    
    \item [description] description in double quotes is a short explanation of
                        what the constant group represents.
    
    \item [name1] identifier of the constant. Must be unique within the 
                  constant group. 
    
    \item [value1] the value of the constant. Must match the declared type.
    
    \item [description1] description of this particular constant
    
\end{description}

\subsection{Enumerations}
\label{sec:decl:enums}

Enumerations are a special type of constants without any specific value. This
declaration is analogue to the C style \texttt{enum} declaration.

\begin{syntax}
\synbf{enumeration} \synit{name} "\synit{description}" \verb+{+
    \synit{name1} [ "\synit{description1} "] ;
    \ldots
\verb+}+;
\end{syntax}

\begin{description}
    \item[name] the identifier of this enumeration group. Must be unique for 
                all declarations.
    
    \item [description] description in double quotes is a short explanation of
                        what the enumeration group represents.
    
    \item [name1] identifier of the element. Must be unique within the 
                  enumeration group.   
    
    \item [description1] description of this particular element
    
\end{description}

\subsection{Facts}
\label{sec:decl:facts}

The fact is the central element of Skate. It defines the actual facts about the
system that are put into the SKB. Each fact has a name and one or more fields
of a given type. Ideally, facts should insert data into the SKB without any 
transformation.

\begin{syntax}
\synbf{fact} \synit{name}  "\synit{description}" \verb+{+
    \synit{type1} \synit{name1} [ "\synit{description1} "] ;
    \ldots
\verb+}+;
\end{syntax}

\begin{description}
    \item[name] the identifier of this fact. Must be unique for all 
                declarations.
    
    \item[description] description in double quotes is a short explanation of
                       what the fact defines.
    
    \item[type1] the type of the fact field. Must be one of the BuiltIn types
                 or one of the constants, flags or other facts. When using 
                 facts as field types, there must be no recursive nesting.

    \item [name1] identifier of a fact field. Must be unique within the 
                  Fact group.   
    
    \item [description1] description of this particular field
\end{description}

\subsection{Queries}

\todo{figure out how to do this...}

\begin{syntax}
\synbf{query} \synit{name} "\synit{description}" \verb+{+
    \synit{declaration};
    \ldots
\verb+}+;
\end{syntax}

\section{Namespaces}
\label{sec:decl:namespace}

The idea of a namespace is to provide more hierarchical structure, for example
a PCI devices may have virtual and physical functions.

\todo{does everything has to live in a namespace?, or is there an implicit
default namespace?}

\begin{syntax}
\synbf{namespace} \synit{name} "\synit{description}" \verb+{+
    \synit{declaration};
    \ldots
\verb+}+;
\end{syntax}

\begin{description}
    \item[name] the identifier of this namespace.
    
    \item[description] description of this namespace
    
    \item[declarations] One or more declarations as stated above.
\end{description}


\section{Documentation}

In order to organize the generated documentation we have a few syntactical 
constructs that allows inserting structural elements and additional text for
explanation into the generated documentation. There will not be any code 
generated based from this constructs.

\subsection{Schemas}
The generated documentation will contain all the schema declared in the source 
tree. The different schema files correspond to chapters in the resulting 
documentation.

\subsection{Sections}
\label{sec:doc:section}
The \texttt{section} construct allows to insert section headings into the 
documentation. A section logically groups the declarations together to allow
expressing a logical hierarchy. 

\begin{syntax}
\synbf{section} "\synit{name}";  \verb+{+
    \synit{declaration};
    \ldots
\verb+}+;
    
\end{syntax}

\subsection{Text}
\label{sec:doc:text}

By adding \texttt{text} blocks, additional content can be added to the generated
documentation. This includes examples and additional information of the
declarations of the schema.

\begin{syntax}
\synbf{text} \verb+{+
    \synit{text}
\verb+}+; 
\end{syntax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{C mapping for Schema Definitions}
\label{chap:cmapping}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

For each schema specification, Skate generates ....

\paragraph{Abbrevations}
In all the sections of this chapter, we use the follwing abbrevations, where 
the actual value may be upper or lower case depending on the conventions:

\begin{description}
  \item[SN] The schema name as used in the schema declaration.
  \item[DN] The declaration name as used in the flags / constants / 
            enumeration / facts declaration
  \item[FN] The field name as used in field declaration of flags / constants / 
            enumeration / facts
\end{description}

In general all defined functions, types and macros are prefixed with the schema
name SN.

\paragraph{Conventions}
We use the follwing conventions for the generated code:
\begin{itemize}
  \item macro definitions and enumerations are uppercase.
  \item type definitions, function names are lowercase.
  \item use of the underscore \texttt{'\_'} to separate words
\end{itemize}

\todo{just a header file (cf mackerel), or also C functions (cf. flounder)?}

\section{Using Schemas}

Developers can use the schemas by including the generated header file of a 
schema. All header files are placed in the schema subdirectory of the main 
include folder of the build tree. For example, the 
schema \texttt{SN} would generate the file \texttt{SN\_schema.h} and can 
be included by a C program with:
\begin{quote}
\texttt{\#include <schema/SN\_schema.h}
\end{quote}

\section{Preamble}

The generated headerfile is protected by a include guard that depends on the
schema name. For example, the schema \texttt{SN} will be guarded by the
macro definition \texttt{\_\_SCHEMADEF\_\_SN\_H\_}. The header file will 
include the folling header files:
\begin{enumerate}
  \item a common header \texttt{skate.h} providing the missing macro and 
        function definitions for correct C generation.
  \item an include for each of the imported schema devices.
\end{enumerate}

\section{Constants}

For any declared constant group, Skate will generate the following:

\paragraph{Type and macro definitions}
\begin{enumerate}
  \item A type definition for the declared type of the constant group. The 
        type  typename will be \texttt{SN\_DN\_t}.
  \item A set of CPP macro definitions, one for each of the declared constants.
        Each macro will have the name as in \texttt{SN\_DN\_FN} and expands to the field value cast to the type of the field.
\end{enumerate}

\paragraph{Function definitions}
\begin{enumerate}
  \item A function to describe the value 
        \begin{quote}
          \texttt{SN\_DN\_describe(SN\_DN\_t);}
        \end{quote}

  \item An snprintf-like function to pretty-print values of type SN\_DN\_t, 
        with prototype:
        \begin{quote}
          \texttt{int SN\_DN\_print(char *s, size\_t sz);}
        \end{quote}

\end{enumerate}
\todo{Do we need more ?}

\section{Flags}

\paragraph{Type and macro definitions}
\begin{enumerate}
  \item A type definition for the declared type of the flag group. The 
        type typename will be \texttt{SN\_DN\_t}.
\end{enumerate}

\paragraph{Function definitions}
\begin{enumerate}
  \item A function to describe the value 
        \begin{quote}
          \texttt{SN\_DN\_describe(SN\_DN\_t);}
        \end{quote}
\end{enumerate}
\todo{Do we need more ?}

\section{Enumerations}
Enumerations translate one-to-one to the C enumeration type in a straight 
forward manner:

\begin{quote}
  \texttt{typdef enum \{ SN\_DN\_FN1, ... \} SN\_DN\_t; }
\end{quote}

\paragraph{Function definitions}
\begin{enumerate}
  \item A function to describe the value 
        \begin{quote}
          \texttt{SN\_DN\_describe(SN\_DN\_t);}
        \end{quote}
  \item A function to pretty-print the value
        \begin{quote}
          \texttt{SN\_DN\_print(char *b, size\_t sz, SN\_DN\_t val);}
        \end{quote}
\end{enumerate}

\section{Facts}


\paragraph{Type and macro definitions}
\begin{enumerate}
  \item A type definition for the declared type of the flag group. The 
        type typename will be \texttt{SN\_DN\_t}.
\end{enumerate}

\paragraph{Function definitions}
\begin{enumerate}
  \item A function to describe the value 
        \begin{quote}
          \texttt{SN\_DN\_describe(SN\_DN\_t);}
        \end{quote}
  \item A function to add a fact to the SKB
  \item A function to retrieve all the facts of this type from the SKB
  \item A function to delete the fact from the SKB
\end{enumerate}

\todo{Provide some way of wildcard values. e.g. list all facts with this 
filter or delete all facts that match the filter.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Prolog mapping for Schema Definitions}
\label{chap:prologmapping}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Generated Documentation}
\label{chap:documentation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{High-level overview: Skate schema for the SKB}
\label{chap:overview}

\todo{this is the old part}


\section{Schema language}

The schema language is a C-like language defining facts and their attributes. An
attribute is typed and can be one of a basic type, a fact or an enumeration
type. Basic types include signed and unsigned integers as well as memory
addresses with a machine-specific word size and strings. As facts can be
attributes of other facts we can achieve a simple nesting of facts.

In Listing \ref{lst:sample_schema} an excerpt of the CPUID schema is shown. In
Barrelfish, a CPU core is identified using an eight bit unsigned number, hence
we use a \Skate{typedef} to declare a \varname{core\_id} type.

\begin{lstlisting}[caption={Sample Skate schema definition},
label={lst:sample_schema},language=Skate]

schema cpuid "CPUID abstractions" {
    typedef uint8 core_ID;
    fact vendor "Literal vendor" {
        core_id Core_id "Core";
        string vendor "Core vendor";
    };
};
\end{lstlisting}

Each schema starts with the keyword \Skate{schema}. It is followed by an
identifier and a documentation string for that schema. The identifier also needs
to be equal to the file name, i.e.~the schema \varname{cpuid} needs to reside in
\varname{cpuid.Skate}. After the schema declaration we find a list of facts,
typdefs and enums enclosed in curly braces (\{\}).

Each fact has an identifying name and a documentation string. Its attributes
follow the documentation string and are enclosed in curly braces. The attributes
are a tuple consisting of a type, a name and an optional documentation. The type
can be a basic type, a fact or an enumeration type. Note that types need to have
unique names, there is no mechanism to derive new types from existing types.

Typedefs allow to use a different identifier for a built-in type. This is useful
for abstracting common built-in types.

\todo{Explain enumerations}

\section{Code generation}

Skate can translate schema definitions into documentation and C code (header
and implementation). Here, we explain the mechanisms that are used to generate a
C implementation of the schema.

The example presented in Listing \ref{lst:sample_schema} translates into C
structures and type definitions for both \varname{core\_id} and
\varname{vendor}. Functions are provided to populate the SKB with instanced of
facts.

\section{Translating facts}

Each fact corresponds to a structure in C. Skate generates both a structure
and a type definition for each fact. Using the example, it creates the
structure shown in Listing \ref{lst:c_vendor}.

\begin{lstlisting}[caption={C header for fact
\varname{vendor}},label={lst:c_vendor},language=C]
struct cpuid__vendor {
    /* CPU ID */
    cpuid__core_id_t Core_ID;
    /* Vendor string */
    char *vendor;
};
typedef struct cpuid__vendor cpuid__vendor_t;
\end{lstlisting}

Each fact attribute is represented by a \ccode!struct!~field. Nested structures are
allowed, but there cannot be a recursive dependency.

On top of this, it generates a function
\ccode!cpuid__vendor__add(struct cpuid__vendor *)!.
This function can be used to add facts of the specified type to the SKB. For
example, the code presented in Listing \ref{lst:c_add_vendor} adds an Intel core
to the SKB.

\begin{lstlisting}[caption={C example to add a vendor fact.},
label={lst:c_add_vendor}, language=C]
cpuid__vendor_t vendor;
vendor.Core_ID = core_id;
vendor.vendor = vendor_string;

errval_t err = cpuid__vendor__add(&vendor);
\end{lstlisting}

\section{Mapping facts to Prolog facts}

Each fact added to the SKB using Skate is represented by a single Prolog
functor.  The functor name in Prolog consist of the schema and fact name.  The
fact defined in Listing \ref{lst:sample_schema} is represented by the functor
\lstinline!cpuid_vendor!~and has an arity of three.

\section{Integration with the build process}

Skate is a tool that is integrated with Hake. Add the attribute
\lstinline!SkateSchema!~to a Hakefile to invoke Skate as shown in Listing
\ref{lst:Skate_hake}.

\begin{lstlisting}[caption={Including Skate schemata in Hake},
label={lst:Skate_hake}, language=Haskell]
[ build application {
    SkateSchema = [ "cpu" ]
    ... 
} ]
\end{lstlisting}

Adding an entry for \varname{SkateSchema} to a Hakefile will generate both
header and implementation and adds it to the list of compiled resources. A
Skate schema is referred to by its name and Skate will look for a file
ending with \varname{.Skate} containing the schema definition.

The header file is placed in \pathname{include/schema} in the build tree, the C
implementation is stored in the Hakefile application or library directory.

\chapter{Limitations \& Work in Progress}

Skate is not yet in a feature-complete state. It does not allow querying facts
or specifying more advanced rules for types besides the ones being enforced by C
on \ccode!struct!s. Although features are missing users can start writing
schemata as the syntax is not going to change significantly at the moment.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv}
\bibliography{barrelfish}

\end{document}
