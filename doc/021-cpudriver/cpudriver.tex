%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2015, ETH Zurich.
% All rights reserved.
%
% This file is distributed under the terms in the attached LICENSE file.
% If you do not find this file, copies can be found by writing to:
% ETH Zurich D-INFK, Universitaetstr 6, CH-8092 Zurich. Attn: Systems Group.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt,twoside]{report}
\usepackage{bftn}
\usepackage{calc}
\usepackage{verbatim}
\usepackage{xspace}
\usepackage{pifont}
\usepackage{pxfonts}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{listings}
\usepackage{todonotes}

\title{CPU drivers in Barrelfish}
\author{Barrelfish project}
\tnnumber{21}
\tnkey{CPU drivers}

\presetkeys{todonotes}{inline}{}

\begin{document}
\maketitle			% Uncomment for final draft

\begin{versionhistory}
\vhEntry{0.1}{01.12.2015}{GZ}{Initial Version}
\end{versionhistory}

% \intro{Abstract}		% Insert abstract here
% \intro{Acknowledgements}	% Uncomment (if needed) for acknowledgements
\tableofcontents		% Uncomment (if needed) for final draft
% \listoffigures		% Uncomment (if needed) for final draft
% \listoftables			% Uncomment (if needed) for final draft
\cleardoublepage
\setcounter{secnumdepth}{2}

\newcommand{\fnname}[1]{\textit{\texttt{#1}}}%
\newcommand{\datatype}[1]{\textit{\texttt{#1}}}%
\newcommand{\varname}[1]{\texttt{#1}}%
\newcommand{\keywname}[1]{\textbf{\texttt{#1}}}%
\newcommand{\pathname}[1]{\texttt{#1}}%
\newcommand{\tabindent}{\hspace*{3ex}}%
\newcommand{\sockeye}{\lstinline[language=sockeye]}
\newcommand{\ccode}{\lstinline[language=C]}

\lstset{
  language=C,
  basicstyle=\ttfamily \small,
  keywordstyle=\bfseries,
  flexiblecolumns=false,
  basewidth={0.5em,0.45em},
  boxpos=t,
  captionpos=b
}

\chapter{Introduction}
\label{chap:introduction}

This document describes the CPU driver, the part of Barrelfish that typically
runs in privileged mode (also known as kernel) on our supported architectures.

Barrelfish currently supports the following CPU drivers for 
different CPU architectures and platforms:
\begin{itemize}
    \item x86-32
    \item x86-64
    \item k1om
    \item ARMv7
    \item ...
    \item ARMv8
\end{itemize}


\chapter{General}

This chapter describes the architecture agnostic parts in the CPU driver.
It should include at least the following:

\section{Terminology}

\texttt{BSP Core}: Refers to the bootstrap processor, meaning the first
processor that is usually booted by the boot-loader or firmware on a hardware
architecture.

\texttt{APP Core}: Application processor, processors booted either by the BSP
or other APP cores and not the initial boot-loader or firmware.

\section{General design decisions}
... that need to be taken into account when writing a new CPU driver,
like no preemption, no dynamic memory allocation etc.

\section{Code file structure and layout}
Naming, Where goes architecture, Where is platform specific stuff.
What libraries we use, where is the code shared between libbarrelfish
and cpudriver.

\section{Minimal hardware requirements for a CPU driver}
Do we need an MMU etc.

\section{Scheduler}
Round-robin, RBED, gang-scheduler

\section{Architecture generic API (syscall) interface}
Describe the common syscall API that is provided, including
the higher level interface based on capabilities.

\section{Up-call interface}
Mechanisms, What are the common structure definitions agreed upon between
libbarrelfish and the cpudriver.



\chapter{x86-64 / AMD64}
\label{chap:x86}

In this chapter, we describe the CPU driver for the x86-64 also known as AMD64
architecture.

\section{Boot process}

We first describe the boot process for the initial BSP core, and followed by
the boot process of an APP core.

\subsubsection{BSP Core}

Barrelfish relies on a multiboot v1~\cite{multiboot1} compliant boot-loader to
load the initial kernel on the BSP core. In our current set-up we use GRUB as
our boot-loader which contains an implementation of the multiboot standard.

On start-up, GRUB will search the supplied kernel module (on x86-64 this is the
binary called elver in \pathname{tools/elver/}) for a magic byte sequence 
(defined by multiboot) and begin execution just after that sequence appeared
(see \pathname{tools/elver/boot.S}).

\pathname{boot.S} in elver will set-up an preliminary GDT, an IA32-e page-
table, and stack for execution. \pathname{elver.c} will then search for a
binary called \keywname{kernel} or \keywname{cpu} in all the multiboot
modules, relocate that module and then jump to the relocated kernel module. At
this point, we have set-up a 1 GiB identity mapping of the physical address
space using 2 MiB  pages in order to address everything we need initially.

Note that the reason elver exists is because multiboot v1 does not support
ELF64 images (or setting up long-mode). If we use a bootloader that supports
loading relocatable ELF64 images into 64-bit mode, elver would be redundant.

After \keywname{elver} is done, execution in the proper BSP kernel program
begins in \pathname{kernel/arch/x86\_64/boot.S} which then calls 
\fnname{arch\_init}, the first kernel C entry point.

\subsubsection{APP Core}

APP cores are booted using the coreboot infrastructure in Barrelfish. The
logic that boots APP cores resides in \pathname{usr/drivers/cpuboot}.

The source code responsible for booting a new core on x86 is found in
\pathname{usr/drivers/cpuboot/x86boot.c}, specifically in the function called
\fnname{spawn\_xcore\_monitor}. \fnname{spawn\_xcore\_monitor} will load the
\keywname{kernel} and \keywname{monitor} binary, and relocate the kernel. The
function called \fnname{start\_aps\_x86\_64\_start} will afterwards map in the
bootstrap code (which is defined in \pathname{init\_ap\_x86\_64.S}) for booting the
APP core. One complication for this code is that it has to resides below 1 MiB
in physical memory since the new APP core starts in protected mode and
therefore can not address anything above that limit in the beginning. Once the
mapping is initiated, the entry point address for the new APP kernel will be
written into this memory region. Finally, a series of system calls is invoked
in order to send the necessary IPIs to bootstrap the new processor.

\section{Hardware state}

In this section, we describe the hardware state of a core after the CPU driver
has completed its initialization and started to dispatch the first 
user-space program.

\subsection{Descriptor Tables}

\subsubsection{Global Descriptor Table (GDT)}


\subsubsection{Interrupt Descriptor Table (IDT)}


\subsubsection{Local Descriptor Table (LDT)}


\subsection{Registers}
Segment, general purpose, floating point, SIMD

\subsection{MSR}
All MSRs/ read written.

\subsection{Address space layout}

\subsection{Serial port}
Initialized to get any output.

\subsection{Interrupt controllers}

\subsubsection{PIC}
We have to use that before the BSP core has spawned the ACPI server.

\subsubsection{APIC}
We don't use that anymore.

\subsubsection{xAPIC}
We use that.

\subsubsection{x2APIC}
Not yet supported.


\section{System call API}
This section describe the architectural system calls that are not 
common with other architectures.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv}
\bibliography{barrelfish}

\end{document}
