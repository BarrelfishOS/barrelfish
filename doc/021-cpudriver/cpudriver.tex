%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2015, ETH Zurich.
% All rights reserved.
%
% This file is distributed under the terms in the attached LICENSE file.
% If you do not find this file, copies can be found by writing to:
% ETH Zurich D-INFK, Universitaetstr 6, CH-8092 Zurich. Attn: Systems Group.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt,twoside]{report}
\usepackage{bftn}
\usepackage{calc}
\usepackage{verbatim}
\usepackage{xspace}
\usepackage{pifont}
\usepackage{pxfonts}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{listings}
\usepackage{todonotes}

\title{CPU drivers in Barrelfish}
\author{Barrelfish project}
\tnnumber{21}
\tnkey{CPU drivers}

\presetkeys{todonotes}{inline}{}

\begin{document}
\maketitle			% Uncomment for final draft

\begin{versionhistory}
\vhEntry{0.1}{01.12.2015}{GZ}{Initial Version}
\end{versionhistory}

% \intro{Abstract}		% Insert abstract here
% \intro{Acknowledgements}	% Uncomment (if needed) for acknowledgements
\tableofcontents		% Uncomment (if needed) for final draft
% \listoffigures		% Uncomment (if needed) for final draft
% \listoftables			% Uncomment (if needed) for final draft
\cleardoublepage
\setcounter{secnumdepth}{2}

\newcommand{\fnname}[1]{\textit{\texttt{#1}}}%
\newcommand{\datatype}[1]{\textit{\texttt{#1}}}%
\newcommand{\varname}[1]{\texttt{#1}}%
\newcommand{\keywname}[1]{\textbf{\texttt{#1}}}%
\newcommand{\pathname}[1]{\texttt{#1}}%
\newcommand{\tabindent}{\hspace*{3ex}}%
\newcommand{\sockeye}{\lstinline[language=sockeye]}
\newcommand{\ccode}{\lstinline[language=C]}

\lstset{
  language=C,
  basicstyle=\ttfamily \small,
  keywordstyle=\bfseries,
  flexiblecolumns=false,
  basewidth={0.5em,0.45em},
  boxpos=t,
  captionpos=b
}

\chapter{Introduction}
\label{chap:introduction}

This document describes the CPU driver, the part of Barrelfish that typically
runs in privileged mode (also known as kernel) on our supported architectures.

Barrelfish currently supports the following CPU drivers for
different CPU architectures and platforms:
\begin{itemize}
    \item x86-32
    \item x86-64
    \item k1om
    \item ARMv7
    \item ...
    \item ARMv8
\end{itemize}


\chapter{General}

This chapter describes the architecture agnostic parts in the CPU driver.
It should include at least the following:

\section{Terminology}

\texttt{BSP Core}: Refers to the bootstrap processor, meaning the first
processor that is usually booted by the boot-loader or firmware on a hardware
architecture.

\texttt{APP Core}: Application processor, processors booted either by the BSP
or other APP cores and not the initial boot-loader or firmware.

\section{General design decisions}
... that need to be taken into account when writing a new CPU driver,
like no preemption, no dynamic memory allocation etc.

\section{Code file structure and layout}
Naming, Where goes architecture, Where is platform specific stuff.
What libraries we use, where is the code shared between libbarrelfish
and cpudriver.

\section{Minimal hardware requirements for a CPU driver}
Do we need an MMU etc.

\section{Scheduler}
Round-robin, RBED, gang-scheduler

\section{Architecture generic API (syscall) interface}
Describe the common syscall API that is provided, including
the higher level interface based on capabilities.

\begin{itemize}
\item[0] SYSCALL\_INVOKE: Invoke a cap
\item[1] SYSCALL\_YIELD: Yield the CPU
\item[2] SYSCALL\_LRPC: Fast LRPC
\item[3] SYSCALL\_DEBUG: Benchmarking and debug syscalls
\item[4] SYSCALL\_REBOOT: Reboot the machine
\item[5] SYSCALL\_NOP: No operation
\item[6] SYSCALL\_PRINT: Write to console
\item[9] SYSCALL\_SUSPEND: Suspend the CPU
\item[10] SYSCALL\_GET\_ABS\_TIME: Get time elapsed since boot

%#ifdef __ARM_ARCH_7M__  //cortex-m3 on pandaboard
%#define SYSCALL_RESUME_CONTEXT      7
%///< Resume a context that the dispatcher can't
\end{itemize}

\section{Capability invocation interface}

This is handled using the SYSCALL\_INVOKE system call but it deserves
it's own section:

CNode Command:
\begin{itemize}
\item CNodeCmd\_Copy: Copy capability
\item CNodeCmd\_Mint: Mint capability
\item CNodeCmd\_Retype: Retype capability
\item CNodeCmd\_Delete: Delete capability
\item CNodeCmd\_Revoke: Revoke capability
\item CNodeCmd\_Create: Create capability
\item CNodeCmd\_GetState: Get distcap state for capability
\end{itemize}

VNode Command:
\begin{itemize}
\item VNodeCmd\_Map:
\item VNodeCmd\_Unmap:
\item VNodeCmd\_Identify: the physical address of the VNode
\end{itemize}

Kernel Command:
\begin{itemize}
\item KernelCmd\_Spawn\_core: Spawn a new kernel
\item KernelCmd\_Identify\_cap: Return the meta data of a capability
\item KernelCmd\_Identify\_domains\_cap: Return the meta data of another domain's capability
\item KernelCmd\_Remote\_relations: Set capability as being remote
\item KernelCmd\_Cap\_has\_relations: Return presence of local relations
\item KernelCmd\_Create\_cap: Create a new capability
\item KernelCmd\_Copy\_existing:
\item KernelCmd\_Get\_core\_id: Returns the id of the core the domain is on
\item KernelCmd\_Get\_arch\_id: Returns arch id of caller's core
\item KernelCmd\_Nullify\_cap: Set the capability to NULL allowed it to be reused
\item KernelCmd\_Setup\_trace: Set up trace buffer
\item KernelCmd\_Register: Register monitor notify endpoint
\item KernelCmd\_Domain\_Id: Set domain ID of dispatcher
\item KernelCmd\_Get\_cap\_owner
\item KernelCmd\_Set\_cap\_owner
\item KernelCmd\_Lock\_cap
\item KernelCmd\_Unlock\_cap
\item KernelCmd\_Delete\_last
\item KernelCmd\_Delete\_foreigns
\item KernelCmd\_Revoke\_mark\_target
\item KernelCmd\_Revoke\_mark\_relations
\item KernelCmd\_Delete\_step
\item KernelCmd\_Clear\_step
\item KernelCmd\_Retype
\item KernelCmd\_Has\_descendants
\item KernelCmd\_Sync\_timer
\item KernelCmd\_IPI\_Register
\item KernelCmd\_IPI\_Delete
\item KernelCmd\_GetGlobalPhys
\item KernelCmd\_Add\_kcb: add extra kcb to be scheduled
\item KernelCmd\_Remove\_kcb: Remove kcb from scheduling ring
\item KernelCmd\_Suspend\_kcb\_sched: suspend/resume kcb scheduler
\end{itemize}

Dispatcher:
\begin{itemize}
\item DispatcherCmd\_Setup: Set dispatcher parameters
\item DispatcherCmd\_Properties: Set dispatcher properties
\item DispatcherCmd\_PerfMon: Performance monitoring
\item DispatcherCmd\_SetupGuest: Set up the DCB of a guest domain
\item DispatcherCmd\_DumpPTables: Dump hw page tables of dispatcher
\item DispatcherCmd\_DumpCapabilities: Dump capabilities of dispatcher
\item DispatcherCmd\_Vmread: Execute vmread on the current and active VMCS
\item DispatcherCmd\_Vmwrite: Execute vmwrite on the current and active VMCS
\item DispatcherCmd\_Vmptrld: Make VMCS clear and inactive
\item DispatcherCmd\_Vmclear: Make VMCS current and active
\end{itemize}

Frames:
\begin{itemize}
\item FrameCmd\_Identify: Return physical address of frame
\item FrameCmd\_ModifyFlags: Modify flags for (part of) the mapped region of frame
\end{itemize}

IRQ Table:
\begin{itemize}
\item IRQTableCmd\_Alloc: Allocate new vector (XXX: HACK: this is x86 specific)
\item IRQTableCmd\_Set: Set endpoint for IRQ# notifications
\item IRQTableCmd\_Delete: Remove notification endpoint for IRQ#
\end{itemize}

IO Ports:
\begin{itemize}
\item IOCmd\_Outb: Output byte to port
\item IOCmd\_Outw: Output word to port
\item IOCmd\_Outd: Output double word to port
\item IOCmd\_Inb: Input byte from port
\item IOCmd\_Inw: Input word from port
\item IOCmd\_Ind: Input double word from port
\end{itemize}

Notify Command:
\begin{itemize}
\item NotifyCmd\_Send
\end{itemize}

Perfomance Monitor:
\begin{itemize}
\item PerfmonCmd\_Activate: Activate performance counters
\item PerfmonCmd\_Deactivate: Deactivate performance counters
\item PerfmonCmd\_Write: Read current performance counter values
\end{itemize}

ID Caps:
\begin{itemize}
\item IDCmd\_Identify: Return system-wide unique ID
\end{itemize}

IPIs:
\begin{itemize}
\item IPICmd\_Send\_Start: Send Startup IPI to a destination core
\item IPICmd\_Send\_Init: Send Init IPI to a destination core
\end{itemize}

\section{Up-call interface}
Mechanisms, What are the common structure definitions agreed upon between
libbarrelfish and the cpudriver.

\chapter{x86-64 / AMD64}
\label{chap:x86}

In this chapter, we describe the CPU driver for the x86-64 also known as AMD64
architecture.

\section{Boot process}

We first describe the boot process for the initial BSP core, followed by
the boot process of an APP core.

\subsubsection{BSP Core}

Barrelfish relies on a multiboot v1~\cite{multiboot1} compliant boot-loader to
load the initial kernel on the BSP core. In our current set-up we use GRUB as
our boot-loader which contains an implementation of the multiboot standard.

On start-up, GRUB will search the supplied kernel module (on x86-64 this is the
binary called elver in \pathname{tools/elver/}) for a magic byte sequence
(defined by multiboot) and begin execution just after that sequence appeared
(see \pathname{tools/elver/boot.S}).

\pathname{boot.S} in elver will set-up an preliminary GDT, an IA32-e page-table,
and stack for execution. \pathname{elver.c} will then search for a
binary called \keywname{kernel} or \keywname{cpu} in all the multiboot
modules, relocate that module and then jump to the relocated kernel module. At
this point, we have set-up a 1 GiB identity mapping of the physical address
space using 2 MiB  pages in order to address everything we need initially.

Note that the reason elver exists is because multiboot v1 does not support
ELF64 images (or setting up long-mode). If we use a bootloader that supports
loading relocatable ELF64 images into 64-bit mode, elver would be redundant.

After \keywname{elver} is done, execution in the proper BSP kernel program
begins in \pathname{kernel/arch/x86\_64/boot.S} which then calls
\fnname{arch\_init}, the first kernel C entry point.

\subsubsection{APP Core}

APP cores are booted using the coreboot infrastructure in Barrelfish. The
logic that boots APP cores resides in \pathname{usr/drivers/cpuboot}.

The source code responsible for booting a new core on x86 is found in
\pathname{usr/drivers/cpuboot/x86boot.c}, specifically in the function called
\fnname{spawn\_xcore\_monitor}. \fnname{spawn\_xcore\_monitor} will load the
\keywname{kernel} and \keywname{monitor} binary, and relocate the kernel. The
function called \fnname{start\_aps\_x86\_64\_start} will afterwards map in the
bootstrap code (which is defined in \pathname{init\_ap\_x86\_64.S}) for booting the
APP core. One complication for this code is that it has to resides below 1 MiB
in physical memory since the new APP core starts in protected mode and
therefore can not address anything above that limit in the beginning. Once the
mapping is initiated, the entry point address for the new APP kernel will be
written into this memory region. Finally, a set of system calls are invoked
in order to send the necessary IPIs to bootstrap the new processor.

\section{Hardware state}

In this section, we describe the hardware state of a core after the CPU driver
has completed its initialization and started to dispatch the first
user-space program.

\subsection{Descriptor Tables}

\subsubsection{Global Descriptor Table (GDT)}

The GDT table is loaded by the \fnname{gdt\_reset} function during start-up and statically defined.

The table contains the following entries:

\begin{tabular}{M|l}
    Index & Description \\ \hline
    0 & NULL segment  \\
    1 & Kernel code segment  \\
    2 & Kernel stack segment  \\
    3 & User stack segment  \\
    4 & User code segment  \\
    5 & Task state segment  \\
    6 & Task state segment (cont.)  \\
    7 & Local descriptor table \\
    8 & Local descriptor table (cont.) \\
\end{tabular}

\subsubsection{Interrupt Descriptor Table (IDT)}

The initial IDT is set-up by \fnname{setup\_default\_idt} in
\pathname{irq.c}. The number of entries in the IDT is set to 256 entries which
are initialized in the following way:

\begin{tabular}{M|l}
    Index & Description \\ \hline
    0  &  Divide Error \\
    1  &  Debug \\
    2  &  Nonmaskable External Interrupt \\
    3  &  Breakpoint \\
    4  &  Overflow \\
    5  &  Bound Range Exceeded \\
    6  &  Undefined/Invalid Opcode \\
    7  &  No Math Coprocessor \\
    8  &  Double Fault \\
    9  &  Coprocessor Segment Overrun \\
    10 &  Invalid TSS \\
    11 &  Segment Not Present \\
    12 &  Stack Segment Fault \\
    13 &  General Protection Fault \\
    14 &  Page Fault \\
    15 &  Unused \\
    16 &  FPU Floating-Point Error \\
    17 &  Alignment Check \\
    18 &  Machine Check \\
    19 &  SIMD Floating-Point Exception \\
    \hline
    32 & \multirow{3}{*}{PIC Interrupts} \\
    \vdots{} & \\
    47 & \\
    \hline
    48 & \multirow{3}{*}{Generic Interrupts} \\
    \vdots{} & \\
    61 & \\
    \hline
    62 & Tracing IPI \\
    63 & Tracing IPI \\
    \hline
    64 & \multirow{3}{*}{Unused} \\
    \vdots{} & \\
    247 & \\
    \hline
    248 & Halt IPI (Stopping a core) \\
    249 & Inter core vector (IPI notifications) \\
    250 & APIC Timer \\
    251 & APIC Thermal \\
    252 & APIC Performance monitoring interrupt \\
    253 & APIC Error \\
    254 & APIC Spurious interrupt \\
    255 & Unused \\
\end{tabular}

Unused entries will be initialized by a special handler function. The slots
reserved for generic interrupts can be allocated by user-space applications.

\subsubsection{Local Descriptor Table (LDT)}

The local descriptor table segment in the GDT will
initially point to NULL as no LDT is installed.

User-space applications can install their own LDT table
which is loaded on context-switching using the
\fnname{maybe\_reload\_ldt} function.

\subsection{Registers}

\subsubsection{Segment registers}

Segment registers are initialized by the \fnname{gdt\_reset} function during start-up and each of them points to a GDT entry (index of the GDT table slot for each segment is given in brackets).

\begin{itemize}
\item[cs] Kernel code segment (1)
\item[ds] NULL segment (0)
\item[es] NULL segment (0)
\item[fs] NULL segment (0)
\item[gs] NULL segment (0)
\item[ss] Kernel stack segment (2)
\end{itemize}

We also note that the \keywname{fs} and \keywname{gs} segment registers are
preserved and restored across context switches.

\subsubsection{General purpose}

\subsubsection{Floating point / SIMD}

\subsubsection{Machine specific registers (MSR)}

\subsection{Address space layout}

\subsection{Serial port}
On x86, the serial device (a PC16550 compatible controller) is initialized for the first time by the BSP core on boot-up.

By default serial port \varname{0x3f8} will be used, but the port can be changed by
using a command line argument supplied to the kernel.

Notable settings for the serial driver are:
\begin{itemize}
    \item Interrupts are disabled.
    \item FIFOs are enabled.
    \item No stop bit.
    \item 8 data bits.
    \item No parity bit.
    \item BAUD rate is 115200.
\end{itemize}

The serial device is later re-initialized into a different state once the
serial driver takes over the device. For example, interrupts will be enabled
hand handled by the driver.


\subsection{Interrupt controllers}

\subsubsection{PIC}
We have to use that before the BSP core has spawned the ACPI server.

\subsubsection{APIC}
We don't use that anymore.

\subsubsection{xAPIC}
We use that.

\subsubsection{x2APIC}
Not yet supported.


\section{System call API}
This section describe the architectural system calls that are not
common with other architectures.

\begin{itemize}
\item[7] SYSCALL\_X86\_FPU\_TRAP\_ON: Turn FPU trap on (x86)
\item[8] SYSCALL\_X86\_RELOAD\_LDT: Reload the LDT register (x86\_64)
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv}
\bibliography{barrelfish}

\end{document}
