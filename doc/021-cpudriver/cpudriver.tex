%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2015, ETH Zurich.
% All rights reserved.
%
% This file is distributed under the terms in the attached LICENSE file.
% If you do not find this file, copies can be found by writing to:
% ETH Zurich D-INFK, Universitaetstr 6, CH-8092 Zurich. Attn: Systems Group.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper,11pt,twoside]{report}
\usepackage{bftn}
\usepackage{calc}
\usepackage{verbatim}
\usepackage{xspace}
\usepackage{pifont}
\usepackage{pxfonts}
\usepackage{textcomp}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{listings}
\usepackage{todonotes}

\title{CPU drivers in Barrelfish}
\author{Barrelfish project}
\tnnumber{21}
\tnkey{CPU driver}

\presetkeys{todonotes}{inline}{}

\begin{document}
\maketitle			% Uncomment for final draft

\begin{versionhistory}
\vhEntry{0.1}{01.12.2015}{GZ}{Initial Version}
\end{versionhistory}

% \intro{Abstract}		% Insert abstract here
% \intro{Acknowledgements}	% Uncomment (if needed) for acknowledgements
\tableofcontents		% Uncomment (if needed) for final draft
% \listoffigures		% Uncomment (if needed) for final draft
% \listoftables			% Uncomment (if needed) for final draft
\cleardoublepage
\setcounter{secnumdepth}{2}

\newcommand{\fnname}[1]{\textit{\texttt{#1}}}%
\newcommand{\datatype}[1]{\textit{\texttt{#1}}}%
\newcommand{\varname}[1]{\texttt{#1}}%
\newcommand{\keywname}[1]{\textbf{\texttt{#1}}}%
\newcommand{\pathname}[1]{\texttt{#1}}%
\newcommand{\tabindent}{\hspace*{3ex}}%
\newcommand{\sockeye}{\lstinline[language=sockeye]}
\newcommand{\ccode}{\lstinline[language=C]}

\lstset{
  language=C,
  basicstyle=\ttfamily \small,
  keywordstyle=\bfseries,
  flexiblecolumns=false,
  basewidth={0.5em,0.45em},
  boxpos=t,
  captionpos=b
}

\chapter{Introduction}
\label{chap:introduction}

This document describes the CPU driver, the part of Barrelfish that typically
runs in privileged mode (also known as kernel) on our supported architectures.

Barrelfish currently supports the following CPU drivers for 
different CPU architectures and platforms:
\begin{itemize}
    \item x86-32
    \item x86-64
    \item k1om
    \item ARMv7
    \item ...
    \item ARMv8
\end{itemize}


\chapter{General}

This chapter describes the architecture agnostic parts in the CPU driver.
It should include at least the following:

\section{Terminology}

\texttt{BSP Core}: Refers to the bootstrap processor, meaning the first
processor that is usually booted by the boot-loader or firmware on a hardware
architecture.

\texttt{APP Core}: Application processor, processors booted either by the BSP
or other APP cores and not the initial boot-loader or firmware.

\section{General design decisions}
... that need to be taken into account when writing a new CPU driver,
like no preemption, no dynamic memory allocation etc.

\section{Code file structure and layout}
Naming, Where goes architecture, Where is platform specific stuff.
What libraries we use, where is the code shared between libbarrelfish
and cpudriver.

\section{Minimal hardware requirements for a CPU driver}
Do we need an MMU etc.

\section{Scheduler}
Round-robin, RBED, gang-scheduler

\section{Architecture generic API (syscall) interface}
Describe the common syscall API that is provided, including
the higher level interface based on capabilities.

\section{Up-call interface}
Mechanisms, What are the common structure definitions agreed upon between
libbarrelfish and the cpudriver.



\chapter{x86-64 / AMD64}
\label{chap:x86}

In this chapter, we describe the CPU driver for the x86-64 also known as AMD64
architecture.

\section{Boot process}
We first describe the boot process for the initial BSP core,
and follow that by the boot process of an APP core.

\subsubsection{BSP Core}

Barrelfish relies on a multiboot v1~\cite{multiboot1} compliant boot-loader to
load the initial kernel on the BSP core. In our current set-up we use GRUB as
our boot-loader which contains an implementation of the multiboot standard.

On start-up, GRUB will search the supplied kernel module (on x86-64 this is the
binary called elver in \pathname{tools/elver/}) for a magic byte sequence 
(defined by multiboot) and begin execution just after that sequence appeared
(see \pathname{tools/elver/boot.S}).

boot.S in elver will set-up an preliminary GDT, an IA32-e page-table, and
stack for execution. \pathname{elver.c} will then search for a binary called
\keywname{kernel} or \keywname{cpu} in all the multiboot modules, relocate
that module and then jump to the relocated kernel module.

TODO: At this point we have the following page-table and GDT setup:

Note that the reason elver exists is because multiboot v1 does not
support ELF64 images or long-mode. If we use a bootloader that
supports loading relocatable ELF64 images into 64-bit mode, 
this can be dropped.

\subsubsection{APP Core}
coreboot

\section{Hardware state}
Following the boot-process, we describe the hardware state of a core after the
CPU driver has completed its initialization in this section.

\subsection{Descriptor Tables}
\subsubsection{Global Descriptor Table (GDT)}
\subsubsection{Interrupt Descriptor Table (IDT)}
\subsubsection{Local Descriptor Table (LDT)}

\subsection{Registers}
Segment, general purpose, floating point, SIMD

\subsection{MSR}
All MSRs/ read written.

\subsection{Serial port}
Initialized to get any output.

\subsection{Interrupt controllers}

\subsubsection{PIC}
We have to use that before the BSP core has spawned the ACPI server.

\subsubsection{APIC}
We don't use that anymore.

\subsubsection{xAPIC}
We use that.

\subsubsection{x2APIC}
Not yet supported.


\section{System call API}
This section describe the architectural system calls that are not 
common with other architectures.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv}
\bibliography{barrelfish}

\end{document}
