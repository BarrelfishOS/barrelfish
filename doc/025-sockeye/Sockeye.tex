%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2017, ETH Zurich.
% All rights reserved.
%
% This file is distributed under the terms in the attached LICENSE file.
% If you do not find this file, copies can be found by writing to:
% ETH Zurich D-INFK, Universitaetstr 6, CH-8092 Zurich. Attn: Systems Group.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\providecommand{\pgfsyspdfmark}[3]{}

\documentclass[a4paper,11pt,twoside]{report}
\usepackage{amsmath}
\usepackage{bftn}
\usepackage{calc}
\usepackage{verbatim}
\usepackage{xspace}
\usepackage{pifont}
\usepackage{pxfonts}
\usepackage{textcomp}

\usepackage{multirow}
\usepackage{listings}
\usepackage{todonotes}
\usepackage{hyperref}

\title{Sockeye in Barrelfish}
\author{Barrelfish project}
% \date{\today}   % Uncomment (if needed) - date is automatic
\tnnumber{025}
\tnkey{Sockeye}


\lstdefinelanguage{Sockeye}{
    morekeywords={is,are,accept,map,over,to,at},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
}

\presetkeys{todonotes}{inline}{}

\begin{document}
\maketitle      % Uncomment for final draft

\begin{versionhistory}
\vhEntry{0.1}{15.06.2017}{DS}{Initial Version}
\end{versionhistory}

% \intro{Abstract}    % Insert abstract here
% \intro{Acknowledgements}  % Uncomment (if needed) for acknowledgements
\tableofcontents    % Uncomment (if needed) for final draft
% \listoffigures    % Uncomment (if needed) for final draft
% \listoftables     % Uncomment (if needed) for final draft
\cleardoublepage
\setcounter{secnumdepth}{2}

\newcommand{\fnname}[1]{\textit{\texttt{#1}}}%
\newcommand{\datatype}[1]{\textit{\texttt{#1}}}%
\newcommand{\varname}[1]{\texttt{#1}}%
\newcommand{\keywname}[1]{\textbf{\texttt{#1}}}%
\newcommand{\pathname}[1]{\texttt{#1}}%
\newcommand{\tabindent}{\hspace*{3ex}}%
\newcommand{\Sockeye}{\lstinline[language=Sockeye]}
\newcommand{\Prolog}{\lstinline[language=Prolog]}
\newcommand{\ccode}{\lstinline[language=C]}

\lstset{
  basicstyle=\ttfamily \small,
  keywordstyle=\bfseries,
  flexiblecolumns=false,
  basewidth={0.5em,0.45em},
  boxpos=t,
  captionpos=b,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction and usage}
\label{chap:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Sockeye}\footnote{Sockeye salmon (Oncorhynchus nerka), also called red salmon, kokanee salmon, or blueback salmon, is an anadromous species of salmon found in the Northern Pacific Ocean and rivers discharging into it. This species is a Pacific salmon that is primarily red in hue during spawning. They can grow up to 84 cm in length and weigh 2.3 to 7 kg. 
Source: \href{https://en.wikipedia.org/wiki/Sockeye_salmon}{Wikipedia}}
is a domain specific language to describe SoCs (Systems on a Chip).
It is an implementation of the language introduced in \cite{achermann:mars17} but adds some features to address issues encountered in practise.

\todo{Add short introduction on decoding nets.}

The Sockeye compiler is written in Haskell using the Parsec parsing library. It
generates Prolog files from the Sockeye files. These Prolog files contain facts that represent a decoding net as defined in \cite{achermann:mars17}.
The Prolog files can then be loaded into Barrelfish's System Knowledgebase (SKB).

The source code for Sockeye can be found in \pathname{SOURCE/tools/sockeye}.


\section{Command line options}

\begin{verbatim}
$ sockeye [options] file
\end{verbatim}


The available options are:
\begin{description}
\item[-P] Generate a Prolog file that can be loaded into the SKB.
\item[-C] Just perform checks, do not compile.
\item[-o] \varname{filename} The path to the output file (including the file extension)
\item[-h] show usage information
\end{description}

The backend (capital letter options) specified last takes precedence.

The Sockeye file to compile is given via the \textit{file} parameter.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lexical Conventions}
\label{chap:lexer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Sockeye parser follows a similar convention as opted by modern day 
programming languages like C and Java. Hence, Sockeye uses a Java-style-like
parser based on the Haskell Parsec Library. The following conventions are used:

\begin{description}
\item[Encoding] The file should be encoded using plain text.
\item[Whitespace:]  As in C and Java, Sockeye considers sequences of
  space, newline, tab, and carriage return characters to be
  whitespace.  Whitespace is generally not significant. 

\item[Comments:] Sockeye supports C-style comments.  Single line comments
  start with \texttt{//} and continue until the end of the line.
  Multiline comments are enclosed between \texttt{/*} and \texttt{*/};
  anything inbetween is ignored and treated as white space.
  Nested comments are not supported.

\item[Identifiers:] Valid Sockeye identifiers are sequences of numbers
  (0-9), letters (a-z, A-Z), the underscore character ``\texttt{\_}'' and the dash character ``\textendash''. They
  must start with a letter.
  \begin{align*}
  identifier & \rightarrow letter (letter \mid digit \mid \text{\_} \mid \text{\textendash})^{\textrm{*}} \\
  letter & \rightarrow (\textsf{A \ldots Z} \mid  \textsf{a \ldots z})\\
  digit & \rightarrow (\textsf{0 \ldots 9})
	\end{align*}

\item[Case sensitivity:] Sockeye is case sensitive hence identifiers \Sockeye{node1} and \Sockeye{Node2} are not the same.
  
\item[Integer Literals:] A Sockeye integer literal is a sequence of
  digits, optionally preceded by a radix specifier.  As in C, decimal (base 10)
  literals have no specifier and hexadecimal literals start with
  \texttt{0x}. Octal literals start with \texttt{0o}.

\begin{align*}
decimal & \rightarrow (\textsf{0 \ldots 9})^{\textrm{1}}\\
hexadecimal & \rightarrow (\textsf{0x})(\textsf{0 \ldots 9} \mid \textsf{A \ldots F} \mid \textsf{a \ldots f})^{\textrm{1}}\\
octal & \rightarrow (\textsf{0o})(\textsf{0 \ldots 7})^{\textrm{1}}\\
\end{align*}

\item[Reserved words:] The following are reserved words in Sockeye:
\begin{verbatim}
is, are, accept, map, over, to, at
\end{verbatim}

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Decoding Net Declaration}
\label{chap:declaration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter we define the layout of a Sockeye file. Each Sockeye file contains the declaration of a single decoding net.
An SoC can be split into multiple decoding nets e.g. one for the address spaces and another one for the interrupt routes.
However a node in a decoding net can not reference a node in a different decoding net (see also Section~\ref{sec:modularity} for further information).

\section{Syntax}

\subsection{Syntax Specification}
We use EBNF to specify the Sockeye syntax. Terminals are \textbf{bold}.
The non-terminals \textit{iden}, \textit{integer} and \textit{decimal} correspond to identifiers, integer literals and decimal literals from Chapter~\ref{chap:lexer}.

\subsection{Net specification}
A net consists of one or more node declarations.
A node declaration contains one or more identifiers and the node specification.
The order in which the nodes are declared does not matter.

\begin{align*}
\textit{net}_s & \mathop{=}
	\Big\{
		\textit{iden}\ \textbf{is}\ \textit{node}_s\
	\Big|\
		\bigl\{ \textit{iden}\bigr\}\ \textbf{are}\ \textit{node}_s
	\Big\} \\
\end{align*}

\paragraph{Example}
\begin{syntax}
	node1 \textbf{is} \ldots

	node2
	node3 \textbf{are} \ldots
\end{syntax}

\subsection{Node specifications}
A node specification consists of a type, a set of accepted addresses, a set of translated addresses and an overlay.
All of these are optional.

\begin{align*}
\textit{node}_s & \mathop{=}
	\Big[
		\textit{type}
	\Big]\ 	
	\Big[
		\textbf{accept [}\ \big\{\textit{block}_s\big\}\ \textbf{]}\ 
	\Big]\ 
	\Big[
		\textbf{map [}\ \big\{\textit{map}_s\big\}\ \textbf{]}\ 
	\Big]\ 
	\Big[
		\textbf{over}\ \textit{iden}
	\Big] \\
\end{align*}

\paragraph{Example}
\begin{syntax}
	node1 \textbf{is} \textit{<type>} \textbf{accept} [\ldots]
	node2 \textbf{is} \textbf{map} [\ldots] \textbf{over} node1
\end{syntax}

\subsection{Node type}
Currently there are two types: \Sockeye{device} and \Sockeye{memory}. A third internal type \Sockeye{other} is given to nodes for which no type is specified.
The \verb|device|-type specifies that the accepted addresses are device registers while the \Sockeye{memory}-type is for memory nodes like RAM or ROM.

\begin{align*}
\textit{type} & \mathop{=}
	\textbf{device}\
	|\
	\textbf{memory} \\
\end{align*}

\paragraph{Example}
\begin{syntax}
	node1 \textbf{is} memory \textbf{accept} [\ldots]
	node2 \textbf{is} device \textbf{accept} [\ldots]
\end{syntax}

\subsection{Addresses}
Addresses can be given as hexadecimal, octal or decimal integers.
\begin{align*}
\textit{addr} & \mathop{=} \textit{integer} \\
\end{align*}

\clearpage
\subsection{Block specification}{}
A block is specified by its start and end address.
If the start and end address are the same, the end address can be omitted.
Sockeye also supports specifying a block as its base address and the number of address bits the block spans:
A block from \texttt{0x0} to \texttt{0xFFF} with a size of 4kB can be specified as \Sockeye|0x0/12|.

\begin{align*}
\textit{block}_s & \mathop{=} \textit{addr}\
	\Big[
		\textbf{-}\ \textit{addr}\ 
	\Big|\
		\textbf{/}decimal
	\Big] \\
\end{align*}

\paragraph{Example}
\begin{syntax}
	node1 is \textbf{accept} [0x42-0x51]
	node2 is \textbf{accept} [0x42]      // \textit{same as \textup{0x42-0x42}}
	node3 is \textbf{accept} [0x0/12]    // \textit{same as \textup{0x00-0xFFF}}
\end{syntax}

\subsection{Map specification}
A map specification is a source address block, a target node identifier and optionally a target base address to which the source block is translated within the target node.
If no target base address is given, the block is translated to the same addresses within the target node.
Multiple translation targets can be specified by giving a comma-separated list of targets.

\begin{align*}
\textit{map}_s & \mathop{=}
\textit{block}_s\ \textbf{to}\ \textit{iden}\ 
	\Big[
		\textbf{at}\ \textit{addr}
	\Big]\
	\Big\{
		\textbf{,}\ \textit{iden}\ 
		\Big[
			\textbf{at}\ \textit{addr}
		\Big]
	\Big\} \\
\end{align*}

\paragraph{Example}
\begin{syntax}
	/* \textit{Translate \textup{0x0-0xFF} to \textup{node2} at \textup{0x300-0x3FF}:} */
	node1 is \textbf{map} [0x0/8 \textbf{to} node2 \textbf{at} 0x300] 

	/* \textit{This is the same as \textup{0x300/8 \textbf{to} node1 \textbf{at} 0x300}:} */
	node2 is \textbf{map} [0x300/8 \textbf{to} node1]

	/* \textit{Multiple translation targets, \textup{0x0-0xFF} is translated to
	   - \textup{node1} at \textup{0x0-0xFF}
	   - \textup{node2} at \textup{0x300-0x3FF}:} */
	node3 is \textbf{map} [0x0/8 \textbf{to} node1, node2 \textbf{at} 0x300]
\end{syntax}

\section{Example Specification}
Listing~\ref{lst:sockeye_example} shows an example Sockeye specification.

\lstinputlisting[caption={Example Sockeye specification}, label={lst:sockeye_example}, language=Sockeye]{example.soc}

The specification for the Texas Instruments OMAP4460 SoC used on the PandaboardES can serve as a real world example. It is located in \pathname{SOURCE/socs/omap4460.soc}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Checks on the AST}
\label{chap:checks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The Sockeye compiler performs some sanity checks on the parsed AST.

\section{No Duplicate Identifiers}
This check makes sure that there aren't two node declarations with the same identifier.

\section{No References to Undefined Nodes}
This check makes sure that all nodes referenced in translation sets and overlays are declared in the same file.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Prolog Mapping for Sockeye}
\label{chap:prolog}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The Sockeye compiler generates \(\text{ECL}^i\text{PS}^e\)-Prolog\footnote{\href{http://eclipseclp.org/}{http://eclipseclp.org/}} to be used within the SKB.
A decoding net is expressed by the predicate \Prolog{net/2}. The first argument to the predicate is the node identifier represented as a Prolog atom.
The second argument is the node specification, a Prolog functor with the name \Prolog{node} and an arity of four. The arguments of the functor are the node type, the list of accepted addresses, the list of translated addresses and the overlay.

The node type is one of three atoms: \Prolog{device}, \Prolog{memory} or \Prolog{other}.
The accepted addresses are a list of address blocks where each block is represented through the functor \Prolog{block/2} with the start and end addresses as arguments.
The translated addresses are a list of mappings to other nodes, represented by the functor \Prolog{map/3} where the first argument is the translated address block, the second one is the node identifier of the target node and the third one is the base address for the mapping in the target node.
The overlay is represented as an atom which is either the node identifier of the overlay node or \Prolog{'@none'} for nodes with no overlay.

There is a predicate clause for \Prolog{net/2} for every node specified. 
Listings~\ref{lst:prolog_example} shows the generated Prolog code for the Sockeye example in Listing~\ref{lst:sockeye_example}.

\lstinputlisting[caption={Generated Prolog code},label={lst:prolog_example},language=Prolog]{example.pl}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Limitations}
\label{chap:limitations}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modularity}
\label{sec:modularity}
\todo{Add description of challenges}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Compiling Sockeye files with Hake}
\label{chap:hake}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SoC descriptions are placed in the directory \pathname{SOURCE/socs} with the file extension \pathname{.soc}.
Each Sockeye file has to be added to the list of SoCs in the Hakefile in the same directory.
The Hake rule for Sockeye files compiles all the listed files to \pathname{BUILD/sockeyefacts/<filename>.pl} if they are specified as a dependency in some Hakefile.
To add a compiled Sockeye specification to the SKB RAM-disk, the filename can be added to the \varname{sockeyeFiles} list in the SKBs Hakefile.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv}
\bibliography{defs,barrelfish}

\end{document}