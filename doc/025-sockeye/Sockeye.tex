%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2017, ETH Zurich.
% All rights reserved.
%
% This file is distributed under the terms in the attached LICENSE file.
% If you do not find this file, copies can be found by writing to:
% ETH Zurich D-INFK, Universitaetstr 6, CH-8092 Zurich. Attn: Systems Group.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\providecommand{\pgfsyspdfmark}[3]{}

\documentclass[a4paper,11pt,twoside]{report}
\usepackage{amsmath}
\usepackage{bftn}
\usepackage{calc}
\usepackage{verbatim}
\usepackage{xspace}
\usepackage{pifont}
\usepackage{pxfonts}
\usepackage{textcomp}

\usepackage{multirow}
\usepackage{listings}
\usepackage{todonotes}
\usepackage{hyperref}

\title{Sockeye in Barrelfish}
\author{Barrelfish project}
% \date{\today}   % Uncomment (if needed) - date is automatic
\tnnumber{025}
\tnkey{Sockeye}


\lstdefinelanguage{sockeye}{
    morekeywords={is,are,accept,map,over,to,at},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
}

\presetkeys{todonotes}{inline}{}

\begin{document}
\maketitle      % Uncomment for final draft

\begin{versionhistory}
\vhEntry{0.1}{12.06.2017}{DS}{Initial Version}
\end{versionhistory}

% \intro{Abstract}    % Insert abstract here
% \intro{Acknowledgements}  % Uncomment (if needed) for acknowledgements
\tableofcontents    % Uncomment (if needed) for final draft
% \listoffigures    % Uncomment (if needed) for final draft
% \listoftables     % Uncomment (if needed) for final draft
\cleardoublepage
\setcounter{secnumdepth}{2}

\newcommand{\fnname}[1]{\textit{\texttt{#1}}}%
\newcommand{\datatype}[1]{\textit{\texttt{#1}}}%
\newcommand{\varname}[1]{\texttt{#1}}%
\newcommand{\keywname}[1]{\textbf{\texttt{#1}}}%
\newcommand{\pathname}[1]{\texttt{#1}}%
\newcommand{\tabindent}{\hspace*{3ex}}%
\newcommand{\Sockeye}{\lstinline[language=sockeye]}
\newcommand{\ccode}{\lstinline[language=C]}

\lstset{
  language=C,
  basicstyle=\ttfamily \small,
  keywordstyle=\bfseries,
  flexiblecolumns=false,
  basewidth={0.5em,0.45em},
  boxpos=t,
  captionpos=b
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction and usage}
\label{chap:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Sockeye}\footnote{Sockeye salmon (Oncorhynchus nerka), also called red salmon, kokanee salmon, or blueback salmon, is an anadromous species of salmon found in the Northern Pacific Ocean and rivers discharging into it. This species is a Pacific salmon that is primarily red in hue during spawning. They can grow up to 84 cm in length and weigh 2.3 to 7 kg. 
Source: \href{https://en.wikipedia.org/wiki/Sockeye_salmon}{Wikipedia}}
is a domain specific language to describe SoCs (Systems on a Chip).
It is an implementation of the language introduced in \cite{achermann:mars17} but adds some features to address issues encountered in practise.

The Sockeye compiler is written in Haskell using the Parsec parsing library. It
generates Prolog files from the Sockeye files. These Prolog files contain facts that represent a decoding net as defined in \cite{achermann:mars17}.
The Prolog files can then be loaded into Barrelfish's System Knowledgebase (SKB).

The source code for Sockeye can be found in \texttt{SOURCE/tools/sockeye}.


\section{Command line options}
\label{sec:cmdline}

\begin{verbatim}
$ sockeye [options] file
\end{verbatim}


The available options are:
\begin{description}
	\item[-P] Generate a Prolog file that can be loaded into the SKB.
	\item[-C] Just perform checks, do not compile.
  \item[-o] \textit{filename} The path to the output file (including the file extension)
  \item[-h] show usage information
\end{description}

The backend (capital letter options) specified last takes precedence.

The Sockeye file to compile is give via the \textit{file} parameter.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lexical Conventions}
\label{chap:lexer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Sockeye parser follows a similar convention as opted by modern day 
programming languages like C and Java. Hence, Sockeye uses a Java-style-like
parser based on the Haskell Parsec Library. The following conventions are used:

\begin{description}
\item[Encoding] The file should be encoded using plain text.
\item[Whitespace:]  As in C and Java, Sockeye considers sequences of
  space, newline, tab, and carriage return characters to be
  whitespace.  Whitespace is generally not significant. 

\item[Comments:] Sockeye supports C-style comments.  Single line comments
  start with \texttt{//} and continue until the end of the line.
  Multiline comments are enclosed between \texttt{/*} and \texttt{*/};
  anything inbetween is ignored and treated as white space.

\item[Identifiers:] Valid Sockeye identifiers are sequences of numbers
  (0-9), letters (a-z, A-Z), the underscore character ``\texttt{\_}'' and hyphens ``\texttt{-}''. They
  must start with a letter.
  \begin{align*}
  identifier & \rightarrow letter (letter \mid digit \mid \_ \mid -)^{\textrm{*}} \\
  letter & \rightarrow (\textsf{A \ldots Z} \mid  \textsf{a \ldots z})\\
  digit & \rightarrow (\textsf{0 \ldots 9})
	\end{align*}
  
\item[Integer Literals:] A Sockeye integer literal is a sequence of
  digits, optionally preceded by a radix specifier.  As in C, decimal (base 10)
  literals have no specifier and hexadecimal literals start with
  \texttt{0x}. Octal literals start with \texttt{0o}.

\begin{align*}
decimal & \rightarrow (\textsf{0 \ldots 9})^{\textrm{1}}\\
hexadecimal & \rightarrow (\textsf{0x})(\textsf{0 \ldots 9} \mid \textsf{A \ldots F} \mid \textsf{a \ldots f})^{\textrm{1}}\\
octal & \rightarrow (\textsf{0o})(\textsf{0 \ldots 7})^{\textrm{1}}\\
\end{align*}

\item[Reserved words:] The following are reserved words in Sockeye:
\begin{verbatim}
is, are, accept, map, over, to, at
\end{verbatim}

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Decoding Net Declaration}
\label{chap:declaration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter we define the layout of a Sockeye file. Each Sockeye file contains the declaration of a single decoding net.
An SoC can be split into multiple decoding nets e.g. one for the address spaces and another one for the interrupt routes.
However a node in a decoding net can not reference a node in a different decoding net.

\section{Syntax}

\subsection{Syntax Specification}
We use EBNF to specify the Sockeye syntax. Terminals are \textbf{bold}.
The non-terminals \textit{iden}, \textit{integer} and \textit{decimal} correspond to the identifiers, integer literals and decimal literals from Chapter~\ref{chap:lexer}.

\subsection{Net specification}
A net consists of one or more node declarations.
A node declaration contains one or more identifiers and the node specification.
The order in which the nodes are declared does not matter.

\begin{align*}
\textit{net}_s & \mathop{=}
	\Big\{
		\textit{iden}\ \textbf{is}\ \textit{node}_s\
	\Big|\
		\bigl\{ \textit{iden}\bigr\}\ \textbf{are}\ \textit{node}_s
	\Big\} \\
\end{align*}

\subsection{Node specifications}
A node specification consists of a type, a set of accepted addresses, a set of translated addresses and an overlay.
All of these are optional.

\begin{align*}
\textit{node}_s & \mathop{=}
	\Big[
		\textit{type}
	\Big]\ 	
	\Big[
		\textbf{accept [}\ \big\{\textit{block}_s\big\}\ \textbf{]}\ 
	\Big]\ 
	\Big[
		\textbf{map [}\ \big\{\textit{map}_s\big\}\ \textbf{]}\ 
	\Big]\ 
	\Big[
		\textbf{over}\ \textit{iden}
	\Big] \\
\end{align*}

\subsection{Node type}
Currently there are two types: \verb|device| and \verb|memory|. A third internal type \verb|other| is given to nodes for which no type is specified.
The \verb|device|-type specifies that the accepted addresses are device registers while the \verb|memory|-type is for memory nodes like RAM or ROM.

\begin{align*}
\textit{type} & \mathop{=}
	\textbf{device}\
	|\
	\textbf{memory} \\
\end{align*}

\subsection{Addresses}
Addresses can be given as hexadecimal, octal or decimal integers.
\begin{align*}
\textit{addr} & \mathop{=} \textit{integer} \\
\end{align*}

\subsection{Block specification}
A block is specified by its start and end address.
If the start and end address are the same, the end address can be omitted.
Sockeye also supports specifying a block as its base address and the number of address bits the block spans:
A block from \texttt{0x0} to \texttt{0xFFF} with a size of 4kB can be specified ass \verb|0x0/12|.

\begin{align*}
\textit{block}_s & \mathop{=} \textit{addr}\
	\Big[
		\textbf{-}\ \textit{addr}\ 
	\Big|\
		\textbf{/}decimal
	\Big] \\
\end{align*}

\subsection{Map specification}
A map specification is a source address block, a target node identifier and optionally a target base address where the source block to which the source block is translated.
Multiple translation targets can be specified by giving a comma-separated list of targets.

\begin{align*}
\textit{map}_s & \mathop{=}
\textit{block}_s\ \textbf{to}\ \textit{iden}\ 
	\Big[
		\textbf{at}\ \textit{addr}
	\Big]\
	\Big\{
		\textbf{,}\ \textit{iden}\ 
		\Big[
			\textbf{at}\ \textit{addr}
		\Big]
	\Big\} \\
\end{align*}

\section{Conventions}
\todo{Specify conventions}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Checks on the AST}
\label{chap:checks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The Sockeye compiler performs some sanity checks on the parsed AST.

\section{No Duplicate Identifiers}
This check makes sure that there aren't two node declarations with the same identifier.

\section{No References to Undefined Nodes}
This check makes sure that all nodes referenced in translation sets and overlays are declared in the same file.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Prolog Mapping for Sockeye}
\label{chap:prolog}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\todo{Describe Prolog fact layout}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Compiling Sockeye files with Hake}
\label{chap:hake}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SoC descriptions are placed in the directory \texttt{SOURCE/socs} with the file extension \texttt{.soc}.
Each Sockeye file has to be added to the list of SoCs in the Hakefile in the same directory.
The Hake rule for Sockeye files compiles all the listed files to \texttt{BUILD/sockeyefacts/<filename>.pl} if they are specified as a dependency in some Hakefile.
To add a compiled Sockeye specification into the SKB RAM disk, the filename can be added to the \verb|sockeyeFiles| list in the SKBs Hakefile.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv}
\bibliography{barrelfish}

\end{document}
