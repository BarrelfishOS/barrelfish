%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2018, ETH Zurich.
% All rights reserved.
%
% This file is distributed under the terms in the attached LICENSE file.
% If you do not find this file, copies can be found by writing to:
% ETH Zurich D-INFK, Universitaetstr 6, CH-8092 Zurich. Attn: Systems Group.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\providecommand{\pgfsyspdfmark}[3]{}

\documentclass[a4paper,11pt,twoside]{report}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{bftn}
\usepackage{calc}
\usepackage{verbatim}
\usepackage{xspace}
\usepackage{pifont}
\usepackage{pxfonts}
\usepackage{textcomp}
\usepackage[xindy,nowarn]{glossaries}

\usepackage{multirow}
\usepackage{listings}
\usepackage{todonotes}
\usepackage{hyperref}

\title{Sockeye in Barrelfish}
\author{Barrelfish project}
% \date{\today}   % Uncomment (if needed) - date is automatic
\tnnumber{025}
\tnkey{Sockeye}


\lstdefinelanguage{Sockeye}{
    morekeywords={accept, are, as, at, import, in, input, is, map, module, output, over, reserved, to, with},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
}

\newacronym{ast}{AST}{abstract syntax tree}
\newacronym{dsl}{DSL}{domain specific language}
\newacronym{hdn}{HDN}{hardware decoding net}
\newacronym{skb}{SKB}{System Knowledge Base}
\newacronym[longplural={systems on a chip}]{soc}{SoC}{system on a chip}

\makeglossaries

\presetkeys{todonotes}{inline}{}

\begin{document}
\maketitle      % Uncomment for final draft

\begin{versionhistory}
\vhEntry{0.1}{15.06.2017}{DS}{Initial Version}
\vhEntry{0.2}{03.08.2017}{DS}{Describe Modularity Features}
\vhEntry{0.3}{09.02.2018}{DS}{Sockeye 2.0}
\end{versionhistory}

% \intro{Abstract}    % Insert abstract here
% \intro{Acknowledgements}  % Uncomment (if needed) for acknowledgements
\tableofcontents    % Uncomment (if needed) for final draft
% \listoffigures    % Uncomment (if needed) for final draft
% \listoftables     % Uncomment (if needed) for final draft
\cleardoublepage
\setcounter{secnumdepth}{2}

\newcommand{\fnname}[1]{\textit{\texttt{#1}}}%
\newcommand{\datatype}[1]{\textit{\texttt{#1}}}%
\newcommand{\varname}[1]{\texttt{#1}}%
\newcommand{\keywname}[1]{\textbf{\texttt{#1}}}%
\newcommand{\pathname}[1]{\texttt{#1}}%
\newcommand{\tabindent}{\hspace*{3ex}}%
\newcommand{\Sockeye}{\lstinline[language=Sockeye]}
\newcommand{\Prolog}{\lstinline[language=Prolog]}
\newcommand{\ccode}{\lstinline[language=C]}

\lstset{
  basicstyle=\ttfamily \small,
  keywordstyle=\bfseries,
  flexiblecolumns=false,
  basewidth={0.5em,0.45em},
  boxpos=t,
  captionpos=b,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction and Usage}
\label{chap:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Sockeye}\footnote{Sockeye salmon (Oncorhynchus nerka), also called red salmon, kokanee salmon, or blueback salmon, is an anadromous species of salmon found in the Northern Pacific Ocean and rivers discharging into it. This species is a Pacific salmon that is primarily red in hue during spawning. They can grow up to 84 cm in length and weigh 2.3 to 7 kg. 
Source: \href{https://en.wikipedia.org/wiki/Sockeye_salmon}{Wikipedia}}
is a \gls{dsl} to describe \glspl{soc}

Achermann~et~al. propose a formal model to describe hardware as a directed graph~\cite{achermann:mars17}.
For the rest of this technote we'll call such a graph a \gls{hdn}.
The model captures the complex interactions within an between address translation hardware and the interrupt system.
There is also work being done to extend the model to include clock distribution and power management.

Each node in the graph can accept a set of addresses and translate another (not necessarily disjunct) set of addresses (when describing interrupt routes they accept or translate interrupt vectors).
While the nodes are modeled explicitly, the edges are implicitly given by the translation sets of the nodes.

Starting at a specific node, addresses can be resolved by following the appropriate edges in the \gls{hdn}.
When a node translates an address, resolution is continued at the referenced node.
When a node accepts an address, resolution terminates

Sockeye uses \glspl{hdn} as its underlying model.
If offers language features to efficiently describe real hardware.

We currently envision two main use cases for Sockeye:
\begin{itemize}
  \item Generate Isabell/HOL code from Sockeye specifications to be able to formally reason about the described hardware.
  \item Generate Prolog files that can be loaded into Barrelfish's \gls{skb} for the system to be able to reason about the hardware it's running on.
\end{itemize}

The Sockeye compiler is written in Haskell using the Parsec parsing library.
The source code for the compiler can be found in \pathname{SOURCE/tools/sockeye}.
\todo{DS: The code for the old version is in the subdirectory \pathname{v1}.
To not break building the tree \pathname{BUILD/tools/bin/sockeye} is compiled from the old code.
The new code is compiled to \pathname{BUILD/tools/bin/sockeye2}.}


\clearpage
\section{Command Line Options}

\begin{verbatim}
$ sockeye [options] file
\end{verbatim}


The available options are:
\begin{description}
\item[-P] Generate a Prolog file that can be loaded into the \gls{skb} (default).
\item[-I] Generate Isabelle/HOL code to formally reason about hardware.
\item[-i] Add a directory to the search path where Sockeye looks for imports.
\item[-o] \varname{filename} The path to the output file (required)
\item[-d] \varname{filename} The path to the dependency output file (optional)
\item[-h] show usage information
\end{description}

The backend (capital letter options) specified last takes precedence.
\todo{DS: The backends are not yet implemented in the new compiler version.
For debugging purposes there are command line options to dump various internal data structures.
Use -h for more info.}

Multiple directories can be added by giving the \texttt{-i} options multiple times.
Sockeye will first look for files in the current directory and then check the given directories in the order they were given.

When invoked with the \texttt{-d} option, the compiler will generate a dependency file for GNU make to be able to track changes in imported files.

The Sockeye file to compile is given via the \texttt{file} parameter.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Language Constructs \& Syntax}
\label{chap:syntax}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This chapter describes the language constructs in Sockeye and their syntax.
We use EBNF to describe the Sockeye syntax. Terminals are \textbf{bold} while non-terminals are \textit{italic}.
\todo{Do we really need a formal syntax description here? Aren't examples enough?}
The non-terminal \textit{iden} denotes an identifier.
The non-terminals \textit{letter}, \textit{decimal} and \textit{hexadecimal} are defined as expected.
The precise definition of these non-terminals is found in Chapter~\ref{chap:lexer}.

Most of the examples are taken from the Texas Instruments OMAP44xx SoC as used on the PandaboardES\footnote{The technical reference manual can be found \href{http://www.ti.com/lit/ug/swpu235ab/swpu235ab.pdf}{here}.}.

\section{Natural Numbers}
Sockeye supports addition, subtraction and multiplication of natural numbers.
Additionally natural numbers can be interpreted as bit arrays and can then be \emph{sliced} (selecting a contiguous range of bits of a number's binary representation) and \emph{concatenated}.
\begin{example}
  /* Slicing: */
  4[0] = 0
  4[1] = 0
  4[2] = 14
  5[1 to 2] = 0b10 = 2

  /* Concatenation: */
  8 ++ 0xF[1 to 2] = 0b100011 = 35
\end{example}

The concatenation operator is left associative and the right hand side has to be a slice expression for the concatenation to be defined (the number of bits the left hand side has to be shifted has to be known). The operator precedence for the standard operations is as expected, slicing has higher precedence than the standard operations and concatenation has lower precedence.

Sockeye also has syntax to describe contiguous ranges of natural numbers:
\begin{example}
  /* Singleton range */
  42

  /* Base and limit */
  0 to 8 // 0 up to and including 8
  5 to 11

  /* Base base and a number of variable bits */
  (0 bits 2) // 0 up to and excluding 2^4

  /* The variable bits have to be 0 in the base */
  (0x100 bits 8) // OK
  (0x110 bits 8) // Error
\end{example}

A (possibly sparse) set of natural numbers can be expressed as a comma-separated list of contiguous ranges.
\begin{example}
  /* These are equivalent */
  (0 bits 2, 5 to 7, 11)
  (0, 1, 2, 3, 5, 6, 7, 11)
\end{example}

\section{Addresses}
\todo{DS: Do we call them addresses, although might be interrupt vectors, clock signals etc?}
In \glspl{hdn} addresses are natural numbers.
Sockeye models them as tuples of natural numbers.
This allows easier modeling of cases where different parts of an address are used for different purposes.
An example for this would e.g. be a lookup table that uses some bits as an index and prepends the rest of the incoming address with the value indexed by these bits.
Note that this is not more powerful than the underlying model as there is a bijection between tuples of natural numbers and natural numbers (e.g. diagonalisation).

Sockeye syntax not only allows to specify single addresses but address sets.
The dimensions of an address tuple are separated by semicolons:
\begin{example}
  (0; 8; 15)
  (0x0; 0x8; 0xF)
  (0 bits 12; 0 bits 8; 0 bits 12)
\end{example}

An address set contains all addresses in the Cartesian product of its dimensions.

\section{Nodes}
Sockeye nodes closely correspond to nodes in an \gls{hdn}:
They have a set of addresses that they accept, and a set of translations of incoming addresses to other nodes.
In addition Sockeye nodes have an input and output \emph{domain} and \emph{type}.

\paragraph{Domains}
There are the following node domains in Sockeye:
\begin{itemize}
  \item \textit{memory}: Nodes in this domain are part of the memory system. 
  \item \textit{intr}: Nodes in this domain are part of the interrupt system.
  \item \textit{power}: Nodes in this domain are part of the power management system.
  \item \textit{clock}: Nodes in this domain are part of the clock distribution system.
\end{itemize}
Standard nodes have the same input and output domain.
Nodes with different input and output domains are called \emph{conversion nodes}.
They offer a controlled way of crossing the boundaries between domains e.g. to model message signaled interrupts.
\todo{DS: Do we allow all combinations of input/output domains or do we want to e.g. disallow crossing from memory to clock?}

\paragraph{Types} The types in Sockeye allow to constrain the addresses.
A type is simply an address set that the address has to be an element of.

Sockeye separates the declaration of a node and its definition.
However, to keep specifications as readable as possible the definition should immediately follow the declaration whenever possible.

\paragraph{Node Declarations} A node is declared by giving its input domain and type and optionally its output domain and type.

Nodes can either be declared as single nodes or (sparse) node arrays.
The possible array indexes are a set of natural numbers.
\begin{example}
  /* Declare 32bit addressed RAM node */
  \textit{memory} (0 bits 32) SDRAM

  /* If the output domain is not given it defaults to the input domain */
  \textit{memory} (0 bits 32) \textit{memory} SDRAM // Equivalent to the above

  /* 
   * Declare the physical address space of 4 cores
   * (Array indexes do not have to be contiguous)
   */
  \textit{memory} (0 bits 12; 0 bits 8; 0 bits 12) CPU_Physical[1, 3, 5, 7]

  /* Declare a MSIx controller converting memory accesses to interrupts */
  \textit{memory} (0 bits 32) \textit{intr} MSIx_CTRL

  /*
   * Give output type to limit translation range
   * to interrupt vectors 0 ... 1023
   */
  \textit{memory} (0 bits 32) \textit{intr} (0 to 1023) MSIx_CTRL
\end{example}

\paragraph{Node Definitions}
There are four types of statements to define nodes:
\begin{itemize}
  \item \textbf{accepts} is used to define the accepted addresses of a node
  \item \textbf{maps} is used to define the translations done by a node
  \item \textbf{converts} is the same as \textbf{maps} but for conversion nodes.
  This definition statement is only allowed for conversion nodes.
  It is also the only one allowed for conversion nodes.
  \todo{DS: Do we need/want to allow others?}
  \item \textbf{overlays} is used to define a default translation for a node.
  Any address that is neither accepted nor translated explicitly is translated to the overlay node at the same address.
\end{itemize}
A node's definition is given by the union of all the statements about the node.
The definition can contain multiple statements of the same type.

Accepting addresses are defined by giving a list of semicolon-separated address sets.
Address sets are tuples of sets of natural numbers.
All accepted addresses have to be elements of the nodes input type.
\begin{example}
  /*
   * SDRAM accepts all 32bit addresses
   */
  \textit{memory} (0 bits 32) SDRAM
  SDRAM \textbf{accepts} [(0 bits 32)]

 /* Multiple entries (equivalent to above) */
  SDRAM \textbf{accepts} [
    (0x00000000 bits 30);
    (0x40000000 bits 30);
    (0x80000000 bits 30);
    (0xC0000000 bits 30)
  ]

/* Multiple statements (equivalent to above) */
SDRAM \textbf{accepts} [(0x00000000 bits 31)]
SDRAM \textbf{accepts} [(0x80000000 bits 31)]
\end{example}

Translations are defined by giving a semicolon-separated list of origin addresses and translation targets.
A translation targets consists of a node reference and a target address.
The origin addresses have to elements of the node's input type.
The target node has to have the same input domain as the node's output domain.
The target address has to be within the target nodes input type.
If the node has an output type, the target address additionally needs to be in the output type.
\begin{example}
Translation examples
\end{example}

To translate contiguous ranges of addresses, an address set can be given instead of the origin address.
To translate all addresses in a dimension of the node's input type, a wildcard can be used.
If all dimensions of the address set are contiguous, the target address can also be a set with all dimensions being contiguous ranges.
\begin{example}
Advanced translation examples
\end{example}

An overlay represents a default translation target for all addresses that are neither accepted nor explicitly translated.
Nodes can only have overlays if their output type is either unspecified or the same as the input type.
The overlay node's input type has to be the same as the one of the node.
\begin{example}
Overlay examples
\end{example}

\todo{Describe properties}

\section{Named Types}
Sockeye allows to define named types (similar to typedefs in C).
When declaring nodes, these types can then be referenced by name.

\section{Modules}

\section{Sockeye Files}
A Sockeye file consists of named type and module definitions.

\section{Import System}
The import system in Sockeye allows to split the definition of a \gls{hdn} over several files and reuse files in a library like fashion.
A file can either be imported as a whole, meaning all modules and named types from the imported file become available inside the imported file.
Alternatively modules and types can be selectively imported.
With selective imports, modules and types can also be renamed to avoid name clashes.
Imported modules and types are not re-exported.

Imports have to be specified at the top of a Sockeye file.
\begin{example}
Import examples
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lexical Conventions}
\label{chap:lexer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Sockeye parser uses the following conventions:

\begin{description}
\item[Encoding] The file should be encoded using plain text.
\item[Whitespace:]  As in C and Java, Sockeye considers sequences of
  space, newline, tab, and carriage return characters to be
  whitespace.  Whitespace is generally not significant. 

\item[Comments:] Sockeye supports C-style comments.  Single line comments
  start with \texttt{//} and continue until the end of the line.
  Multiline comments are enclosed between \texttt{/*} and \texttt{*/};
  anything in between is ignored and treated as white space.
  Nested comments are not supported.

\item[Identifiers:] Valid Sockeye identifiers are sequences of numbers
  (0-9), letters (a-z, A-Z), the underscore character ``\texttt{\_}'' and the dash character ``\textendash''. They
  must start with a letter.
  \begin{align*}
  identifier & \rightarrow letter (letter \mid digit \mid \text{\_})^{\textrm{*}} \\
  letter & \rightarrow (\textsf{A \ldots Z} \mid  \textsf{a \ldots z})\\
  digit & \rightarrow (\textsf{0 \ldots 9})
    \end{align*}

\item[Case sensitivity:] Sockeye is case sensitive hence identifiers \Sockeye{node1} and \Sockeye{Node2} are not the same.
  
\item[Integer Literals:] A Sockeye integer literal is a sequence of
  digits, optionally preceded by a radix specifier.  As in C, decimal (base 10)
  literals have no specifier and hexadecimal literals start with
  \texttt{0x}.

\begin{align*}
decimal & \rightarrow (\textsf{0 \ldots 9})^{\textrm{1}}\\
hexadecimal & \rightarrow (\textsf{0x})(\textsf{0 \ldots 9} \mid \textsf{A \ldots F} \mid \textsf{a \ldots f})^{\textrm{1}}\\
\end{align*}

\item[Reserved words:] The following are reserved words in Sockeye:
\begin{verbatim}
import, as, module, input, output, type, const,
memory, intr, power, clock,
instance, of, forall, in,
accepts, maps, converts, overlays, instantiates, binds,
to, at, bits
\end{verbatim}

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Syntax}
\label{chap:declaration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter we define the layout of a Sockeye file.
The node declarations in a Sockeye file describe a single \gls{hdn}.
Parts of a \gls{hdn} can be packaged into reusable modules (see Section~\ref{sec:modules}).
With imports (see Section~\ref{sec:imports}) modules can also be put into separate files.

In the following sections we use EBNF to describe the Sockeye syntax. Terminals are \textbf{bold} while non-terminals are \textit{italic}.
The non-terminals \textit{iden}, \textit{letter}, \textit{decimal} and \textit{hexadecimal} correspond to the ones defined in Chapter~\ref{chap:lexer}.

The examples are all taken from the Texas Instruments OMAP4460 SoC used on the PandaboardES\footnote{The technical reference manual can be found \href{http://www.
ti.com/lit/ug/swpu235ab/swpu235ab.pdf}{here}.}.
A more complete specification of the SoC is located in \pathname{SOURCE/socs/omap44xx.soc}.

\section{Basic Syntax}
This section describes the basic syntax for Sockeye.


\subsection{Node Declarations}
A node declaration contains one or more identifiers and the node specification.
The order in which the nodes are declared does not matter.

\paragraph{Syntax}
\begin{align*}
\textit{net}_s & \mathop{=}
    \Big\{
        \textit{iden}\ \textbf{is}\ \textit{node}_s\
    \Big|\
        \textit{iden}\bigl\{\textbf{,}\ \textit{iden}\bigr\}\ \textbf{are}\ \textit{node}_s
    \Big\} \\
\end{align*}

\clearpage
\paragraph{Example}
\begin{example}
    SDRAM \textbf{is} \ldots

    UART1,
    UART2 \textbf{are} \ldots
\end{example}

\subsection{Node Specifications}
A node specification consists of a type, a set of accepted address blocks, a set of address mappings to other nodes, a set of reserved address blocks and an overlay.
All of these are optional.
The reserved address blocks are only relevant in conjunction with overlays and are used to exclude some addresses from the overlay.
The overlay is specified as a node identifier and a number of address bits.
The overlay will span addresses from \texttt{0x0} to \(\texttt{0x2}^\texttt{bits} - \texttt{1}\).

\paragraph{Syntax}
\begin{align*}
\textit{node}_s & \mathop{=}
    \Big[\ 
       \textit{type}\ 
    \Big]\  
    \Big[
       \textit{accept}\ 
    \Big]\ 
    \Big[\ 
       \textit{map}\ 
    \Big]\ 
    \Big[\ 
        \textit{reserved}\ 
    \Big]\ 
    \Big[\ 
        \textit{overlay}\ 
    \Big]\\
\textit{accept} & \mathop{=}
    \textbf{accept [}\ \big\{\ \textit{block}_s\ \big\}\ \textbf{]}\\
\textit{map} & \mathop{=}
    \textbf{map [}\ \big\{\ \textit{map}_s\ \big\}\ \textbf{]}\\
\textit{reserved} & \mathop{=}
    \textbf{reserved [}\ \big\{\ \textit{block}_s\ \big\}\ \textbf{]}\\
\textit{overlay} & \mathop{=}
    \textbf{over}\ \textit{iden}\textbf{/}\textit{decimal}\\
\end{align*}

\paragraph{Example}
\begin{example}
    SDRAM \textbf{is} \textbf{accept} [\ldots]
    L3 \textbf{is} \textbf{map} [\ldots]
    CORETEXA9_SS_Interconnect \textbf{is} \textbf{reserved} [\ldots] \textbf{over} L3/32
\end{example}

\subsection{Node Type}
Currently there are three types: \Sockeye{core}, \Sockeye{device} and \Sockeye{memory}. A fourth internal type \Sockeye{other} is given to nodes for which no type is specified.
The \Sockeye{core} type designates the node as a CPU core. The \Sockeye{device} type specifies that the accepted addresses are device registers while the \Sockeye{memory} type is for memory nodes like RAM or ROM.

\paragraph{Syntax}
\begin{align*}
\textit{type} & \mathop{=}
    \textbf{core}\
    |\
    \textbf{device}\
    |\
    \textbf{memory} \\
\end{align*}

\paragraph{Example}
\begin{example}
    CORETEXA9_1 \textbf{is} core \textbf{map} [\ldots]
    UART3 \textbf{is} device \textbf{accept} [\ldots]
    SDRAM \textbf{is} memory \textbf{accept} [\ldots]
\end{example}

\subsection{Addresses}
Addresses are specified as hexadecimal literals.

\paragraph{Syntax}
\begin{align*}
\textit{addr} & \mathop{=} \textit{hexadecimal} \\
\end{align*}

\subsection{Block Specifications}
A block is specified by its start and end address.
If the start and end address are the same, the end address can be omitted.
Sockeye also supports specifying a block as its base address and the number of address bits the block spans:
A block from \Sockeye{0x0} to \Sockeye{0xFFF} with a size of 4kB can be specified as \Sockeye{0x0/12}.

\paragraph{Syntax}
\begin{align*}
\textit{block}_s & \mathop{=} \textit{addr}\
    \Big[
        \textbf{-}\ \textit{addr}\ 
    \Big|\
        \textbf{/}\textit{decimal}
    \Big] \\
\end{align*}

\paragraph{Example}
\begin{example}
    UART1 is \textbf{accept} [0x0-0xFFF]
    UART3 is \textbf{accept} [0x0/12]    // \textit{same as \textup{0x0-0xFFF}}
    IF_A9_0 is \textbf{accept} [0x44]      // \textit{same as \textup{0x44-0x44}}
\end{example}

\subsection{Map Specification}
A map specification is a source address block, a target node identifier and optionally a target base address to which the source block is translated within the target node.
If no target base address is given, the block is translated to the target node starting at \Sockeye{0x0}.
Note that this is different from the concrete syntax described in \cite{achermann:mars17} where in this case the base address of the source block is used.
This was changed due to the mapping to \Sockeye{0x0} being used more often in practice.
Multiple translation targets can be specified by giving a comma-separated list of targets.

\paragraph{Syntax}
\begin{align*}
\textit{map}_s & \mathop{=}
\textit{block}_s\ \textbf{to}\ \textit{iden}\ 
    \Big[
        \textbf{at}\ \textit{addr}
    \Big]\
    \Big\{
        \textbf{,}\ \textit{iden}\ 
        \Big[
            \textbf{at}\ \textit{addr}
        \Big]
    \Big\}\\
\end{align*}

\paragraph{Example}
\begin{example}
    /* \textit{Translate \textup{0x54000000-0x0x54FFFFFF}
     * to \textup{L3_EMU} at \textup{0x54000000-0x0x54FFFFFF}:}
     */
    L3 is \textbf{map} [0x54000000/24 \textbf{to} L3_EMU \textbf{at} 0x54000000] 

    /* \textit{This is the same as \textup{0x80000000/30 \textbf{to} SDRAM \textbf{at} 0x0}:} */
    L3 is \textbf{map} [0x80000000/30 \textbf{to} SDRAM]

    /* \textit{Multiple translation targets, interrupt vector \textup{0x2} is translated to
     * - \textup{SPIMap} at \textup{0xC}
     * - \textup{NVIC} at \textup{0x12}:}
     * /
    SDMA is \textbf{map} [0x2 \textbf{to} SPIMap \textbf{at} 0xC, NVIC \textbf{at} 0x12]
\end{example}

\section{Modules}
\label{sec:modules}
A module encapsulates a \gls{hdn} which can be integrated into a larger \gls{hdn}.
A module instantiation always creates a namespace inside the current one.
Normally nodes can only be referenced by nodes in the same namespace.
To properly integrate a module into a larger \gls{hdn} we need a mechanism to connect the module to the enclosing \gls{hdn}.
This is done via ports.
There are input ports, which create a connection into the module and output ports which create connections from the module to outside nodes.
A port has always a width, specified as the number of address bits the port spans.
All declared input ports must have a corresponding node declaration in the module body.

When a module is instantiated a list of port mappings can be specified.
An input port mapping creates a node outside the module that overlays the node inside the module.
An output port mapping creates a node inside the module that overlays the node outside the module.
Not all ports a module declares have to be mapped.
Not mapping an input port simply means there is no connection to the corresponding node inside the module.
For unmapped output ports an empty node inside the module will be generated, acting as a dead end for address resolution.

Additionally a module can be parametrized.
It will then be a module template that only becomes a fully defined module when instantiated with concrete arguments.
Module parameters are typed and the Sockeye compiler checks that they are used in a type safe way.
There are two types of parameters: address parameters and natural parameters.
Address parameters allow to parametrize addresses in node specifications.
Natural parameters are used in combination with interval template identifiers (see Section~\ref{sec:template_idens}).
Parameters can also be passed as arguments to module template instantiations in the module body.

\subsection{Module Declarations}
A module declaration starts with the keyword \Sockeye{module} and a unique module name.
If the module is a template, a list of typed parameters can be specified.
The module body is enclosed in curly braces and starts with the port definitions.
The rest of the body are node declarations and module instantiations.
If the module has address parameters the name of the parameter can be used wherever in the body an address is expected.

\paragraph{Syntax}
\begin{align*}
    \textit{param\_type} & \mathop{=}
        \textbf{addr}\ |\ \textbf{nat}\\
    \textit{parameter} & \mathop{=}
        \textit{param\_type}\ \textit{iden}\\
    \textit{param\_list} & \mathop{=}
        \textbf{(}\big[\ 
            \textit{parameter}\big\{\textbf{,}\ \textit{parameter}\big\}\ 
        \big] \textbf{)}\\
    \textit{input\_port} & \mathop{=}
        \textbf{input}\ \textit{iden}\textbf{/}\textit{decimal}
        \big\{
            \textbf{,}\ \textit{iden}\textbf{/}\textit{decimal}
        \big\}\\
    \textit{output\_port} & \mathop{=}
        \textbf{output}\ \textit{iden}\textbf{/}\textit{decimal}
        \big\{
            \textbf{,}\ \textit{iden}\textbf{/}\textit{decimal}
        \big\}\\
    \textit{body}_s & \mathop{=}
        \big\{\ 
            \textit{net}_s\ |\ \textit{mod\_inst}_s\ 
        \big\}\\
    \textit{mod\_decl}_s & \mathop{=}
        \textbf{module}\ \textit{iden} \big[\textit{param\_list}\big]\ 
        \textbf{\{}\ 
            \big\{\textit{input\_port}\ |\ \textit{output\_port}\big\}\ 
            \textit{body}_s\ 
        \textbf{\}}\\
\end{align*}

\paragraph{Example}
For some examples of module declarations see Listing~\ref{lst:sockeye_example}.

\subsection{Module Instantiations}
Module instantiations start with the module name and in the case of a module template with the list of arguments.
After that the identifier of the namespace in which to instantiate the module has to be given followed by an optional list of port mappings.

\paragraph{Syntax}
\begin{align*}
    \textit{argument} & \mathop{=}
        \textit{decimal}\ |\ \textit{hexadecimal}\ |\ \textit{iden}\\
    \textit{arg\_list} & \mathop{=}
        \textbf{(}\big[\ 
            \textit{argument}\big\{\textbf{,}\ \textit{argument}\big\}\ 
        \big] \textbf{)}\\
    \textit{mod\_inst}_s & \mathop{=}
        \textit{iden} \big[\textit{arg\_list}\big]\ \textbf{as}\ \textit{iden}\ \big[\ 
            \textbf{with}\ \big\{\textit{input\_map}\ |\ \textit{output\_map}\big\}\ 
        \big]\\
    \textit{input\_map} & \mathop{=}
        \textit{iden}\ \textbf{>}\ \textit{iden}\\
    \textit{output\_map} & \mathop{=}
        \textit{iden}\ \textbf{<}\ \textit{iden}\\
\end{align*}

\clearpage
\paragraph{Example}
\begin{example}
    /* Instantiate module 'CortexA9-Subsystem' in namespace 'CortexA9_SS' */
    CortexA9-Subsystem as CortexA9_SS

    /* Pass arguments to module template e.g. to instantiate a
     * CortexA9 MPCore module with
     * - 2 cores
     * - 0x48240000 as the base of the private memory region
     */
    CortexA9-MPCore(2, 0x48240000) \textbf{as} MPU

    /* Declare port mappings:
     * - map 'CORTEXA9_1' to input port 'CPU_1'
     * - map output port 'Interconnect' to 'L3'
     */
    CortexA9-Subsystem as CortexA9_SS \textbf{with}
        CORTEXA9_1 > CPU_1
        L3 < Interconnect
\end{example}

\section{Templated Identifiers}
\label{sec:template_idens}
Templated identifiers allow to declare multiple nodes and ports at once and instantiate a module multiple times at once.
There are two forms of templated identifiers:
\begin{description}
    \item[Interval template]
        The template contains one or several intervals.
        The identifier will be instantiated for all possible combinations of values in the intervals.
        Index variables can optionally be named so they can be referenced later.
    \item[Simple template]
        Simple templates work very similar to interval templates.
        The only difference is, that a simple template can only reference index variables declared in the same context.
        It can not contain intervals to declare new index variables.
\end{description}

Interval templates can be used in identifiers of node declarations (to declare multiple nodes), port declarations (to declare multiple ports) and namespace identifiers of module instantiations (to instantiate a module multiple times).
The scope of index variables is the corresponding syntactic construct the interval template was used in.
Simple templates can be used in any place a node identifier is expected.
This includes the places where interval templates can be used, identifiers of translation destination nodes and overlays but not module parameter or index variable names.

An important thing to note is that the limits of an interval can reference module parameters of type \Sockeye{nat}.
This allows module parameters to control how many ports or nodes are instantiated from a certain interval template.

\paragraph{Syntax}
\begin{align*}
    \textit{var} & \mathop{=}
        \textit{iden}\\
    \textit{limit} & \mathop{=}
        \textit{decimal}\ |\ \textit{iden} \\
    \textit{interval} & \mathop{=}
        \textbf{[}\textit{limit}\textbf{..}\textit{limit}\textbf{]}\\
    \textit{interval\_templ}_s & \mathop{=}
        \textit{iden}\textbf{\{}\textit{var}\ \textbf{in}\ \textit{interval}\textbf{\}}
        \Big[
            \textit{iden}\ |\ \textit{templ\_iden}_s\ |\ \textit{for\_iden}_s
        \Big]\\
    \textit{simple\_templ}_s & \mathop{=}
        \textit{iden}\textbf{\{}\textit{var}\textbf{\}}\Big[\textit{iden}\ |\ \textit{templ\_iden}_s\Big]\\
\end{align*}

\paragraph{Example}
\begin{example}
    /* Declare similar nodes
     * Note that interval templates in node declarations
     * always require the usage of '\textbf{are}'
     */
    GPTIMER_\verb+{+[1..5]\verb+}+ \textbf{are} device \textbf{accept} [0x0/12]

    /* Use the index in the node definition */
    GPTIMER_ALIAS_\verb+{+i in [1..5]\verb+}+ \textbf{is} \textbf{map} [0x100/12 to GPTIMER_\verb+{+i\verb+}+]

    /* Declare similar module ports
     * (possibly depending on module parameters)
     */
    \textbf{module} module CortexA9-MPCore(nat cores, addr periphbase) \verb+{+
        input CPU_\verb+{+[1..cores]\verb+}+
        \ldots
    \verb+}+

    /* Instantiate module multiple times
     * and use index variable in port mappings
     */
    CortexA9-Core \textbf{as} Core_\verb+{+c in [1..2]\verb+}+ \textbf{with}
        CPU_\verb+{+c\verb+}+ > CPU
\end{example}

\section{Imports}
\label{sec:imports}
Imports allow a specification to be split across several files.
They also allow the reuse of modules.
Imports have to be specified at the very top of a Sockeye file.
An import will cause the compiler to load all modules from \pathname{<import\_path>.soc}
Nodes declared outside of modules will not be loaded.
The compiler will first look for files in the current directory and then check the directories passed with the \texttt{-i} option in the order they were given.

\paragraph{Syntax}
\begin{align*}
\textit{import}_s & \mathop{=}
    \textbf{import}\ \big\{\ \textit{letter}\ |\ \textbf{/}\ \big\}
\end{align*}

\paragraph{Example}
\begin{example}
    /* Invoked with 'sockeye -i imports -i modules' the following
     * will cause the compiler to look for the files
     * 1. ./cortex/cortexA9.soc
     * 2. imports/cortex/cortexA9.soc
     * 3. modules/cortex/cortexA9.soc
     * and import all modules from the first one that exists.
     */
    \textbf{import} cortex/cortexA9
\end{example}

\section{Sockeye Files}
A sockeye file consists of imports, module declarations and the specification body (node declarations and module instantiations).

\paragraph{Syntax}
\begin{align*}
    \textit{sockeye}_s & \mathop{=}
        \big\{\ 
            \textit{import}_s\ 
        \big\}\ 
        \big\{\ 
            \textit{mod\_decl}_s\ 
        \big\}\ 
        \big\{\ 
            \textit{net}_s\ |\ \textit{mod\_inst}_s\ 
        \big\}
\end{align*}

\paragraph{Example}
Listing~\ref{lst:sockeye_example} shows an example Sockeye specification.

\clearpage
\lstinputlisting[caption={Example Sockeye specification}, label={lst:sockeye_example}, language=Sockeye]{example.soc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Checks on the AST}
\label{chap:checks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The compiler performs the transformation from parsed Sockeye to \gls{hdn}s in three steps:
\begin{enumerate}
    \item Type checker
    \item Instantiator
    \item Net builder
\end{enumerate}
In each of the steps some checks are performed.
The type checker checks that all referenced symbols (modules, parameters and index variables) are defined and ensures module template parameter type safety.
The instantiator instantiates module and identifier templates and ensures that each identifier is declared only once.
The net builder instantiates the modules and ensures referential integrity in the generated \gls{hdn}. It also transforms overlays to translation sets.
The checks are detailed in the following sections.

\section{Type Checker}
\subsection{Duplicate Modules}
This check makes sure that all module names in any of the imported files are unique.

\subsection{Duplicate Parameters}
This check makes sure that no module has two parameters with the same name.

\subsection{Duplicate Index Variables}
This check makes sure that no two index variables in the same scope have the same name.

\subsection{Undefined Modules}
This check makes sure that all modules being instantiated actually exist.

\subsection{Undefined Parameters}
This check makes sure that all referenced parameters are in scope.

\subsection{Undefined Index Variables}
This check makes sure that all index variables referenced in templated identifiers are in scope. 

\subsection{Parameter Type Mismatch}
This check makes sure that parameters are used in a type safe way.

\subsection{Argument Count Mismatch}
This check makes sure that module instantiations give the correct number of arguments to the module template being instantiated.

\subsection{Argument Type Mismatch}
This check makes sure that the arguments passed to module templates have the correct type.

\section{Instantiator}
\subsection{Module Instantiation Loops}
This check makes sure that there are no loops in module instantiations which would result in an infinite nesting of decoding subnets.

\subsection{Duplicate Namespaces}
This check makes sure that all module instantiations in a module have a unique namespace.

\subsection{Duplicate Identifiers}
This check makes sure that all node identifiers are unique.
This includes output ports, declared nodes and nodes mapped to input ports of instantiated modules.

\subsection{Duplicate Ports}
This check makes sure, that there are no duplicate input or output ports.
Note that declaring an output port with the same identifier as an input port is allowed and results in all address resolutions going through the input port being passed through the module to the output port.

\subsection{Duplicate Port Mapping}
This check makes sure that no port is mapped twice in the same module instantiation.

\section{Net Builder}

\subsection{Mapping to Undefined Port}
This check makes sure that there are no port mappings to ports not declared by the instantiated module.

\subsection{References to Undefined Nodes}
This check makes sure that all nodes referenced in translation sets, overlays and port mappings exist.
It also checks that every input port has a corresponding node declaration.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Prolog Mapping for Sockeye}
\label{chap:prolog}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\todo{DS: This describes the mapping in the initial draft for Sockeye.
The new version of the compiler does not yet implement the Prolog backend.
If PicoSAT will indeed be used in the future to query \glspl{hdn}, this will impose currently unknown requirements on the Prolog representation.
We probably also want modules represented in the \gls{skb} such that they can be instantiated at runtime, meaning Sockeye should be compiled to a colleciton of inference rules rather than facts.}

The Sockeye compiler generates \(\text{ECL}^i\text{PS}^e\)-Prolog\footnote{\href{http://eclipseclp.org/}{http://eclipseclp.org/}} to be used within the \gls{skb}.
A \gls{hdn} is expressed by the predicate \Prolog{node/2}.
The first argument to the predicate is the node identifier and the second one the node specification.

Node identifiers are represented as a functor \Prolog{node_id/2}.
The first argument is the node's name, represented as an atom, and the second one is the (possibly nested) namespace it is in.
The namespace is represented as a list of atoms where the head is the innermost namespace component.

Node specifications are represented by a Prolog functor \Prolog{node_spec/3}.
The arguments to the functor are the node type, the list of accepted addresses and the list of translated addresses.
The overlay is translated to address mappings and added to the list of translated addresses during compilation.

The node type is one of four atoms: \Prolog{core}, \Prolog{device}, \Prolog{memory} or \Prolog{other}.
The accepted addresses are a list of address blocks where each block is represented through the functor \Prolog{block/2} with the start and end addresses as arguments.
The translated addresses are a list of mappings to other nodes, represented by the functor \Prolog{map/3} where the first argument is the translated address block, the second one is the target node's identifier and the third one is the base address for the mapping in the target node.

There is a predicate clause for \Prolog{node/2} for every node specified.

The code is generated using \(\text{ECL}^i\text{PS}^e\)'s structure notation.
This enables more readable and concise notation when accessing specific arguments of the functors.

Listing~\ref{lst:prolog_example} shows the generated Prolog code for the Sockeye example in Listing~\ref{lst:sockeye_example}.

\clearpage
\lstinputlisting[caption={Generated Prolog code},label={lst:prolog_example},language=Prolog]{example.pl}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Compiler Implementation}
\label{chap:compiler}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\todo{DS: Needed?}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Compiling Sockeye Files with Hake}
\label{chap:hake}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SoC descriptions are placed in the directory \pathname{SOURCE/socs} with the file extension \pathname{soc}.
Each top-level Sockeye file has to be added to the list of SoCs in the Hakefile in the same directory.
When passed a filename (without extension), the function \verb|sockeye :: String -> HRule| creates a rule to compile the file \pathname{SOURCE/socs/<filename>.soc} to \pathname{BUILD/sockeyefacts/<filename>.pl}.
The rule will also generate \pathname{BUILD/sockeyefacts/<filename>.pl.depend} (with the \texttt{-d} option of the Sockeye compiler) and include it in the Makefile.
This causes \texttt{make} to rebuild the file also when imported files are changed.
To add a compiled Sockeye specification to the \gls{skb} RAM disk, the filename can be added to the \varname{sockeyeFiles} list in the \gls{skb}'s Hakefile.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv}
\bibliography{defs,barrelfish}

\end{document}