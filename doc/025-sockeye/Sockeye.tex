%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Copyright (c) 2017, ETH Zurich.
% All rights reserved.
%
% This file is distributed under the terms in the attached LICENSE file.
% If you do not find this file, copies can be found by writing to:
% ETH Zurich D-INFK, Universitaetstr 6, CH-8092 Zurich. Attn: Systems Group.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\providecommand{\pgfsyspdfmark}[3]{}

\documentclass[a4paper,11pt,twoside]{report}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{bftn}
\usepackage{calc}
\usepackage{verbatim}
\usepackage{xspace}
\usepackage{pifont}
\usepackage{pxfonts}
\usepackage{textcomp}

\usepackage{multirow}
\usepackage{listings}
\usepackage{todonotes}
\usepackage{hyperref}

\title{Sockeye in Barrelfish}
\author{Barrelfish project}
% \date{\today}   % Uncomment (if needed) - date is automatic
\tnnumber{025}
\tnkey{Sockeye}


\lstdefinelanguage{Sockeye}{
    morekeywords={accept, are, as, at, import, in, input, is, map, module, output, over, reserved, to, with},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
}

\presetkeys{todonotes}{inline}{}

\begin{document}
\maketitle      % Uncomment for final draft

\begin{versionhistory}
\vhEntry{0.1}{15.06.2017}{DS}{Initial Version}
\vhEntry{0.2}{26.07.2017}{DS}{Describe Modularity Features}
\end{versionhistory}

% \intro{Abstract}    % Insert abstract here
% \intro{Acknowledgements}  % Uncomment (if needed) for acknowledgements
\tableofcontents    % Uncomment (if needed) for final draft
% \listoffigures    % Uncomment (if needed) for final draft
% \listoftables     % Uncomment (if needed) for final draft
\cleardoublepage
\setcounter{secnumdepth}{2}

\newcommand{\fnname}[1]{\textit{\texttt{#1}}}%
\newcommand{\datatype}[1]{\textit{\texttt{#1}}}%
\newcommand{\varname}[1]{\texttt{#1}}%
\newcommand{\keywname}[1]{\textbf{\texttt{#1}}}%
\newcommand{\pathname}[1]{\texttt{#1}}%
\newcommand{\tabindent}{\hspace*{3ex}}%
\newcommand{\Sockeye}{\lstinline[language=Sockeye]}
\newcommand{\Prolog}{\lstinline[language=Prolog]}
\newcommand{\ccode}{\lstinline[language=C]}

\lstset{
  basicstyle=\ttfamily \small,
  keywordstyle=\bfseries,
  flexiblecolumns=false,
  basewidth={0.5em,0.45em},
  boxpos=t,
  captionpos=b,
  frame=single,
  breaklines=true,
  postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Introduction and Usage}
\label{chap:introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\emph{Sockeye}\footnote{Sockeye salmon (Oncorhynchus nerka), also called red salmon, kokanee salmon, or blueback salmon, is an anadromous species of salmon found in the Northern Pacific Ocean and rivers discharging into it. This species is a Pacific salmon that is primarily red in hue during spawning. They can grow up to 84 cm in length and weigh 2.3 to 7 kg. 
Source: \href{https://en.wikipedia.org/wiki/Sockeye_salmon}{Wikipedia}}
is a domain specific language to describe SoCs (Systems on a Chip).

Achermann~et~al.~\cite{achermann:mars17} propose a formal model to describe address spaces and interrupt routes in a system as a directed graph.
They call such a graph a ``decoding net''.
Each node in the graph can accept a set of addresses and translate another (not necessarily disjunct) set of addresses (when describing interrupt routes the accept or translate interrupt vectors).
Starting at a specific node, addresses can be resolved by following the appropriate edges in the decoding net.
When a node translates an address, resolution is continued on that node.
When a node accepts an address, resolution terminates

Achermann~et~al.~\cite{achermann:mars17} also propose a concrete syntax for specifying decoding nets.
Sockeye is an implementation of the proposed language but adds some features to address issues encountered in practice.

The Sockeye compiler is written in Haskell using the Parsec parsing library. It
generates Prolog files from the Sockeye files. These Prolog files contain facts that represent a decoding net (see Chapter~\ref{chap:prolog}).
The Prolog files can then be loaded into Barrelfish's System Knowledgebase (SKB).

The source code for Sockeye can be found in \pathname{SOURCE/tools/sockeye}.


\section{Command Line Options}

\begin{verbatim}
$ sockeye [options] file
\end{verbatim}


The available options are:
\begin{description}
\item[-P] Generate a Prolog file that can be loaded into the SKB.
\item[-i] Add a directory to the search path where Sockeye looks for imports.
\item[-o] \varname{filename} The path to the output file
\item[-h] show usage information
\end{description}

The backend (capital letter options) specified last takes precedence.

Multiple directories can be added by giving the \texttt{-i} options multiple times.
Sockeye will first look for files in the current directory and then check the given directories in the order they were given.

The Sockeye file to compile is given via the \texttt{file} parameter.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Lexical Conventions}
\label{chap:lexer}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The Sockeye parser follows a similar convention as opted by modern day 
programming languages like C and Java. Hence, Sockeye uses a Java-style-like
parser based on the Haskell Parsec Library. The following conventions are used:

\begin{description}
\item[Encoding] The file should be encoded using plain text.
\item[Whitespace:]  As in C and Java, Sockeye considers sequences of
  space, newline, tab, and carriage return characters to be
  whitespace.  Whitespace is generally not significant. 

\item[Comments:] Sockeye supports C-style comments.  Single line comments
  start with \texttt{//} and continue until the end of the line.
  Multiline comments are enclosed between \texttt{/*} and \texttt{*/};
  anything in between is ignored and treated as white space.
  Nested comments are not supported.

\item[Identifiers:] Valid Sockeye identifiers are sequences of numbers
  (0-9), letters (a-z, A-Z), the underscore character ``\texttt{\_}'' and the dash character ``\textendash''. They
  must start with a letter.
  \begin{align*}
  identifier & \rightarrow letter (letter \mid digit \mid \text{\_} \mid \text{\textendash})^{\textrm{*}} \\
  letter & \rightarrow (\textsf{A \ldots Z} \mid  \textsf{a \ldots z})\\
  digit & \rightarrow (\textsf{0 \ldots 9})
    \end{align*}

\item[Case sensitivity:] Sockeye is case sensitive hence identifiers \Sockeye{node1} and \Sockeye{Node2} are not the same.
  
\item[Integer Literals:] A Sockeye integer literal is a sequence of
  digits, optionally preceded by a radix specifier.  As in C, decimal (base 10)
  literals have no specifier and hexadecimal literals start with
  \texttt{0x}.

\begin{align*}
decimal & \rightarrow (\textsf{0 \ldots 9})^{\textrm{1}}\\
hexadecimal & \rightarrow (\textsf{0x})(\textsf{0 \ldots 9} \mid \textsf{A \ldots F} \mid \textsf{a \ldots f})^{\textrm{1}}\\
\end{align*}

\item[Reserved words:] The following are reserved words in Sockeye:
\begin{verbatim}
accept, are, as, at, import, in, input, is, map,
module, output, over, reserved, to, with
\end{verbatim}

\end{description}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Syntax}
\label{chap:declaration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter we define the layout of a Sockeye file.
The node declarations in a Sockeye file describe a single decoding net.
Parts of a decoding net can be packaged into reusable modules (see Section~\ref{sec:modules}).
With imports (see Section~\ref{sec:imports}) modules can also be put into separate files.
Also, a SoC can be split into multiple decoding nets e.g. one for the address spaces and another one for the interrupt routes.

In the following sections we use EBNF to specify the Sockeye syntax. Terminals are \textbf{bold} while non-terminals are \textit{italic}.
The non-terminals \textit{iden}, \textit{letter}, \textit{decimal} and \textit{hexadecimal} correspond to the ones defined in Chapter~\ref{chap:lexer}.

\section{Basic Syntax}
This section describes the basic syntax for Sockeye.
It closely corresponds to the concrete syntax described in \cite{achermann:mars17}.
If there are important syntactic or semantic differences it is stated so in the description of the respective syntactical construct.

\subsection{Node Declarations}
A node declaration contains one or more identifiers and the node specification.
The order in which the nodes are declared does not matter.

\paragraph{Syntax}
\begin{align*}
\textit{net}_s & \mathop{=}
    \Big\{
        \textit{iden}\ \textbf{is}\ \textit{node}_s\
    \Big|\
        \textit{iden}\bigl\{\textbf{,}\ \textit{iden}\bigr\}\ \textbf{are}\ \textit{node}_s
    \Big\} \\
\end{align*}

\clearpage
\paragraph{Example}
\begin{syntax}
    node1 \textbf{is} \ldots

    node2,
    node3 \textbf{are} \ldots
\end{syntax}

\subsection{Node Specifications}
A node specification consists of a type, a set of accepted address blocks, a set of address mappings to other nodes, a set of reserved address blocks and an overlay.
All of these are optional.
The reserved address blocks are only relevant in conjunction with overlays and are used to exclude some addresses from the overlay.
The overlay is specified as a node identifier and a number of address bits.
The overlay will span addresses from \texttt{0x0} to \(\texttt{0x2}^\texttt{bits} - \texttt{1}\).

\paragraph{Syntax}
\begin{align*}
\textit{node}_s & \mathop{=}
    \Big[\ 
       \textit{type}\ 
    \Big]\  
    \Big[
       \textit{accept}\ 
    \Big]\ 
    \Big[\ 
       \textit{map}\ 
    \Big]\ 
    \Big[\ 
        \textit{reserved}\ 
    \Big]\ 
    \Big[\ 
        \textit{overlay}\ 
    \Big]\\
\textit{accept} & \mathop{=}
    \textbf{accept [}\ \big\{\ \textit{block}_s\ \big\}\ \textbf{]}\\
\textit{map} & \mathop{=}
    \textbf{map [}\ \big\{\ \textit{map}_s\ \big\}\ \textbf{]}\\
\textit{reserved} & \mathop{=}
    \textbf{reserved [}\ \big\{\ \textit{block}_s\ \big\}\ \textbf{]}\\
\textit{overlay} & \mathop{=}
    \textbf{over}\ \textit{iden}\textbf{/}\textit{decimal}\\
\end{align*}

\paragraph{Example}
\begin{syntax}
    node1 \textbf{is} \textit{<type>} \textbf{accept} [\ldots]
    node2 \textbf{is} \textbf{map} [\ldots]
    node3 \textbf{is} \textbf{reserved} [\ldots] \textbf{over} node2/32
\end{syntax}

\subsection{Node Type}
Currently there are two types: \Sockeye{device} and \Sockeye{memory}. A third internal type \Sockeye{other} is given to nodes for which no type is specified.
The \Sockeye{device}-type specifies that the accepted addresses are device registers while the \Sockeye{memory}-type is for memory nodes like RAM or ROM.

\paragraph{Syntax}
\begin{align*}
\textit{type} & \mathop{=}
    \textbf{device}\
    |\
    \textbf{memory} \\
\end{align*}

\paragraph{Example}
\begin{syntax}
    node1 \textbf{is} memory \textbf{accept} [\ldots]
    node2 \textbf{is} device \textbf{accept} [\ldots]
\end{syntax}

\subsection{Addresses}
Addresses are specified as hexadecimal literals.

\paragraph{Syntax}
\begin{align*}
\textit{addr} & \mathop{=} \textit{hexadecimal} \\
\end{align*}

\subsection{Block Specifications}
A block is specified by its start and end address.
If the start and end address are the same, the end address can be omitted.
Sockeye also supports specifying a block as its base address and the number of address bits the block spans:
A block from \Sockeye{0x0} to \Sockeye{0xFFF} with a size of 4kB can be specified as \Sockeye{0x0/12}.

\paragraph{Syntax}
\begin{align*}
\textit{block}_s & \mathop{=} \textit{addr}\
    \Big[
        \textbf{-}\ \textit{addr}\ 
    \Big|\
        \textbf{/}\textit{decimal}
    \Big] \\
\end{align*}

\paragraph{Example}
\begin{syntax}
    node1 is \textbf{accept} [0x42-0x51]
    node2 is \textbf{accept} [0x42]      // \textit{same as \textup{0x42-0x42}}
    node3 is \textbf{accept} [0x0/12]    // \textit{same as \textup{0x0-0xFFF}}
\end{syntax}

\subsection{Map Specification}
A map specification is a source address block, a target node identifier and optionally a target base address to which the source block is translated within the target node.
If no target base address is given, the block is translated to the target node starting at \Sockeye{0x0}.
Note that this is different from the concrete syntax described in \cite{achermann:mars17} where in this case the base address of the source block is used.
This was changed due to the mapping to \Sockeye{0x0} being used more often in practice.
Multiple translation targets can be specified by giving a comma-separated list of targets.

\paragraph{Syntax}
\begin{align*}
\textit{map}_s & \mathop{=}
\textit{block}_s\ \textbf{to}\ \textit{iden}\ 
    \Big[
        \textbf{at}\ \textit{addr}
    \Big]\
    \Big\{
        \textbf{,}\ \textit{iden}\ 
        \Big[
            \textbf{at}\ \textit{addr}
        \Big]
    \Big\}\\
\end{align*}

\paragraph{Example}
\begin{syntax}
    /* \textit{Translate \textup{0x0-0xFF} to \textup{node2} at \textup{0x300-0x3FF}:} */
    node1 is \textbf{map} [0x0/8 \textbf{to} node2 \textbf{at} 0x300] 

    /* \textit{This is the same as \textup{0x300/8 \textbf{to} node1 \textbf{at} 0x0}:} */
    node2 is \textbf{map} [0x300/8 \textbf{to} node1]

    /* \textit{Multiple translation targets, \textup{0x0-0xFF} is translated to
       - \textup{node1} at \textup{0x0-0xFF}
       - \textup{node2} at \textup{0x300-0x3FF}:} */
    node3 is \textbf{map} [0x0/8 \textbf{to} node1, node2 \textbf{at} 0x300]
\end{syntax}

\section{Modules}
\label{sec:modules}
A module encapsulates a decoding net which can be integrated into a larger decoding net.
A module instantiation always creates a namespace inside the current one.
Normally nodes can only be referenced by nodes in the same namespace but there needs to be away to reference nodes inside a module and also a way for nodes inside the module to reference nodes outside of it.
This is done via ports.
There are input ports, which create a connection into the module and output ports which create connections from the module to outside nodes.
A port has always a width, specified as the number of address bits the port spans.
All declared input ports must have a corresponding node declaration in the module body.

When a module is instantiated a list of port mappings can be specified.
An input port mapping creates a node outside the module that overlays the node inside the module.
An output port mapping creates a node inside the module that overlays the node outside the module.
Not all ports a module defines have to be mapped.
Not mapping an input port simply means there is no connection to the corresponding node inside the module.
For unmapped output ports there will be an empty node inside the module, which is a dead end for address resolution.

Additionally a module can also be parametrized.
It will then be a module template that only becomes a fully defined module when instantiated with concrete arguments.
Module parameters are typed and the Sockeye compiler checks that they are used in a type safe way.
There are two types of parameters, address parameters and natural parameters.
Address parameters allow to parametrize addresses in node specifications.
Natural parameters are used in combination with interval template identifiers (see Section~\ref{sec:template_idens}).
Parameters can also be passed as arguments to module template instantiations in the module body.

\subsection{Module Declarations}
A module declaration starts with the keyword \Sockeye{module} and a unique module name.
If the module is a template, a list of typed parameters can be specified.
The module body is enclosed in curly braces and starts with the port definitions.
The rest of the body are node declarations and module instantiations.
If the module has address parameters the name of the parameter can be used wherever in the body an address is expected.

\paragraph{Syntax}
\begin{align*}
    \textit{param\_type} & \mathop{=}
        \textbf{addr}\ |\ \textbf{nat}\\
    \textit{parameter} & \mathop{=}
        \textit{param\_type}\ \textit{iden}\\
    \textit{param\_list} & \mathop{=}
        \textbf{(}\big[\ 
            \textit{parameter}\big\{\textbf{,}\ \textit{parameter}\big\}\ 
        \big] \textbf{)}\\
    \textit{input\_port} & \mathop{=}
        \textbf{input}\ \textit{iden}\textbf{/}\textit{decimal}
        \big\{
            \textbf{,}\ \textit{iden}\textbf{/}\textit{decimal}
        \big\}\\
    \textit{output\_port} & \mathop{=}
        \textbf{output}\ \textit{iden}\textbf{/}\textit{decimal}
        \big\{
            \textbf{,}\ \textit{iden}\textbf{/}\textit{decimal}
        \big\}\\
    \textit{body}_s & \mathop{=}
        \big\{\ 
            \textit{net}_s\ |\ \textit{mod\_inst}_s\ 
        \big\}\\
    \textit{mod\_decl}_s & \mathop{=}
        \textbf{module}\ \textit{iden} \big[\textit{param\_list}\big]\ 
        \textbf{\{}\ 
            \big\{\textit{input\_port}\ |\ \textit{output\_port}\big\}\ 
            \textit{body}_s\ 
        \textbf{\}}\\
\end{align*}

\subsection{Module Instantiations}
Module instantiations start with the module name and in the case of a module template with the list of arguments.
After that the identifier of the namespace in which to instantiate the module has to be given followed by an optional list of port mappings.

\paragraph{Syntax}
\begin{align*}
    \textit{argument} & \mathop{=}
        \textit{decimal}\ |\ \textit{hexadecimal}\ |\ \textit{iden}\\
    \textit{arg\_list} & \mathop{=}
        \textbf{(}\big[\ 
            \textit{argument}\big\{\textbf{,}\ \textit{argument}\big\}\ 
        \big] \textbf{)}\\
    \textit{mod\_inst}_s & \mathop{=}
        \textit{iden} \big[\textit{arg\_list}\big]\ \textbf{as}\ \textit{iden}\ \big[\ 
            \textbf{with}\ \big\{\textit{input\_map}\ |\ \textit{output\_map}\big\}\ 
        \big]\\
    \textit{input\_map} & \mathop{=}
        \textit{iden}\ \textbf{>}\ \textit{iden}\\
    \textit{output\_map} & \mathop{=}
        \textit{iden}\ \textbf{<}\ \textit{iden}\\
\end{align*}

\clearpage
\paragraph{Example}
\begin{syntax}
    /* Instantiate module 'SomeModule' in namespace 'subspace' /*
    SomeModule \textbf{as} subspace

    /* Pass arguments to module template */
    TemplModule(0x0, 42) \textbf{as} templSubspace

    /* Declare port mappings:
       - map 'Node1' to ouptut port 'Out'
       - map input port 'In' to 'Node2' */
    SomeModule \textbf{as} subspace \textbf{with}
        Node1 > Out
        Node2 < In
\end{syntax}

\section{Templated Identifiers}
\label{sec:template_idens}
Templated identifiers allow to declare multiple nodes and ports at once and instantiate a module multiple times at once.
There are two forms of templated identifiers:
\begin{description}
    \item[Interval template]
        The template contains one or several intervals.
        The identifier will be instantiated for all possible combinations of values in the intervals.
        Index variables can optionally be named so they can be referenced later.
    \item[Simple template]
        Simple templates work very similar to interval templates.
        The only difference is, that a simple template can only reference index variables declared in the same context.
        It can not contain intervals to declare new index variables.
\end{description}

Interval templates can be used in identifiers of node declarations (to declare multiple nodes), port declarations (to declare multiple ports) and namespace identifiers of module instantiations (to instantiate a module multiple times).
The scope of index variables is the corresponding syntactic construct the interval template was used in.
Simple templates can be used in any place a node identifier is expected.
This includes the places where interval templates can be used, translation destination node identifiers and overlays but not module parameter or index variable names.

An important thing to note is that the limits of an interval can reference module parameters of type \Sockeye{nat}.
This allows module parameters to control how many ports or nodes are instantiated from a certain interval template.

\paragraph{Syntax}
\begin{align*}
    \textit{var} & \mathop{=}
        \textit{iden}\\
    \textit{limit} & \mathop{=}
        \textit{decimal}\ |\ \textit{iden} \\
    \textit{interval} & \mathop{=}
        \textbf{[}\textit{limit}\textbf{..}\textit{limit}\textbf{]}\\
    \textit{interval\_templ}_s & \mathop{=}
        \textit{iden}\textbf{\{}\textit{var}\ \textbf{in}\ \textit{interval}\textbf{\}}
        \Big[
            \textit{iden}\ |\ \textit{templ\_iden}_s\ |\ \textit{for\_iden}_s
        \Big]\\
    \textit{simple\_templ}_s & \mathop{=}
        \textit{iden}\textbf{\{}\textit{var}\textbf{\}}\Big[\textit{iden}\ |\ \textit{templ\_iden}_s\Big]\\
\end{align*}

\paragraph{Example}
\begin{syntax}
    /* Declare similar nodes
       (Note that interval templates in node declarations
       always require the usage of '\textbf{are}') */
    Device_\verb+{+[1..5]\verb+}+ \textbf{are} device \textbf{accept} [0x0/8]

    /* Use the index in the node definition */
    Map_\verb+{+m in [1..5]\verb+}+ \textbf{is} \textbf{map} [0x100/8 to Device_\verb+{+m\verb+}+]

    /* Declare similar module ports
       (possibly depending on module parameters) */
    \textbf{module} SomeModule(nat num) \verb+{+
        output Out_\verb+{+[1..num]\verb+}+
        \ldots
    \verb+}+

    /* Instantiate module multiple times
       and use index variable in port mappings */
    SomeModule(3) \textbf{as} sub_module_\verb+{+m in [1..2]\verb+}+ \textbf{with}
        Node_\verb+{+m\verb+}+_\verb+{+o in [1..3]\verb+}+ > Out_\verb+{+o\verb+}+
\end{syntax}

\section{Imports}
\label{sec:imports}
Imports allow a specification to be divided over several files.
They also allow the reuse of declared modules.
Imports have to be specified at the very top of a Sockeye file.
An import will cause the compiler to load all modules from \pathname{<import\_path>.soc}
Nodes declared outside of modules will not be loaded.
The compiler will first look for files in the current directory and then check the directories passed with the \texttt{-i} option in the order they were given.

\paragraph{Syntax}
\begin{align*}
\textit{import}_s & \mathop{=}
    \textbf{import}\ \big\{\ \textit{letter}\ |\ \textbf{/}\ \big\}
\end{align*}

\paragraph{Example}
\begin{syntax}
    /* Invoked with 'sockeye -i imports -i modules' the following
       will cause the compiler to look for the files
       - ./subdir/core.soc
       - imports/subdir/core.soc
       - modules/subdir/core.soc
       and import all modules from the first one that exists. */
    \textbf{import} subdir/core
\end{syntax}

\section{Sockeye Files}
A sockeye file consists of imports, module declarations and the specification body (node declarations and module instantiations).

\paragraph{Syntax}
\begin{align*}
    \textit{sockeye}_s & \mathop{=}
        \big\{\ 
            \textit{import}_s\ 
        \big\}\ 
        \big\{\ 
            \textit{mod\_decl}_s\ 
        \big\}\ 
        \big\{\ 
            \textit{net}_s\ |\ \textit{mod\_inst}_s\ 
        \big\}
\end{align*}

\paragraph{Example}
Listing~\ref{lst:sockeye_example} shows an example Sockeye specification.
The specification for the Texas Instruments OMAP4460 SoC used on the PandaboardES can serve as a real world example. It is located in \pathname{SOURCE/socs/omap44xx.soc}.

\clearpage
\lstinputlisting[caption={Example Sockeye specification}, label={lst:sockeye_example}, language=Sockeye]{example.soc}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Checks on the AST}
\label{chap:checks}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The Sockeye compiler performs some sanity checks on the parsed AST.

\section{No Duplicate Identifiers}
This check makes sure that there aren't two node declarations with the same identifier.

\section{No References to Undefined Nodes}
This check makes sure that all nodes referenced in translation sets and overlays are declared.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Prolog Mapping for Sockeye}
\label{chap:prolog}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The Sockeye compiler generates \(\text{ECL}^i\text{PS}^e\)-Prolog\footnote{\href{http://eclipseclp.org/}{http://eclipseclp.org/}} to be used within the SKB.
A decoding net is expressed by the predicate \Prolog{net/2}. The first argument to the predicate is the node identifier represented as a functor \Prolog{nodeId} with the first argument being the node's name represented as an atom and the second the (possibly nested) namespace it is in, represented as a list of atoms.
The second argument is the node specification, a Prolog functor with the name \Prolog{node} and an arity of three.
The arguments of the functor are the node type, the list of accepted addresses and the list of translated addresses.
The overlay is translated to address mappings and added to the list of translated addresses during compilation.

The node type is one of three atoms: \Prolog{device}, \Prolog{memory} or \Prolog{other}.
The accepted addresses are a list of address blocks where each block is represented through the functor \Prolog{block/2} with the start and end addresses as arguments.
The translated addresses are a list of mappings to other nodes, represented by the functor \Prolog{map/3} where the first argument is the translated address block, the second one is the node identifier of the target node and the third one is the base address for the mapping in the target node.

There is a predicate clause for \Prolog{net/2} for every node specified. 
Listings~\ref{lst:prolog_example} shows the generated Prolog code for the Sockeye example in Listing~\ref{lst:sockeye_example}.

\lstinputlisting[caption={Generated Prolog code},label={lst:prolog_example},language=Prolog]{example.pl}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Compiling Sockeye Files with Hake}
\label{chap:hake}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
SoC descriptions are placed in the directory \pathname{SOURCE/socs} with the file extension \pathname{soc}.
Each top-level Sockeye file has to be added to the list of SoCs in the Hakefile in the same directory.
When passed a filename (without extension), the function \verb|sockeye :: String -> HRule| creates a rule to compile the file \pathname{SOURCE/socs/<filename>.soc} to \pathname{BUILD/sockeyefacts/<filename>.pl}.
The rule will also generate \pathname{BUILD/sockeyefacts/<filename>.pl.depend} (with the \texttt{-d} option of the Sockeye compiler) and include it in the Makefile.
This causes \texttt{make} to rebuild the file also when imported files are changed.
To add a compiled Sockeye specification to the SKB RAM-disk, the filename can be added to the \varname{sockeyeFiles} list in the SKBs Hakefile.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\bibliographystyle{abbrv}
\bibliography{defs,barrelfish}

\end{document}