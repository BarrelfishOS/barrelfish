
------ Test 1 -------
p :-
	p(A).

p / 0:
label(1):
	put_variable             a(1) 
	jmp                      p / 1 

------ Test 2 -------
p :-
	p(A),
	q(A),
	r(A).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
	move_callf               y(1)     a(1)     q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 3 -------
p :-
	(
	    q(A)
	;
	    r(A)
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	put_variable             a(1) 
	jmp                      q / 1 
label(3):
	trust_me                 0 
label(4):
	put_variable             a(1) 
	jmp                      r / 1 

------ Test 4 -------
p :-
	p(A),
	(
	    q(A)
	;
	    r(A)
	).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move_chain               y(1)     a(1)     q / 1 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	move_chain               y(1)     a(1)     r / 1 

------ Test 5 -------
p :-
	(
	    q(A)
	;
	    r(A)
	),
	p(A).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     q / 1     Y[1] 
	move_chain               y(1)     a(1)     p / 1 
label(3):
	trust_me                 0 
label(4):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     r / 1     Y[1] 
	move_chain               y(1)     a(1)     p / 1 

------ Test 6 -------
p :-
	(
	    q(A),
	    r(A)
	;
	    s(A),
	    t(A)
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 
label(3):
	trust_me                 0 
label(4):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     s / 1     Y[1] 
	move_chain               y(1)     a(1)     t / 1 

------ Test 7 -------
p :-
	f(A),
	(
	    q(A),
	    r(A)
	;
	    s(A),
	    t(A)
	).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     f / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move_callf               y(1)     a(1)     q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	move_callf               y(1)     a(1)     s / 1     Y[1] 
	move_chain               y(1)     a(1)     t / 1 

------ Test 8 -------
p :-
	(
	    q(A),
	    r(A)
	;
	    s(A),
	    t(A)
	),
	f(A).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     q / 1     Y[1] 
	move_callf               y(1)     a(1)     r / 1     Y[1] 
	move_chain               y(1)     a(1)     f / 1 
label(3):
	trust_me                 0 
label(4):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     s / 1     Y[1] 
	move_callf               y(1)     a(1)     t / 1     Y[1] 
	move_chain               y(1)     a(1)     f / 1 

------ Test 9 -------
p :-
	(
	    a(A)
	;
	    (
		b(A)
	    ;
		c(A)
	    ),
	    (
		d(A)
	    ;
		e(A)
	    )
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	put_variable             a(1) 
	jmp                      a / 1 
label(3):
	trust_me                 0 
label(4):
	try_me_else              0     0     ref(6) 
label(5):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     b / 1     Y[1] 
label(8):
	try_me_else              0     0     ref(10) 
label(9):
	move_chain               y(1)     a(1)     d / 1 
label(6):
	trust_me                 0 
label(7):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     c / 1     Y[1] 
	branch                   ref(8) 
label(10):
	trust_me_inline          0     Y[1] 
label(11):
	move_chain               y(1)     a(1)     e / 1 

------ Test 10 -------
p(a, A) :-
	q(A).
p(b, A) :-
	r(A).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 2:
label(1):
	atom_switch              a(1) 
		a: 	ref(7)
		b: 	ref(8)
		default: 	ref(fail)

label(2):
	try_me_else              0     2     ref(4) 
label(3):
	get_atom                 a(1)     a 
label(7):
	move                     a(2)     a(1) 
	jmp                      q / 1 
label(4):
	trust_me                 0 
label(5):
	get_atom                 a(1)     b 
label(8):
	move                     a(2)     a(1) 
	jmp                      r / 1 

------ Test 11 -------
p :-
	p(A, A).

p / 0:
label(1):
	put_variable             a(1) 
	move                     a(1)     a(2) 
	jmp                      p / 2 

------ Test 12 -------
p :-
	p(A, A),
	q(A, A),
	r(A, A).

p / 0:
label(1):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    p / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    r / 2 

------ Test 13 -------
p :-
	(
	    q(A, A)
	;
	    r(A, A)
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	put_variable             a(1) 
	move                     a(1)     a(2) 
	jmp                      q / 2 
label(3):
	trust_me                 0 
label(4):
	put_variable             a(1) 
	move                     a(1)     a(2) 
	jmp                      r / 2 

------ Test 14 -------
p :-
	p(A, A),
	(
	    q(A, A)
	;
	    r(A, A)
	).

p / 0:
label(1):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    p / 2     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    q / 2 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    r / 2 

------ Test 15 -------
p :-
	(
	    q(A, A)
	;
	    r(A, A)
	),
	p(A, A).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
label(5):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    p / 2 
label(3):
	trust_me                 0 
label(4):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    r / 2     Y[1] 
	branch                   ref(5) 

------ Test 16 -------
p :-
	(
	    q(A, A),
	    r(A, A)
	;
	    s(A, A),
	    t(A, A)
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    r / 2 
label(3):
	trust_me                 0 
label(4):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    s / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    t / 2 

------ Test 17 -------
p :-
	f(A, A),
	(
	    q(A, A),
	    r(A, A)
	;
	    s(A, A),
	    t(A, A)
	).

p / 0:
label(1):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    f / 2     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    r / 2 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    s / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    t / 2 

------ Test 18 -------
p :-
	(
	    q(A, A),
	    r(A, A)
	;
	    s(A, A),
	    t(A, A)
	),
	f(A, A).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    r / 2     Y[1] 
label(5):
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	chain                    f / 2 
label(3):
	trust_me                 0 
label(4):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    s / 2     Y[1] 
	move                     y(1)     a(1) 
	move                     a(1)     a(2) 
	callf                    t / 2     Y[1] 
	branch                   ref(5) 

------ Test 19 -------
p :-
	a(A),
	(
	    a(A, B)
	;
	    a(A, B, B)
	).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     a / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	put_variable             a(2) 
	move_chain               y(1)     a(1)     a / 2 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	put_variable             a(2) 
	move                     a(2)     a(3) 
	move_chain               y(1)     a(1)     a / 3 

------ Test 30 -------
p :-
	p,
	+(1, 2, 3).

p / 0:
label(1):
	allocate                 0 
	callf                    ref(1)     Y[] 
	put_integer              a(1)     1 
	bi_addi                  a(1)     2     a(1)     24 
	get_integer              a(1)     3 
	exit                 

------ Test 31 -------
p :-
	p(A),
	q,
	+(A, 2, 3).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	bi_addi                  a(1)     2     a(1)     24 
	get_integer              a(1)     3 
	exit                 

------ Test 32 -------
p(A, A, B) :-
	q(a, b, A).

p / 3:
label(1):
	get_value                a(2)     a(1) 
	move                     a(1)     a(3) 
	put_atom                 a(1)     a 
	put_atom                 a(2)     b 
	jmp                      q / 3 

------ Test 33 -------
p(A, A) :-
	+(B, C, 1),
	q(a, b, A).

p / 2:
label(1):
	get_value                a(2)     a(1) 
	put_variable2            a(4)     a(5) 
	bi_add                   a(4)     a(5)     a(4)     16 
	get_integer              a(4)     1 
	move                     a(1)     a(3) 
	put_atom                 a(1)     a 
	put_atom                 a(2)     b 
	jmp                      q / 3 

------ Test 34 -------
p(A, B, C) :-
	+(D, E, F),
	p(A, B, C).

p / 3:
label(1):
	put_variable2            a(4)     a(5) 
	bi_add                   a(4)     a(5)     a(4)     16 
	jmp                      ref(1) 

------ Test 35 -------
p(A) :-
	(
	    q(A)
	;
	    r(A)
	).

p / 1:
label(1):
	try_me_else              0     1     ref(3) 
label(2):
	jmp                      q / 1 
label(3):
	trust_me                 0 
label(4):
	jmp                      r / 1 

------ Test 36 -------
p :-
	A = B,
	q,
	r(B).

p / 0:
label(1):
	allocate                 1 
	put_global_variable      y(1) 
	callf                    q / 0     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 37 -------
p :-
	A = B,
	q(A),
	r(B).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 38 -------
p(A) :-
	q,
	r(A).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 39 -------
p(A) :-
	B = A,
	q(B),
	r(A).

p / 1:
label(1):
	move                     a(1)     a(2) 
	get_variable             1     a(1)     y(1) 
	move                     a(2)     a(1) 
	callf                    q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 40 -------
p :-
	q(A),
	(
	    r1(B),
	    r2(A, B)
	;
	    s(A)
	).

p / 0:
label(1):
	allocate                 2 
	put_global_variable_callf     a(1)     y(1)     q / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	put_global_variable_callf     a(1)     y(2)     r1 / 1     Y[1,2] 
	move                     2     y(1)     a(1) 
	chain                    r2 / 2 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	move_chain               y(1)     a(1)     s / 1 

------ Test 41 -------
p :-
	(
	    !
	;
	    p(A),
	    p(A),
	    !
	).

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	cut                      a(1) 
	ret                  
label(3):
	trust_me                 0 
label(4):
	get_variable             2     a(1)     y(1) 
	put_global_variable_callf     a(1)     y(2)     p / 1     Y[1,2] 
	move_callf               y(2)     a(1)     p / 1     Y[1] 
	cut                      y(1)     0 
	exit                 

------ Test 42 -------
p(A, B) :-
	!.
p(A, B) :-
	p(A),
	p(B),
	!.

p / 2:
label(1):
	move                     a(2)     a(3) 
	savecut                  a(2) 
	get_variable             2     a(3)     y(1) 
	try_me_else              0     2     ref(3) 
label(2):
	cut                      a(2)     0 
	exit                 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	move                     a(2)     y(2) 
	callf                    p / 1     Y[1,2] 
	move_callf               y(1)     a(1)     p / 1     Y[2] 
	cut                      y(2)     0 
	exit                 

------ Test 43 -------
p :-
	s(A),
	(
	    c(A)
	;
	    p(B),
	    p(B),
	    c(A)
	).

p / 0:
label(1):
	allocate                 2 
	put_global_variable_callf     a(1)     y(1)     s / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move_chain               y(1)     a(1)     c / 1 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	put_global_variable_callf     a(1)     y(2)     p / 1     Y[1,2] 
	move_callf               y(2)     a(1)     p / 1     Y[1] 
	move_chain               y(1)     a(1)     c / 1 

------ Test 44 -------
p :-
	s(A),
	(
	    c(A)
	;
	    p(B),
	    p(A),
	    c(B)
	).

p / 0:
label(1):
	allocate                 2 
	put_global_variable_callf     a(1)     y(1)     s / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move_chain               y(1)     a(1)     c / 1 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	put_global_variable_callf     a(1)     y(2)     p / 1     Y[1,2] 
	move_callf               y(1)     a(1)     p / 1     Y[2] 
	move_chain               y(2)     a(1)     c / 1 

------ Test 45 -------
p :-
	s(A),
	(
	    p(A),
	    q,
	    r
	;
	    (
		p,
		q(A),
		r
	    ;
		p,
		q,
		r(A)
	    )
	).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     s / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move_callf               y(1)     a(1)     p / 1     Y[] 
	callf                    q / 0     Y[] 
	chain                    r / 0 
label(3):
	retry_me_inline          0     ref(5)     Y[1] 
label(4):
	callf                    ref(1)     Y[1] 
	move_callf               y(1)     a(1)     q / 1     Y[] 
	chain                    r / 0 
label(5):
	trust_me_inline          0     Y[1] 
label(6):
	callf                    ref(1)     Y[1] 
	callf                    q / 0     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 46 -------
p :-
	s(A),
	(
	    p,
	    q,
	    r(A)
	;
	    (
		p,
		q(A),
		r
	    ;
		p(A),
		q,
		r
	    )
	).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     s / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    ref(1)     Y[1] 
	callf                    q / 0     Y[1] 
	move_chain               y(1)     a(1)     r / 1 
label(3):
	retry_me_inline          0     ref(5)     Y[1] 
label(4):
	callf                    ref(1)     Y[1] 
	move_callf               y(1)     a(1)     q / 1     Y[] 
	chain                    r / 0 
label(5):
	trust_me_inline          0     Y[1] 
label(6):
	move_callf               y(1)     a(1)     p / 1     Y[] 
	callf                    q / 0     Y[] 
	chain                    r / 0 

------ Test 47 -------
p :-
	s(A),
	(
	    p,
	    q(A),
	    r
	;
	    (
		p,
		q,
		r(A)
	    ;
		p,
		q,
		r(A)
	    )
	).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     s / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    ref(1)     Y[1] 
	move_callf               y(1)     a(1)     q / 1     Y[] 
	chain                    r / 0 
label(3):
	retry_me_inline          0     ref(5)     Y[1] 
label(4):
	callf                    ref(1)     Y[1] 
	callf                    q / 0     Y[1] 
	move_chain               y(1)     a(1)     r / 1 
label(5):
	trust_me_inline          0     Y[1] 
label(6):
	callf                    ref(1)     Y[1] 
	callf                    q / 0     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 50 -------
p :-
	s(A),
	(
	    p(A),
	    q(B),
	    r(B)
	;
	    p(B),
	    q(B, C),
	    r(C)
	).

p / 0:
label(1):
	allocate                 3 
	put_global_variable_callf     a(1)     y(1)     s / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move_callf               y(1)     a(1)     p / 1     Y[] 
	put_global_variable_callf     a(1)     y(2)     q / 1     Y[2] 
	move_chain               y(2)     a(1)     r / 1 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	put_global_variable_callf     a(1)     y(3)     p / 1     Y[3] 
	put_global_variable      a(2)     y(2) 
	move_callf               y(3)     a(1)     q / 2     Y[2] 
	move_chain               y(2)     a(1)     r / 1 

------ Test 51 -------
p :-
	s(A),
	(
	    p(A),
	    q(B),
	    r(B)
	;
	    (
		p1(A),
		q1(C),
		q1(C)
	    ;
		p(B),
		q(B, D),
		r(D)
	    )
	).

p / 0:
label(1):
	allocate                 3 
	put_global_variable_callf     a(1)     y(1)     s / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move_callf               y(1)     a(1)     p / 1     Y[] 
	put_global_variable_callf     a(1)     y(2)     q / 1     Y[2] 
	move_chain               y(2)     a(1)     r / 1 
label(3):
	retry_me_inline          0     ref(5)     Y[1] 
label(4):
	move_callf               y(1)     a(1)     p1 / 1     Y[] 
	put_global_variable_callf     a(1)     y(2)     q1 / 1     Y[2] 
	move_chain               y(2)     a(1)     q1 / 1 
label(5):
	trust_me_inline          0     Y[] 
label(6):
	put_global_variable_callf     a(1)     y(3)     p / 1     Y[3] 
	put_global_variable      a(2)     y(2) 
	move_callf               y(3)     a(1)     q / 2     Y[2] 
	move_chain               y(2)     a(1)     r / 1 

------ Test 52 -------
p :-
	(
	    p(A)
	;
	    q
	),
	(
	    p(A)
	;
	    q
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
label(5):
	try_me_else              0     0     ref(7) 
label(6):
	move_chain               y(1)     a(1)     p / 1 
label(3):
	trust_me                 0 
label(4):
	allocate                 1 
	callf                    q / 0     Y[] 
	gc_test                  1 
	put_global_variable      y(1) 
	branch                   ref(5) 
label(7):
	trust_me_inline          0     Y[] 
label(8):
	chain                    q / 0 

------ Test 53 -------
p :-
	(
	    p(A)
	;
	    q(A)
	),
	(
	    p(A)
	;
	    q
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
label(5):
	try_me_else              0     0     ref(7) 
label(6):
	move_chain               y(1)     a(1)     p / 1 
label(3):
	trust_me                 0 
label(4):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     q / 1     Y[1] 
	branch                   ref(5) 
label(7):
	trust_me_inline          0     Y[] 
label(8):
	chain                    q / 0 

------ Test 54 -------
p(A) :-
	A = a,
	p,
	p(A).

p / 1:
label(1):
	get_atom                 a(1)     a 
	get_variable             1     a(1)     y(1) 
	callf                    p / 0     Y[1] 
	move_chain               y(1)     a(1)     ref(1) 

------ Test 55 -------
p(A) :-
	A = B,
	p(B),
	p(A).

p / 1:
label(1):
	move                     a(1)     a(2) 
	get_variable             1     a(1)     y(1) 
	move                     a(2)     a(1) 
	callf                    ref(1)     Y[1] 
	move_chain               y(1)     a(1)     ref(1) 

------ Test 56 -------
p(A, B) :-
	A = B,
	p(B),
	p(A).

p / 2:
label(1):
	get_value                a(1)     a(2) 
	get_variable             1     a(1)     y(1) 
	move                     a(2)     a(1) 
	callf                    p / 1     Y[1] 
	move_chain               y(1)     a(1)     p / 1 

------ Test 57 -------
p(A, B) :-
	A = B,
	p,
	p(A, B).

p / 2:
label(1):
	get_value                a(1)     a(2) 
	get_variable             2     a(1)     y(1) 
	move                     a(2)     y(2) 
	callf                    p / 0     Y[1,2] 
	move                     2     y(1)     a(1) 
	chain                    ref(1) 

------ Test 58 -------
p(A) :-
	A = B,
	p,
	p(A, B).

p / 1:
label(1):
	get_variable             2     a(1)     y(2) 
	move                     a(1)     y(1) 
	callf                    p / 0     Y[1,2] 
	move                     2     y(1)     a(1) 
	chain                    p / 2 

------ Test 59 -------
p(A) :-
	A = B,
	p,
	p(A).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    p / 0     Y[1] 
	move_chain               y(1)     a(1)     ref(1) 

------ Test 60 -------
p :-
	A = B,
	p,
	p(A, B).

p / 0:
label(1):
	allocate                 2 
	put_global_variable      y(1) 
	move                     y(1)     y(2) 
	callf                    ref(1)     Y[1,2] 
	move                     2     y(1)     a(1) 
	chain                    p / 2 

------ Test 61 -------
p :-
	(
	    !,
	    A = B,
	    !,
	    p
	;
	    p
	).

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	cut                      a(1) 
	jmp                      ref(1) 
label(3):
	trust_me                 0 
label(4):
	jmp                      ref(1) 

------ Test 70 -------
p :-
	A = B,
	p(A).

p / 0:
label(1):
	put_variable             a(1) 
	jmp                      p / 1 

------ Test 71 -------
p(A) :-
	B = A,
	p(B),
	q(A).

p / 1:
label(1):
	move                     a(1)     a(2) 
	get_variable             1     a(1)     y(1) 
	move                     a(2)     a(1) 
	callf                    ref(1)     Y[1] 
	move_chain               y(1)     a(1)     q / 1 

------ Test 72 -------
p(A) :-
	r,
	B = A,
	p(B),
	q(A).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    r / 0     Y[1] 
	move_callf               y(1)     a(1)     ref(1)     Y[1] 
	move_chain               y(1)     a(1)     q / 1 

------ Test 73 -------
p(A) :-
	r,
	var(A),
	B = A,
	p(B),
	q(A).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    r / 0     Y[1] 
	move                     y(1)     a(2) 
	bi_var                   a(2) 
	move_callf               y(1)     a(1)     ref(1)     Y[1] 
	move_chain               y(1)     a(1)     q / 1 

------ Test 74 -------
p :-
	A = B,
	p(A),
	q(B).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
	move_chain               y(1)     a(1)     q / 1 

------ Test 75 -------
p :-
	p(A),
	var(A),
	B = A.

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	exit                 

------ Test 76 -------
p :-
	p(A, B),
	var(A),
	var(B),
	A = B.

p / 0:
label(1):
	allocate                 2 
	put_global_variable2     a(1)     y(1)     a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	move                     y(2)     a(2) 
	bi_var                   a(2) 
	get_value                a(1)     a(2) 
	exit                 

------ Test 77 -------
p :-
	p(A, B),
	var(A),
	A = B.

p / 0:
label(1):
	allocate                 2 
	put_global_variable2     a(1)     y(1)     a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	get_value                a(1)     y(2) 
	exit                 

------ Test 80 -------
p(A, B, C, D, E) :-
	t,
	F = G,
	H = I,
	J = I,
	K = L,
	M = L,
	N = A,
	O = P,
	Q = R,
	S = R,
	T = U,
	V = L,
	W = B,
	O = X,
	Q = Y,
	S = Y,
	T = Z,
	V = L,
	W = C,
	A1 = B1,
	C1 = D1,
	E1 = D1,
	F1 = G1,
	H1 = L,
	I1 = D,
	A1 = J1,
	C1 = K1,
	E1 = K1,
	F1 = L1,
	H1 = L,
	I1 = E,
	q,
	A1 = M1,
	C1 = N1,
	E1 = N1,
	F1 = O1,
	H1 = A1,
	G1 = A,
	r(L, I1, U, Z, A1, C1, E1, F1, H1, G1, L1),
	var(O1).

p / 5:
label(1):
	get_variable             17     a(1)     y(13) 
	move                     4     a(2)     y(14) 
	callf                    t / 0     Y[13,14,15,16,17] 
	put_variable             a(1) 
	put_global_variable      y(2) 
	put_variable2            a(1)     a(1) 
	move                     a(1)     a(2) 
	put_global_variable      a(3)     y(3) 
	get_value                a(2)     a(1) 
	move                     a(3)     y(4) 
	get_value                y(2)     y(2) 
	get_value                y(14)     y(15) 
	put_global_variable      y(5) 
	put_global_variable      a(1)     y(6) 
	move                     a(1)     y(7) 
	put_global_variable      y(8) 
	move                     y(8)     y(9)     y(2)     y(10)     y(16)     y(11) 
	get_value                y(6)     y(7) 
	move                     y(8)     y(12) 
	get_value                y(2)     y(10) 
	get_value                y(11)     y(17) 
	callf                    q / 0     Y[2,3,4,5,6,7,8,9,10,11,12,13] 
	get_value                y(6)     y(7) 
	move                     y(8)     y(1) 
	get_value                y(5)     y(10) 
	get_value                y(9)     y(13) 
	move                     y(2)     a(1)     y(11)     a(2) 
	move                     6     y(3)     a(3) 
	move                     y(10)     a(9)     y(9)     a(10)     y(12)     a(11) 
	callf                    r / 11     Y[1] 
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	exit                 

------ Test 101 -------
p :-
	p(A),
	q(B, A),
	r(B),
	t(B).

p / 0:
label(1):
	allocate                 2 
	put_global_variable_callf     a(1)     y(2)     p / 1     Y[2] 
	put_global_variable      a(1)     y(1) 
	move_callf               y(2)     a(2)     q / 2     Y[1] 
	move_callf               y(1)     a(1)     r / 1     Y[1] 
	move_chain               y(1)     a(1)     t / 1 

------ Test 102 -------
p :-
	p(A),
	q(A, B, C),
	r(B, D),
	t(D).

p / 0:
label(1):
	allocate                 3 
	put_global_variable_callf     a(1)     y(3)     p / 1     Y[3] 
	put_variable             a(3) 
	put_global_variable      a(2)     y(2) 
	move_callf               y(3)     a(1)     q / 3     Y[2] 
	put_global_variable      a(2)     y(1) 
	move_callf               y(2)     a(1)     r / 2     Y[1] 
	move_chain               y(1)     a(1)     t / 1 

------ Test 103 -------
p :-
	(
	    f(A),
	    g(A),
	    a(B)
	;
	    b(C),
	    c(C),
	    d(B)
	),
	e(B).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 2 
	put_global_variable_callf     a(1)     y(2)     f / 1     Y[2] 
	move_callf               y(2)     a(1)     g / 1     Y[] 
	put_global_variable_callf     a(1)     y(1)     a / 1     Y[1] 
	move_chain               y(1)     a(1)     e / 1 
label(3):
	trust_me                 0 
label(4):
	allocate                 2 
	put_global_variable_callf     a(1)     y(2)     b / 1     Y[2] 
	move_callf               y(2)     a(1)     c / 1     Y[] 
	put_global_variable_callf     a(1)     y(1)     d / 1     Y[1] 
	move_chain               y(1)     a(1)     e / 1 

------ Test 104 -------
p :-
	(
	    f(A),
	    g(A),
	    a(B)
	;
	    b(C),
	    c(C)
	),
	e(B).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 2 
	put_global_variable_callf     a(1)     y(2)     f / 1     Y[2] 
	move_callf               y(2)     a(1)     g / 1     Y[] 
	put_global_variable_callf     a(1)     y(1)     a / 1     Y[1] 
	move_chain               y(1)     a(1)     e / 1 
label(3):
	trust_me                 0 
label(4):
	allocate                 2 
	put_global_variable_callf     a(1)     y(2)     b / 1     Y[2] 
	move_callf               y(2)     a(1)     c / 1     Y[] 
	gc_test                  1 
	put_global_variable      y(1) 
	move_chain               y(1)     a(1)     e / 1 

------ Test 105 -------
p :-
	(
	    f(A),
	    g(A),
	    a(B)
	;
	    b(C),
	    c(C)
	),
	e(B),
	f(B).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 2 
	put_global_variable_callf     a(1)     y(2)     f / 1     Y[2] 
	move_callf               y(2)     a(1)     g / 1     Y[] 
	put_global_variable_callf     a(1)     y(1)     a / 1     Y[1] 
label(5):
	move_callf               y(1)     a(1)     e / 1     Y[1] 
	move_chain               y(1)     a(1)     f / 1 
label(3):
	trust_me                 0 
label(4):
	allocate                 2 
	put_global_variable_callf     a(1)     y(2)     b / 1     Y[2] 
	move_callf               y(2)     a(1)     c / 1     Y[] 
	gc_test                  1 
	put_global_variable      y(1) 
	branch                   ref(5) 

------ Test 106 -------
p :-
	a(A),
	(
	    b(A),
	    c(B)
	;
	    d(A),
	    e(B)
	),
	f(B).

p / 0:
label(1):
	allocate                 2 
	put_global_variable_callf     a(1)     y(2)     a / 1     Y[2] 
	try_me_else              0     0     ref(3) 
label(2):
	move_callf               y(2)     a(1)     b / 1     Y[] 
	put_global_variable_callf     a(1)     y(1)     c / 1     Y[1] 
	move_chain               y(1)     a(1)     f / 1 
label(3):
	trust_me_inline          0     Y[2] 
label(4):
	move_callf               y(2)     a(1)     d / 1     Y[] 
	put_global_variable_callf     a(1)     y(1)     e / 1     Y[1] 
	move_chain               y(1)     a(1)     f / 1 

------ Test 107 -------
p :-
	a(A),
	(
	    b(A),
	    c(B)
	;
	    d(A),
	    e(B)
	),
	f(C).

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     a / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move_callf               y(1)     a(1)     b / 1     Y[] 
	put_variable             a(1) 
	callf                    c / 1     Y[] 
label(5):
	put_variable             a(1) 
	chain                    f / 1 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	move_callf               y(1)     a(1)     d / 1     Y[] 
	put_variable             a(1) 
	callf                    e / 1     Y[] 
	branch                   ref(5) 

------ Test 108 -------
p :-
	a(A),
	(
	    b(A)
	;
	    c
	),
	d.

p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     a / 1     Y[1] 
	try_me_else              0     0     ref(3) 
label(2):
	move_callf               y(1)     a(1)     b / 1     Y[] 
	chain                    d / 0 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	callf                    c / 0     Y[] 
	chain                    d / 0 

------ Test 109 -------
p :-
	a,
	b(A),
	c(B),
	d(A),
	e(B),
	f.

p / 0:
label(1):
	allocate                 2 
	callf                    a / 0     Y[] 
	put_global_variable_callf     a(1)     y(2)     b / 1     Y[2] 
	put_global_variable_callf     a(1)     y(1)     c / 1     Y[1,2] 
	move_callf               y(2)     a(1)     d / 1     Y[1] 
	move_callf               y(1)     a(1)     e / 1     Y[] 
	chain                    f / 0 

------ Test 110 -------
p :-
	a(A),
	a(A, B, C),
	(
	    a
	;
	    (
		b(B),
		c(B)
	    ;
		(
		    d(D),
		    e(D)
		;
		    f(E),
		    g(E)
		)
	    )
	),
	f(D, C, F),
	g(F).

p / 0:
label(1):
	allocate                 6 
	put_global_variable_callf     a(1)     y(6)     a / 1     Y[6] 
	put_global_variable2     a(2)     y(4)     a(3)     y(3) 
	move_callf               y(6)     a(1)     a / 3     Y[3,4] 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[3] 
	gc_test                  1 
	put_global_variable      y(2) 
label(9):
	put_global_variable      a(3)     y(1) 
	move                     2     y(2)     a(1) 
	callf                    f / 3     Y[1] 
	move_chain               y(1)     a(1)     g / 1 
label(3):
	retry_me_inline          0     ref(5)     Y[3,4] 
label(4):
	move_callf               y(4)     a(1)     b / 1     Y[3,4] 
	move_callf               y(4)     a(1)     c / 1     Y[3] 
	gc_test                  1 
	put_global_variable      y(2) 
	branch                   ref(9) 
label(5):
	retry_me_inline          0     ref(7)     Y[3] 
label(6):
	put_global_variable_callf     a(1)     y(2)     d / 1     Y[2,3] 
	move_callf               y(2)     a(1)     e / 1     Y[2,3] 
	branch                   ref(9) 
label(7):
	trust_me_inline          0     Y[3] 
label(8):
	put_global_variable_callf     a(1)     y(5)     f / 1     Y[3,5] 
	move_callf               y(5)     a(1)     g / 1     Y[3] 
	gc_test                  1 
	put_global_variable      y(2) 
	branch                   ref(9) 

------ Test 120 -------
sentence(A, B, C, D, E) :-
	declarative(A, B, F, D, G),
	terminator(., F, C, G, E).

sentence / 5:
label(1):
	get_variable             4     a(3)     y(1) 
	move                     a(5)     y(2) 
	put_global_variable2     a(3)     y(3)     a(5)     y(4) 
	callf                    declarative / 5     Y[1,2,3,4] 
	put_atom                 a(1)     . 
	move                     y(3)     a(2)     y(1)     a(3)     y(4)     a(4) 
	move_chain               y(2)     a(5)     terminator / 5 

------ Test 130 -------
p(A, B) :-
	+(1, A, C),
	+(2, C, D),
	+(3, D, B).

p / 2:
label(1):
	bi_addi                  a(1)     1     a(1)     24 
	bi_addi                  a(1)     2     a(1)     24 
	bi_addi                  a(1)     3     a(1)     24 
	get_value                a(1)     a(2) 
	ret                  

------ Test 200 -------
p :-
	a(A, A).

p / 0:
label(1):
	put_variable             a(1) 
	move                     a(1)     a(2) 
	jmp                      a / 2 

------ Test 201 -------
p :-
	a(f(A), A).

p / 0:
label(1):
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	jmp                      a / 2 

------ Test 202 -------
p :-
	a(f(A), A),
	b(f(A), A),
	c(A, f(A)).

p / 0:
label(1):
	put_structure            a(1)     f / 1 
	allocate                 1 
	push_variable            y(1) 
	move_callf               y(1)     a(2)     a / 2     Y[1] 
	put_structure            a(1)     f / 1 
	push_value               y(1) 
	move_callf               y(1)     a(2)     b / 2     Y[1] 
	put_structure            a(2)     f / 1 
	push_value               y(1) 
	move_chain               y(1)     a(1)     c / 2 

------ Test 203 -------
p :-
	a(f(A), g(A)),
	b(f(g(A), A)),
	c(f(A, g(A))).

p / 0:
label(1):
	put_structure            a(1)     f / 1 
	allocate                 1 
	push_variable            y(1) 
	put_structure            a(2)     g / 1 
	push_value               y(1) 
	callf                    a / 2     Y[1] 
	put_structure            a(1)     f / 2 
	push_structure           2 
	push_value               y(1) 
	write_did                g / 1 
	push_value               y(1) 
	callf                    b / 1     Y[1] 
	put_structure            a(1)     f / 2 
	push_value               y(1) 
	push_structure           2 
	write_did                g / 1 
	push_value               y(1) 
	chain                    c / 1 

------ Test 204 -------
p(A) :-
	a(A).

p / 1:
label(1):
	jmp                      a / 1 

------ Test 205 -------
p(A) :-
	a(a, A).

p / 1:
label(1):
	move                     a(1)     a(2) 
	put_atom                 a(1)     a 
	jmp                      a / 2 

------ Test 206 -------
p(a).

p / 1:
label(1):
	get_atom                 a(1)     a 
	ret                  

------ Test 207 -------
p(A) :-
	a(A, A).

p / 1:
label(1):
	move                     a(1)     a(2) 
	jmp                      a / 2 

------ Test 208 -------
p(A, B) :-
	a(A, B).

p / 2:
label(1):
	jmp                      a / 2 

------ Test 209 -------
p(A, B) :-
	a(B, A).

p / 2:
label(1):
	swap                     a(1)     a(2) 
	jmp                      a / 2 

------ Test 210 -------
p :-
	A = B,
	a(B, A).

p / 0:
label(1):
	put_variable             a(2) 
	move                     a(2)     a(1) 
	jmp                      a / 2 

------ Test 211 -------
p :-
	a(A, f(A)).

p / 0:
label(1):
	put_structure            a(2)     f / 1 
	push_variable            a(1) 
	jmp                      a / 2 

------ Test 212 -------
p(A) :-
	a(f(A)).

p / 1:
label(1):
	move                     a(1)     a(2) 
	put_structure            a(1)     f / 1 
	push_value               a(2) 
	jmp                      a / 1 

------ Test 213 -------
p(A, B, C) :-
	a(C, A, B).

p / 3:
label(1):
	rot                      a(2)     a(1)     a(3) 
	jmp                      a / 3 

------ Test 214 -------
p(A, B, C) :-
	a(f(C), f(A), f(B)).

p / 3:
label(1):
	move                     a(1)     a(4) 
	put_structure            a(1)     f / 1 
	push_value               a(3) 
	move                     a(2)     a(5) 
	put_structure            a(2)     f / 1 
	push_value               a(4) 
	put_structure            a(3)     f / 1 
	push_value               a(5) 
	jmp                      a / 3 

------ Test 215 -------
p(A, B, C, A) :-
	a(C, A, B).

p / 4:
label(1):
	get_value                a(4)     a(1) 
	rot                      a(2)     a(1)     a(3) 
	jmp                      a / 3 

------ Test 216 -------
p(A, B, C, A) :-
	a(f(C), f(A), f(B)).

p / 4:
label(1):
	get_value                a(4)     a(1) 
	move                     a(1)     a(4) 
	put_structure            a(1)     f / 1 
	push_value               a(3) 
	move                     a(2)     a(5) 
	put_structure            a(2)     f / 1 
	push_value               a(4) 
	put_structure            a(3)     f / 1 
	push_value               a(5) 
	jmp                      a / 3 

------ Test 217 -------
p(f(A)) :-
	q(A).

p / 1:
label(1):
	get_structure            a(1)     f / 1     ref(2) 
	write_variable           a(1) 
	jmp                      q / 1 
label(2):
	read_variable            a(1) 
	jmp                      q / 1 

------ Test 218 -------
p(A, B, C) :-
	a(B, C, A).

p / 3:
label(1):
	rot                      a(3)     a(1)     a(2) 
	jmp                      a / 3 

------ Test 219 -------
p(A, B, C) :-
	D = A,
	a(C, D, B).

p / 3:
label(1):
	rot                      a(3)     a(2)     a(1) 
	jmp                      a / 3 

------ Test 220 -------
p(A, B, C) :-
	D = A,
	a(B, C, D).

p / 3:
label(1):
	rot                      a(2)     a(3)     a(1) 
	jmp                      a / 3 

------ Test 221 -------
p :-
	a(A, f(A)).

p / 0:
label(1):
	put_structure            a(2)     f / 1 
	push_variable            a(1) 
	jmp                      a / 2 

------ Test 222 -------
p :-
	q(a, A, B, A).

p / 0:
label(1):
	put_variable2            a(2)     a(3) 
	put_atom                 a(1)     a 
	move                     a(2)     a(4) 
	jmp                      q / 4 

------ Test 223 -------
p :-
	q(A, A),
	r(A).

p / 0:
label(1):
	allocate                 1 
	put_global_variable      a(1)     y(1) 
	move                     a(1)     a(2) 
	callf                    q / 2     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 224 -------
p :-
	q(f(A), A),
	r(A).

p / 0:
label(1):
	put_structure            a(1)     f / 1 
	allocate                 1 
	push_variable            y(1) 
	move_callf               y(1)     a(2)     q / 2     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 225 -------
p :-
	q([a]),
	r(A).

p / 0:
label(1):
	put_list                 a(1) 
	write_atom               a 
	push_nil             
	allocate                 0 
	callf                    q / 1     Y[] 
	put_variable             a(1) 
	chain                    r / 1 

------ Test 226 -------
p :-
	q([a, b]),
	r(A).

p / 0:
label(1):
	put_list                 a(1) 
	write_atom               a 
	push_list            
	write_atom               b 
	push_nil             
	allocate                 0 
	callf                    q / 1     Y[] 
	put_variable             a(1) 
	chain                    r / 1 

------ Test 227 -------
p :-
	q([a, A, b]),
	r(A).

p / 0:
label(1):
	put_list                 a(1) 
	write_atom               a 
	push_list            
	allocate                 1 
	push_variable            y(1) 
	push_list            
	write_atom               b 
	push_nil             
	callf                    q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 228 -------
p :-
	q([a, b|A]),
	r(A).

p / 0:
label(1):
	put_list                 a(1) 
	write_atom               a 
	push_list            
	write_atom               b 
	allocate                 1 
	push_variable            y(1) 
	callf                    q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 229 -------
p :-
	q([A], A),
	r(A).

p / 0:
label(1):
	put_list                 a(1) 
	allocate                 1 
	push_variable            y(1) 
	push_nil             
	move_callf               y(1)     a(2)     q / 2     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 230 -------
p :-
	q(A, [A]),
	r(A).

p / 0:
label(1):
	put_list                 a(2) 
	allocate                 1 
	push_variable            y(1) 
	push_nil             
	move_callf               y(1)     a(1)     q / 2     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test 231 -------
p :-
	q([A], A).

p / 0:
label(1):
	put_list                 a(1) 
	push_variable            a(2) 
	push_nil             
	jmp                      q / 2 

------ Test 232 -------
p :-
	q(A, [A]).

p / 0:
label(1):
	put_list                 a(2) 
	push_variable            a(1) 
	push_nil             
	jmp                      q / 2 

------ Test 233 -------
p(A) :-
	q([A], A).

p / 1:
label(1):
	move                     a(1)     a(2) 
	put_list                 a(1) 
	push_value               a(2) 
	push_nil             
	jmp                      q / 2 

------ Test 234 -------
p(A) :-
	q(A, [A]).

p / 1:
label(1):
	put_list                 a(2) 
	push_value               a(1) 
	push_nil             
	jmp                      q / 2 

------ Test 235 -------
p(A) :-
	q("hello", 3.4, 5_2).

p / 1:
label(1):
	put_string               a(1)     "hello" 
	put_constant             a(2)     3.4 
	put_constant             a(3)     5_2 
	jmp                      q / 3 

------ Test 236 -------
p(A) :-
	q(f("hello", 3.4, 5_2)).

p / 1:
label(1):
	put_structure            a(1)     f / 3 
	push_string              "hello" 
	push_constant            3.4 
	push_constant            5_2 
	jmp                      q / 1 

------ Test 240 -------
p :-
	p(A, B),
	(
	    p(A),
	    r,
	    p(B),
	    s
	;
	    p(B),
	    r,
	    p(A),
	    s
	).

p / 0:
label(1):
	allocate                 2 
	put_global_variable2     a(1)     y(1)     a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
	try_me_else              0     0     ref(3) 
label(2):
	move_callf               y(1)     a(1)     p / 1     Y[2] 
	callf                    r / 0     Y[2] 
	move_callf               y(2)     a(1)     p / 1     Y[] 
	chain                    s / 0 
label(3):
	trust_me_inline          0     Y[1,2] 
label(4):
	move_callf               y(2)     a(1)     p / 1     Y[1] 
	callf                    r / 0     Y[1] 
	move_callf               y(1)     a(1)     p / 1     Y[] 
	chain                    s / 0 

------ Test jdm(1) -------
p(A, B, a) :-
	q(A, b, f(B)).

p / 3:
label(1):
	get_atom                 a(3)     a 
	put_structure            a(3)     f / 1 
	push_value               a(2) 
	put_atom                 a(2)     b 
	jmp                      q / 3 

------ Test jdm(2) -------
del(t(nil, A, B), A, B).
del(t(A, B, nil), B, A).
del(t(A, B, C), B, r(A, D, E)) :-
	delmin(C, D, E).

INDEXES for (nondet) disjunction [2]
1. Quality 2.5
    [] - [1, 2]
    [structure] - [1, 2]
    [structure, r / 3] - [1, 2, 3]
    [var] - [1, 2, 3]
2. Quality 3.0
    [] - []
    [structure] - []
    [structure, t / 3] - [1, 2, 3]
    [var] - [1, 2, 3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: trust
del / 3:
label(1):
	functor_switch           a(3) 
		r / 3: 	ref(3)
		default: 	ref(16)

label(3):
	try_me_else              0     3     ref(6) 
label(4):
	get_structure            a(1)     t / 3     ref(5) 
	write_atom               nil 
	write_value              a(2) 
	write_value              a(3) 
	ret                  
label(5):
	read_atom                nil 
	read_value               a(2) 
	read_value               a(3) 
	ret                  
label(6):
	retry_me_else            0     ref(9) 
label(7):
	get_structure            a(1)     t / 3     ref(8) 
	write_value              a(3) 
	write_value              a(2) 
	write_atom               nil 
	ret                  
label(8):
	read_value               a(3) 
	read_value               a(2) 
	read_atom                nil 
	ret                  
label(9):
	trust_me                 0 
label(10):
	get_structure            a(1)     t / 3     ref(11) 
	write_variable           a(4) 
	write_value              a(2) 
	write_variable           a(1) 
	branch                   ref(12) 
label(11):
	read_variable            a(4) 
	read_value               a(2) 
	read_variable            a(1) 
label(12):
	get_structure            a(3)     r / 3     ref(13) 
	write_value              a(4) 
	write_variable2          a(2)     a(3) 
	jmp                      delmin / 3 
label(13):
	read_value               a(4) 
	read_variable2           a(2)     a(3) 
	jmp                      delmin / 3 
label(16):
	try                      0     3     ref(4) 
	trust                    0     ref(7) 

------ Test jdm(3) -------
dob(person(A, B, C, D), C).

dob / 2:
label(1):
	get_structure            a(1)     person / 4     ref(2) 
	write_void               2 
	write_value              a(2) 
	write_void           
	ret                  
label(2):
	read_void                2 
	read_value               a(2) 
	ret                  

------ Test jdm(4) -------
qsort([A|B], C) :-
	split(A, B, D, E),
	qsort(D, F),
	qsort(E, G),
	append(F, G, C).

qsort / 2:
label(1):
	get_list                 a(1)     ref(2) 
	write_variable           a(1) 
	move                     a(2)     a(5) 
	write_variable           a(2) 
	branch                   ref(3) 
label(2):
	read_variable            a(1) 
	move                     a(2)     a(5) 
	read_variable            a(2) 
label(3):
	get_variable             5     a(5)     y(3) 
	put_global_variable2     a(3)     y(5)     a(4)     y(4) 
	callf                    split / 4     Y[3,4,5] 
	put_global_variable      a(2)     y(2) 
	move_callf               y(5)     a(1)     ref(1)     Y[2,3,4] 
	put_global_variable      a(2)     y(1) 
	move_callf               y(4)     a(1)     ref(1)     Y[1,2,3] 
	move                     y(2)     a(1)     y(1)     a(2)     y(3)     a(3) 
	chain                    append / 3 

------ Test jdm(r4) -------
qsort(A, [B|C]) :-
	split(B, C, D, E),
	qsort(D, F),
	qsort(E, G),
	append(F, G, A).

qsort / 2:
label(1):
	get_list                 a(2)     ref(2) 
	move                     a(1)     a(5) 
	write_variable2          a(1)     a(2) 
	branch                   ref(3) 
label(2):
	move                     a(1)     a(5) 
	read_variable2           a(1)     a(2) 
label(3):
	get_variable             5     a(5)     y(3) 
	put_global_variable2     a(3)     y(5)     a(4)     y(4) 
	callf                    split / 4     Y[3,4,5] 
	put_global_variable      a(2)     y(2) 
	move_callf               y(5)     a(1)     ref(1)     Y[2,3,4] 
	put_global_variable      a(2)     y(1) 
	move_callf               y(4)     a(1)     ref(1)     Y[1,2,3] 
	move                     y(2)     a(1)     y(1)     a(2)     y(3)     a(3) 
	chain                    append / 3 

------ Test jdm(5) -------
rev(A, B) :-
	revacc([], A, B).

rev / 2:
label(1):
	shift                    a(3)     a(2)     a(1) 
	put_nil                  a(1) 
	jmp                      revacc / 3 

------ Test jdm(6) -------
p(A, B, C, D) :-
	q(a, A, B, C, D).

p / 4:
label(1):
	shift                    a(5)     a(4)     a(3)     a(2)     a(1) 
	put_atom                 a(1)     a 
	jmp                      q / 5 

------ Test mjt(1) -------
p(f(A), g(A)) :-
	q(a, A).

p / 2:
label(1):
	get_structure            a(1)     f / 1     ref(2) 
	move                     a(2)     a(3) 
	write_variable           a(2) 
	get_structure            a(3)     g / 1     ref(4) 
	write_value              a(2) 
	put_atom                 a(1)     a 
	jmp                      q / 2 
label(2):
	move                     a(2)     a(3) 
	read_variable            a(2) 
	get_structure            a(3)     g / 1     ref(4) 
	write_value              a(2) 
	put_atom                 a(1)     a 
	jmp                      q / 2 
label(4):
	read_value               a(2) 
	put_atom                 a(1)     a 
	jmp                      q / 2 

------ Test mjt(2) -------
p(b(A, B), B, C, a(A)) :-
	q(c, C, A, B).

p / 4:
label(1):
	get_structure            a(1)     b / 2     ref(2) 
	shift                    a(5)     a(4)     a(2)     a(3) 
	write_variable           a(3) 
	write_value              a(4) 
	get_structure            a(5)     a / 1     ref(4) 
	write_value              a(3) 
	put_atom                 a(1)     c 
	jmp                      q / 4 
label(2):
	shift                    a(5)     a(4)     a(2)     a(3) 
	read_variable            a(3) 
	read_value               a(4) 
	get_structure            a(5)     a / 1     ref(4) 
	write_value              a(3) 
	put_atom                 a(1)     c 
	jmp                      q / 4 
label(4):
	read_value               a(3) 
	put_atom                 a(1)     c 
	jmp                      q / 4 

------ Test mjt(3) -------
p(g(A), s(B, h(A)), f(B)) :-
	var(B),
	var(A),
	q(a, A, B).

p / 3:
label(1):
	get_structure            a(1)     g / 1     ref(2) 
	move                     a(2)     a(4) 
	write_variable           a(2) 
	branch                   ref(3) 
label(2):
	move                     a(2)     a(4) 
	read_variable            a(2) 
label(3):
	get_structure            a(4)     s / 2     ref(5) 
	move                     a(3)     a(4) 
	write_variable           a(3) 
	write_structure          h / 1 
label(4):
	write_value              a(2) 
	get_structure            a(4)     f / 1     ref(7) 
	write_value              a(3) 
	branch                   ref(8) 
label(5):
	move                     a(3)     a(4) 
	read_variable            a(3) 
	read_last_structure      h / 1     ref(4) 
	read_value               a(2) 
	get_structure            a(4)     f / 1     ref(7) 
	write_value              a(3) 
	branch                   ref(8) 
label(7):
	read_value               a(3) 
label(8):
	bi_var                   a(3) 
	bi_var                   a(2) 
	put_atom                 a(1)     a 
	jmp                      q / 3 

------ Test 300 -------
p(A, B) :-
	p(A),
	+(A, B, C),
	-(A, D, C),
	q(C).

p / 2:
label(1):
	get_variable             2     a(1)     y(1) 
	move                     a(2)     y(2) 
	callf                    p / 1     Y[1,2] 
	move                     2     y(1)     a(2) 
	bi_add                   a(2)     a(3)     a(1)     16 
	put_variable             a(3) 
	bi_sub                   a(2)     a(3)     a(2)     16 
	get_value                a(2)     a(1) 
	chain                    q / 1 

------ Test 301 -------
p(A, B) :-
	p(A),
	r(A, B, C),
	q(C).

p / 2:
label(1):
	get_variable             3     a(1)     y(2) 
	move                     a(2)     y(3) 
	callf                    p / 1     Y[2,3] 
	put_global_variable      a(3)     y(1) 
	move                     2     y(2)     a(1) 
	callf                    r / 3     Y[1] 
	move_chain               y(1)     a(1)     q / 1 

------ Test 302 -------
p(A, B) :-
	p(B),
	r(A, B, C),
	q(C).

p / 2:
label(1):
	get_variable             3     a(1)     y(2) 
	move                     a(2)     y(3) 
	move                     a(2)     a(1) 
	callf                    p / 1     Y[2,3] 
	put_global_variable      a(3)     y(1) 
	move                     2     y(2)     a(1) 
	callf                    r / 3     Y[1] 
	move_chain               y(1)     a(1)     q / 1 

------ Test 303 -------
p :-
	q,
	A = 1,
	B = 3,
	p(C),
	r(A, C, B).

p / 0:
label(1):
	allocate                 3 
	callf                    q / 0     Y[] 
	put_integer              a(2)     1 
	move                     a(2)     y(1) 
	put_integer              a(3)     3 
	move                     a(3)     y(2) 
	put_global_variable_callf     a(1)     y(3)     p / 1     Y[1,2,3] 
	move                     y(1)     a(1)     y(3)     a(2)     y(2)     a(3) 
	chain                    r / 3 

------ Test 304 -------
p :-
	q,
	A = f(B),
	a(A, B).

p / 0:
label(1):
	allocate                 0 
	callf                    q / 0     Y[] 
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	chain                    a / 2 

------ Test 305 -------
p(A, B) :-
	C = 1,
	A = B,
	q(B, C).

p / 2:
label(1):
	shift                    a(3)     a(1)     a(2) 
	put_integer              a(2)     1 
	get_value                a(3)     a(1) 
	jmp                      q / 2 

------ Test 306 -------
p1(A) :-
	A = 1.

p1 / 1:
label(1):
	get_integer              a(1)     1 
	ret                  

------ Test 307 -------
p2(A) :-
	1 = A.

p2 / 1:
label(1):
	get_integer              a(1)     1 
	ret                  

------ Test 308 -------
p3(A) :-
	A = 1,
	p1(A),
	p1(A).

p3 / 1:
label(1):
	get_integer              a(1)     1 
	get_variable             1     a(1)     y(1) 
	callf                    p1 / 1     Y[1] 
	move_chain               y(1)     a(1)     p1 / 1 

------ Test 309 -------
p4(A) :-
	1 = A,
	p1(A),
	p1(A).

p4 / 1:
label(1):
	get_integer              a(1)     1 
	get_variable             1     a(1)     y(1) 
	callf                    p1 / 1     Y[1] 
	move_chain               y(1)     a(1)     p1 / 1 

------ Test 310 -------
p5(f(A)) :-
	A = 1,
	p1(A),
	p1(A).

p5 / 1:
label(1):
	allocate                 1 
	get_structure            a(1)     f / 1     ref(2) 
	write_variable           y(1) 
	branch                   ref(3) 
label(2):
	read_variable            y(1) 
label(3):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 1     Y[1] 
	move_chain               y(1)     a(1)     p1 / 1 

------ Test 311 -------
p5a(f(A)) :-
	p1(A),
	A = 1,
	p1(A).

p5a / 1:
label(1):
	allocate                 1 
	get_structure            a(1)     f / 1     ref(2) 
	write_variable           y(1) 
	branch                   ref(3) 
label(2):
	read_variable            y(1) 
label(3):
	move_callf               y(1)     a(1)     p1 / 1     Y[1] 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	chain                    p1 / 1 

------ Test 312 -------
p6(f(A)) :-
	1 = A,
	p1(A),
	p1(A).

p6 / 1:
label(1):
	allocate                 1 
	get_structure            a(1)     f / 1     ref(2) 
	write_variable           y(1) 
	branch                   ref(3) 
label(2):
	read_variable            y(1) 
label(3):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	callf                    p1 / 1     Y[1] 
	move_chain               y(1)     a(1)     p1 / 1 

------ Test 313 -------
p6a(f(A)) :-
	p1(A),
	1 = A,
	p1(A).

p6a / 1:
label(1):
	allocate                 1 
	get_structure            a(1)     f / 1     ref(2) 
	write_variable           y(1) 
	branch                   ref(3) 
label(2):
	read_variable            y(1) 
label(3):
	move_callf               y(1)     a(1)     p1 / 1     Y[1] 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	chain                    p1 / 1 

------ Test 314 -------
p7(f(A)) :-
	A = 1,
	p1(A).

p7 / 1:
label(1):
	get_structure            a(1)     f / 1     ref(2) 
	write_variable           a(1) 
	get_integer              a(1)     1 
	jmp                      p1 / 1 
label(2):
	read_variable            a(1) 
	get_integer              a(1)     1 
	jmp                      p1 / 1 

------ Test 315 -------
p8(f(A)) :-
	1 = A,
	p1(A).

p8 / 1:
label(1):
	get_structure            a(1)     f / 1     ref(2) 
	write_variable           a(1) 
	get_integer              a(1)     1 
	jmp                      p1 / 1 
label(2):
	read_variable            a(1) 
	get_integer              a(1)     1 
	jmp                      p1 / 1 

------ Test 316 -------
p9(A) :-
	B = 1,
	p1(B),
	p1(B),
	B = A.

p9 / 1:
label(1):
	allocate                 2 
	move                     a(1)     a(2) 
	put_integer              a(1)     1 
	move                     a(1)     y(2)     a(2)     y(1) 
	callf                    p1 / 1     Y[1,2] 
	move_callf               y(2)     a(1)     p1 / 1     Y[1,2] 
	get_value                y(1)     y(2) 
	exit                 

------ Test 317 -------
p9a(A) :-
	p1(B),
	C = 1,
	p1(C),
	p1(C),
	C = A.

p9a / 1:
label(1):
	get_variable             2     a(1)     y(2) 
	put_variable             a(1) 
	callf                    p1 / 1     Y[2] 
	put_integer              a(1)     1 
	move                     a(1)     y(1) 
	callf                    p1 / 1     Y[1,2] 
	move_callf               y(1)     a(1)     p1 / 1     Y[1,2] 
	get_value                y(1)     y(2) 
	exit                 

------ Test 318 -------
p10(A) :-
	1 = B,
	p1(B),
	p1(B),
	B = A.

p10 / 1:
label(1):
	allocate                 2 
	move                     a(1)     a(2) 
	put_integer              a(1)     1 
	move                     a(1)     y(2)     a(2)     y(1) 
	callf                    p1 / 1     Y[1,2] 
	move_callf               y(2)     a(1)     p1 / 1     Y[1,2] 
	get_value                y(1)     y(2) 
	exit                 

------ Test 319 -------
p10a(A) :-
	p1(B),
	1 = C,
	p1(C),
	C = A.

p10a / 1:
label(1):
	get_variable             2     a(1)     y(2) 
	put_variable             a(1) 
	callf                    p1 / 1     Y[2] 
	put_integer              a(1)     1 
	move                     a(1)     y(1) 
	callf                    p1 / 1     Y[1,2] 
	get_value                y(1)     y(2) 
	exit                 

------ Test 320 -------
p11(A) :-
	B = 1,
	call(true),
	B = A.

p11 / 1:
label(1):
	allocate                 2 
	put_integer              a(3)     1 
	move                     a(3)     y(2)     a(1)     y(1) 
	put_atom                 a(1)     true 
	put_module               a(2)     eclipse 
	callf                    sepia_kernel : call_ / 2     Y[1,2] 
	get_value                y(1)     y(2) 
	exit                 

------ Test 321 -------
p12(A, B, C) :-
	D = 1,
	E = 2,
	F = 3,
	call(true),
	A = D,
	B = E,
	C = F.

p12 / 3:
label(1):
	allocate                 6 
	put_integer              a(4)     1 
	move                     a(4)     y(4) 
	put_integer              a(5)     2 
	move                     a(5)     y(5) 
	put_integer              a(6)     3 
	move                     a(6)     y(6) 
	move                     3     a(1)     y(1) 
	put_atom                 a(1)     true 
	put_module               a(2)     eclipse 
	callf                    sepia_kernel : call_ / 2     Y[1,2,3,4,5,6] 
	get_value                y(1)     y(4) 
	get_value                y(2)     y(5) 
	get_value                y(3)     y(6) 
	exit                 

------ Test 322 -------
p13(A, B) :-
	C = 1,
	D = 2,
	E = 3,
	current_op(F, G, H),
	A = C,
	B = D.

p13 / 2:
label(1):
	allocate                 4 
	put_integer              a(5)     1 
	move                     a(5)     y(3) 
	put_integer              a(6)     2 
	move                     a(6)     y(4) 
	move                     2     a(1)     y(1) 
	put_variable2            a(1)     a(2) 
	put_variable             a(3) 
	put_module               a(4)     eclipse 
	callf                    sepia_kernel : current_op_body / 4     Y[1,2,3,4] 
	get_value                y(1)     y(3) 
	get_value                y(2)     y(4) 
	exit                 

------ Test 323 -------
b1 :-
	A = s(B),
	eq(B, C),
	A = s(1),
	C = 1.

b1 / 0:
label(1):
	allocate                 2 
	put_structure            a(3)     s / 1 
	push_variable            a(1) 
	move                     a(3)     y(1) 
	put_global_variable_callf     a(2)     y(2)     eq / 2     Y[1,2] 
	move                     y(1)     a(1) 
	get_structure            a(1)     s / 1     ref(2) 
	write_integer            1 
	branch                   ref(3) 
label(2):
	read_integer             1 
label(3):
	move                     y(2)     a(1) 
	get_integer              a(1)     1 
	exit                 

------ Test 324 -------
do_x(A) :-
	(
	    A = B
	;
	    A = [1|B]
	),
	do_x(B).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
do_x / 1:
label(1):
	list_switch              a(1)     ref(2)     ref(3)     ref(3) 
label(2):
	try_me_else              0     1     ref(4) 
label(3):
	get_variable             1     a(1)     y(1) 
	move_chain               y(1)     a(1)     ref(1) 
label(4):
	trust_me                 0 
label(5):
	allocate                 1 
	get_list                 a(1)     ref(6) 
	write_integer            1 
	write_variable           y(1) 
	move_chain               y(1)     a(1)     ref(1) 
label(6):
	read_integer             1 
	read_variable            y(1) 
	move_chain               y(1)     a(1)     ref(1) 

------ Test u(1) -------
p(foo(A, B, C)) :-
	q(B),
	r(C).

p / 1:
label(1):
	allocate                 1 
	get_structure            a(1)     foo / 3     ref(2) 
	write_void           
	write_variable2          a(1)     y(1) 
	branch                   ref(3) 
label(2):
	read_void            
	read_variable2           a(1)     y(1) 
label(3):
	callf                    q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test ana(1) -------
p :-
	q,
	A = 1,
	B = 3,
	p(A).

p / 0:
label(1):
	allocate                 0 
	callf                    q / 0     Y[] 
	put_integer              a(1)     1 
	chain                    p / 1 

------ Test ana(2) -------
p :-
	A = 1,
	A = B.

p / 0:
label(1):
	put_integer              a(1)     1 
	ret                  

------ Test ana(3) -------
p :-
	A = B.

p / 0:
label(1):
	ret                  

------ Test ana(4) -------
p :-
	A = 3,
	B = A.

p / 0:
label(1):
	put_integer              a(1)     3 
	ret                  

------ Test ana(5) -------
p :-
	A = 3,
	q,
	A = 4,
	r.

WARNING: calling =/2 will always fail
p / 0:
label(1):
	allocate                 1 
	put_integer              a(1)     3 
	move                     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	get_integer              a(1)     4 
	chain                    r / 0 

------ Test ana(6) -------
p :-
	A = 3,
	q,
	B = A,
	r,
	B = 4.

WARNING: calling =/2 will always fail
p / 0:
label(1):
	allocate                 2 
	put_integer              a(1)     3 
	move                     a(1)     y(2) 
	callf                    q / 0     Y[2] 
	move                     y(2)     y(1) 
	callf                    r / 0     Y[1] 
	move                     y(1)     a(1) 
	get_integer              a(1)     4 
	exit                 

------ Test ana(7) -------
p :-
	A = f(B, C),
	q,
	A = f(D, E),
	r.

p / 0:
label(1):
	allocate                 1 
	put_structure            a(1)     f / 2 
	push_void                2 
	move                     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	get_structure            a(1)     f / 2     ref(2) 
	write_void               2 
label(2):
	chain                    r / 0 

------ Test ana(8) -------
p :-
	integer(A),
	(
	    A = 1
	;
	    A = 2
	),
	q.

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 0:
label(1):
	put_variable             a(1) 
	bi_integer               a(1) 
	integer_switch           a(1) 
		1: 	ref(8)
		2: 	ref(9)
		default: 	ref(fail)

label(3):
	try_me_else              0     1     ref(5) 
label(4):
	get_integer              a(1)     1 
label(8):
	jmp                      q / 0 
label(5):
	trust_me                 0 
label(6):
	get_integer              a(1)     2 
label(9):
	jmp                      q / 0 

------ Test ana(9) -------
p(A, B) :-
	f(a, B) = f(A, b),
	q.

p / 2:
label(1):
	get_atom                 a(1)     a 
	get_atom                 a(2)     b 
	jmp                      q / 0 

------ Test idx(1) -------
p :-
	p(A),
	(
	    A = 1,
	    p1
	;
	    A = 2,
	    p2
	).

INDEXES for (nondet) disjunction [3]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [3]
    Branch 1: try
    Branch 2: trust
p / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
	integer_switch           y(1) 
		1: 	ref(4)
		2: 	ref(6)
		default: 	ref(fail)

label(3):
	try_me_else              0     0     ref(5) 
label(4):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	chain                    p1 / 0 
label(5):
	trust_me_inline          0     Y[1] 
label(6):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	chain                    p2 / 0 

------ Test idx(2) -------
p :-
	p(A, B),
	(
	    B = a,
	    A = 1,
	    p1
	;
	    A = 2,
	    B = b,
	    p2
	).

INDEXES for (nondet) disjunction [3]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
2. Quality 1.3
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
    [var] - [1, 2]
Branch determinisms for disjunction [3]
    Branch 1: try
    Branch 2: trust
p / 0:
label(1):
	allocate                 2 
	put_global_variable2     a(1)     y(1)     a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
	integer_switch           y(1) 
		1: 	ref(5)
		2: 	ref(7)
		default: 	ref(fail)

	atom_switch              y(2) 
		a: 	ref(5)
		b: 	ref(7)
		default: 	ref(fail)

label(4):
	try_me_else              0     0     ref(6) 
label(5):
	move                     y(2)     a(1) 
	get_atom                 a(1)     a 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	chain                    p1 / 0 
label(6):
	trust_me_inline          0     Y[1,2] 
label(7):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	move                     y(2)     a(1) 
	get_atom                 a(1)     b 
	chain                    p2 / 0 

------ Test idx(3) -------
p(A, B) :-
	(
	    B = a,
	    A = 1,
	    p1
	;
	    (
		A = 2,
		B = b,
		p2
	    ;
		B = c,
		p3
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
    [atom, c] - [3]
    [var] - [1, 2, 3]
2. Quality 2.0
    [] - [3]
    [var] - [1, 2, 3]
    [integer] - [3]
    [integer, 1] - [1, 3]
    [integer, 2] - [2, 3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: trust
p / 2:
label(1):
	atom_switch              a(2) 
		a: 	ref(12)
		b: 	ref(6)
		c: 	ref(13)
		default: 	ref(fail)

	integer_switch           a(1) 
		1: 	ref(10)
		2: 	ref(11)
		default: 	ref(8)

label(3):
	try_me_else              0     2     ref(5) 
label(4):
	get_atom                 a(2)     a 
label(12):
	get_integer              a(1)     1 
	jmp                      p1 / 0 
label(5):
	retry_me_else            0     ref(7) 
label(6):
	get_integer              a(1)     2 
	get_atom                 a(2)     b 
	jmp                      p2 / 0 
label(7):
	trust_me                 0 
label(8):
	get_atom                 a(2)     c 
label(13):
	jmp                      p3 / 0 
label(10):
	try                      0     2     ref(4) 
	trust                    0     ref(8) 
label(11):
	try                      0     2     ref(6) 
	trust                    0     ref(8) 

------ Test idx(4) -------
p(A, B) :-
	(
	    B = a,
	    A = 1,
	    p1
	;
	    (
		integer(A),
		B = b,
		p2
	    ;
		number(A),
		p3
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.8
    [] - []
    [var] - [1]
    [rational] - [3]
    [breal] - [3]
    [bignum] - [2, 3]
    [integer] - [2, 3]
    [integer, 1] - [1, 2, 3]
    [double] - [3]
2. Quality 2.0
    [] - [3]
    [atom] - [3]
    [atom, a] - [1, 3]
    [atom, b] - [2, 3]
    [var] - [1, 2, 3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: trust
p / 2:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(4)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(10)
		breal: 	ref(13)
		double: 	ref(13)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(11)
		list: 	ref(fail)
		rational: 	ref(13)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(4) 
label(2):
	atom_switch              a(2) 
		a: 	ref(12)
		b: 	ref(10)
		default: 	ref(8)

label(3):
	try_me_else              0     2     ref(5) 
label(4):
	get_atom                 a(2)     a 
	get_integer              a(1)     1 
	jmp                      p1 / 0 
label(5):
	retry_me_else            0     ref(7) 
label(6):
	bi_integer               a(1) 
	get_atom                 a(2)     b 
	jmp                      p2 / 0 
label(7):
	trust_me                 0 
label(8):
	bi_number                a(1) 
label(13):
	jmp                      p3 / 0 
label(10):
	try                      0     2     ref(6) 
	trust                    0     ref(8) 
label(11):
	integer_switch           a(1) 
		1: 	ref(2)
		default: 	ref(10)

label(12):
	try                      0     2     ref(4) 
	trust                    0     ref(8) 

------ Test idx(5) -------
p(A) :-
	(
	    A = 1,
	    p1
	;
	    (
		A = 2,
		p2
	    ;
		(
		    integer(A),
		    p3
		;
		    number(A),
		    p4
		)
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 2.2
    [] - []
    [var] - [1, 2]
    [rational] - [4]
    [breal] - [4]
    [bignum] - [3, 4]
    [integer] - [3, 4]
    [integer, 1] - [1, 3, 4]
    [integer, 2] - [2, 3, 4]
    [double] - [4]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: retry
    Branch 4: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(14)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(11)
		breal: 	ref(16)
		double: 	ref(16)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(15)
		list: 	ref(fail)
		rational: 	ref(16)
		string: 	ref(fail)
		structure: 	ref(fail)

label(14):
	try                      0     1     ref(3) 
	trust                    0     ref(5) 
label(3):
	get_integer              a(1)     1 
	jmp                      p1 / 0 
label(5):
	get_integer              a(1)     2 
	jmp                      p2 / 0 
label(7):
	bi_integer               a(1) 
	jmp                      p3 / 0 
label(9):
	bi_number                a(1) 
label(16):
	jmp                      p4 / 0 
label(11):
	try                      0     1     ref(7) 
	trust                    0     ref(9) 
label(12):
	try                      0     1     ref(3) 
	retry                    0     ref(7) 
	trust                    0     ref(9) 
label(13):
	try                      0     1     ref(5) 
	retry                    0     ref(7) 
	trust                    0     ref(9) 
label(15):
	integer_switch           a(1) 
		1: 	ref(12)
		2: 	ref(13)
		default: 	ref(11)


------ Test idx(6) -------
p :-
	p(A, B),
	(
	    B == a,
	    A = 1,
	    p1
	;
	    A = 2,
	    B == b,
	    p2
	).

INDEXES for (semidet) disjunction [3]
1. Quality 1.0
    [] - []
    [var] - [2]
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
2. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [3]
    Branch 1: det
    Branch 2: det
p / 0:
label(1):
	allocate                 2 
	put_global_variable2     a(1)     y(1)     a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
	atom_switch              y(2) 
		a: 	ref(5)
		b: 	ref(7)
		default: 	ref(fail)

label(7):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	move                     y(2)     a(1) 
	in_get_atom              a(1)     b 
	chain                    p2 / 0 
label(5):
	move                     y(2)     a(1) 
	in_get_atom              a(1)     a 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	chain                    p1 / 0 

------ Test idx(7) -------
p(A) :-
	(
	    A = [],
	    p1
	;
	    A = [B|C],
	    p2
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [list] - [2]
    [[]] - [1]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	list_switch              a(1)     ref(6)     ref(8)     ref(fail) 
label(2):
	try_me_else              0     1     ref(4) 
label(3):
	get_nil                  a(1) 
label(8):
	jmp                      p1 / 0 
label(4):
	trust_me                 0 
label(5):
	get_list                 a(1)     ref(6) 
	write_void               2 
label(6):
	jmp                      p2 / 0 

------ Test idx(8) -------
p(A) :-
	(
	    var(A),
	    !,
	    p
	;
	    q
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [2]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(7)
		[]: 	ref(5)
		atom: 	ref(5)
		bignum: 	ref(5)
		breal: 	ref(5)
		double: 	ref(5)
		goal: 	ref(5)
		handle: 	ref(5)
		integer: 	ref(5)
		list: 	ref(5)
		rational: 	ref(5)
		string: 	ref(5)
		structure: 	ref(5)

	branch                   ref(7) 
label(3):
	bi_var                   a(1) 
label(7):
	jmp                      p / 0 
label(5):
	jmp                      q / 0 

------ Test idx(9) -------
p(A) :-
	(
	    A = 3.1,
	    p
	;
	    A = 9.9,
	    q
	).

INDEXES for (nondet) disjunction [2]
1. Quality 2.0
    [] - []
    [var] - [1, 2]
    [double] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	try_me_else              0     1     ref(3) 
label(2):
	get_constant             a(1)     3.1 
	jmp                      p / 0 
label(3):
	trust_me                 0 
label(4):
	get_constant             a(1)     9.9 
	jmp                      q / 0 

------ Test idx(10) -------
p(A) :-
	(
	    A = "foo",
	    p
	;
	    (
		A = "bar",
		q
	    ;
		r
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 2.0
    [] - [3]
    [var] - [1, 2, 3]
    [string] - [1, 2, 3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(2)
		[]: 	ref(7)
		atom: 	ref(7)
		bignum: 	ref(7)
		breal: 	ref(7)
		double: 	ref(7)
		goal: 	ref(7)
		handle: 	ref(7)
		integer: 	ref(7)
		list: 	ref(7)
		rational: 	ref(7)
		string: 	ref(2)
		structure: 	ref(7)

label(2):
	try_me_else              0     1     ref(4) 
label(3):
	get_string               a(1)     "foo" 
	jmp                      p / 0 
label(4):
	retry_me_else            0     ref(6) 
label(5):
	get_string               a(1)     "bar" 
	jmp                      q / 0 
label(6):
	trust_me                 0 
label(7):
	jmp                      r / 0 

------ Test idx(11) -------
p(A) :-
	(
	    A = f(1),
	    p
	;
	    (
		A = g(1, 2),
		q
	    ;
		r
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 2.0
    [] - [3]
    [structure] - [3]
    [structure, g / 2] - [2, 3]
    [structure, f / 1] - [1, 3]
    [var] - [1, 2, 3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: trust
p / 1:
label(1):
	functor_switch           a(1) 
		g / 2: 	ref(14)
		f / 1: 	ref(15)
		default: 	ref(12)

label(3):
	try_me_else              0     1     ref(7) 
label(4):
	get_structure            a(1)     f / 1     ref(5) 
	write_integer            1 
	jmp                      p / 0 
label(5):
	read_integer             1 
	jmp                      p / 0 
label(7):
	retry_me_else            0     ref(11) 
label(8):
	get_structure            a(1)     g / 2     ref(9) 
	write_integer2           1     2 
	jmp                      q / 0 
label(9):
	read_integer             1 
	read_integer             2 
	jmp                      q / 0 
label(11):
	trust_me                 0 
label(12):
	jmp                      r / 0 
label(14):
	try                      0     1     ref(8) 
	trust                    0     ref(12) 
label(15):
	try                      0     1     ref(4) 
	trust                    0     ref(12) 

------ Test idx(12) -------
p(A) :-
	(
	    A = [],
	    p
	;
	    r
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - [2]
    [[]] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	list_switch              a(1)     ref(5)     ref(2)     ref(5) 
label(2):
	try_me_else              0     1     ref(4) 
label(3):
	get_nil                  a(1) 
	jmp                      p / 0 
label(4):
	trust_me                 0 
label(5):
	jmp                      r / 0 

------ Test idx(13) -------
p(A) :-
	(
	    A = []
	->
	    p
	;
	    r
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [2]
    [[]] - [1]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	list_switch              a(1)     ref(5)     ref(7)     ref(5) 
label(3):
	get_nil                  a(1) 
label(7):
	jmp                      p / 0 
label(5):
	jmp                      r / 0 

------ Test idx(14) -------
p :-
	p(A, B),
	(
	    a == B,
	    1 = A,
	    p1
	;
	    2 = A,
	    b == B,
	    p2
	).

INDEXES for (semidet) disjunction [3]
1. Quality 1.0
    [] - []
    [var] - [2]
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
2. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [3]
    Branch 1: det
    Branch 2: det
p / 0:
label(1):
	allocate                 2 
	put_global_variable2     a(1)     y(1)     a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
	atom_switch              y(2) 
		a: 	ref(5)
		b: 	ref(7)
		default: 	ref(fail)

label(7):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	move                     y(2)     a(1) 
	in_get_atom              a(1)     b 
	chain                    p2 / 0 
label(5):
	move                     y(2)     a(1) 
	in_get_atom              a(1)     a 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	chain                    p1 / 0 

------ Test idx(15) -------
p :-
	p(A, B),
	(
	    a == B,
	    1 = A,
	    p1
	;
	    (
		2 = A,
		b == B,
		p2
	    ;
		A == B,
		p3
	    )
	).

INDEXES for (nondet) disjunction [3]
1. Quality 1.7
    [] - [3]
    [var] - [2, 3]
    [atom] - [3]
    [atom, a] - [1, 3]
    [atom, b] - [2, 3]
2. Quality 2.0
    [] - [3]
    [var] - [1, 2, 3]
    [integer] - [3]
    [integer, 1] - [1, 3]
    [integer, 2] - [2, 3]
Branch determinisms for disjunction [3]
    Branch 1: try
    Branch 2: try
    Branch 3: trust
p / 0:
label(1):
	allocate                 2 
	put_global_variable2     a(1)     y(1)     a(2)     y(2) 
	callf                    p / 2     Y[1,2] 
	atom_switch              y(2) 
		a: 	ref(11)
		b: 	ref(12)
		default: 	ref(9)

label(12):
	try                      0     0     ref(7) 
	trust_inline             0     ref(9)     Y[1,2] 
label(5):
	move                     y(2)     a(1) 
	in_get_atom              a(1)     a 
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	chain                    p1 / 0 
label(7):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	move                     y(2)     a(1) 
	in_get_atom              a(1)     b 
	chain                    p2 / 0 
label(9):
	move                     2     y(1)     a(1) 
	get_matched_value        a(1)     a(2) 
	chain                    p3 / 0 
label(11):
	try                      0     0     ref(5) 
	trust_inline             0     ref(9)     Y[1,2] 

------ Test idx(16) -------
p(A) :-
	(
	    var(B),
	    !,
	    p
	;
	    q
	).

p / 1:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	jmp                      p / 0 
label(3):
	trust_me                 0 
label(4):
	jmp                      q / 0 

------ Test idx(20) -------
p(A) :-
	(
	    A == [],
	    p
	;
	    A == [a],
	    q
	).

INDEXES for (semidet) disjunction [2]
1. Quality 0.7
    [] - []
    [list] - [2]
    [[]] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	list_switch              a(1)     ref(5)     ref(7)     ref(fail) 
	branch                   ref(fail) 
label(3):
	in_get_nil               a(1) 
label(7):
	jmp                      p / 0 
label(5):
	put_list                 a(2) 
	write_atom               a 
	push_nil             
	get_matched_value        a(1)     a(2) 
	jmp                      q / 0 

------ Test idx(21) -------
p(A) :-
	(
	    A == f(a),
	    r
	;
	    A == "hello",
	    s
	).

INDEXES for (semidet) disjunction [2]
1. Quality 0.7
    [] - []
    [structure] - []
    [structure, f / 1] - [1]
    [string] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(5)
		structure: 	ref(3)

	branch                   ref(fail) 
label(3):
	put_structure            a(2)     f / 1 
	write_atom               a 
	get_matched_value        a(1)     a(2) 
	jmp                      r / 0 
label(5):
	in_get_string            a(1)     "hello" 
	jmp                      s / 0 

------ Test idx(22) -------
p(A) :-
	(
	    A == [],
	    p
	;
	    (
		A == [a],
		q
	    ;
		A == f(a),
		r
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 0.8
    [] - []
    [list] - [2]
    [[]] - [1]
    [structure] - []
    [structure, f / 1] - [3]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(9)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(5)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(7)

	branch                   ref(fail) 
label(3):
	in_get_nil               a(1) 
label(9):
	jmp                      p / 0 
label(5):
	put_list                 a(2) 
	write_atom               a 
	push_nil             
	get_matched_value        a(1)     a(2) 
	jmp                      q / 0 
label(7):
	put_structure            a(2)     f / 1 
	write_atom               a 
	get_matched_value        a(1)     a(2) 
	jmp                      r / 0 

------ Test idx(23) -------
p :-
	(
	    A == [],
	    p
	;
	    q
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	put_variable             a(1) 
	in_get_nil               a(1) 
	jmp                      ref(1) 
label(3):
	trust_me                 0 
label(4):
	jmp                      q / 0 

------ Test idx(24) -------
p(A) :-
	(
	    A = f(B),
	    !,
	    p1
	;
	    (
		A = [C|D],
		!,
		p2
	    ;
		compound(A),
		p2
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [list] - [2]
    [structure] - [3]
    [structure, f / 1] - [1]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(3)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(6)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(11)

label(3):
	get_structure            a(1)     f / 1     ref(4) 
	write_void           
label(4):
	jmp                      p1 / 0 
label(6):
	get_list                 a(1)     ref(7) 
	write_void               2 
label(7):
	jmp                      p2 / 0 
label(9):
	bi_compound              a(1) 
	jmp                      p2 / 0 
label(11):
	functor_switch           a(1) 
		f / 1: 	ref(4)
		default: 	ref(9)


------ Test idx(25) -------
p(A) :-
	(
	    A = 1,
	    p_integer
	;
	    (
		A = 10000000000000000000,
		p_big
	    ;
		(
		    A = 1.1,
		    p_float
		;
		    (
			A = 5_2,
			p_rational
		    ;
			(
			    A = 0.9__1.1,
			    p_breal
			;
			    (
				A = "hello",
				p_string
			    ;
				(
				    A = hello,
				    p_atom
				;
				    (
					A = [],
					p_nil
				    ;
					(
					    A = [B|C],
					    p_list
					;
					    A = foo(bar),
					    p_struct
					)
				    )
				)
			    )
			)
		    )
		)
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.8
    [] - []
    [list] - [9]
    [[]] - [8]
    [structure] - []
    [structure, foo / 1] - [10]
    [atom] - []
    [atom, hello] - [7]
    [var] - [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    [breal] - [5]
    [rational] - [4]
    [bignum] - [2]
    [integer] - []
    [integer, 1] - [1]
    [string] - [6]
    [double] - [3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: retry
    Branch 4: retry
    Branch 5: retry
    Branch 6: retry
    Branch 7: retry
    Branch 8: retry
    Branch 9: retry
    Branch 10: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(2)
		[]: 	ref(26)
		atom: 	ref(15)
		bignum: 	ref(5)
		breal: 	ref(11)
		double: 	ref(7)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(3)
		list: 	ref(19)
		rational: 	ref(9)
		string: 	ref(13)
		structure: 	ref(22)

label(2):
	try_me_else              0     1     ref(4) 
label(3):
	get_integer              a(1)     1 
	jmp                      p_integer / 0 
label(4):
	retry_me_else            0     ref(6) 
label(5):
	get_constant             a(1)     10000000000000000000 
	jmp                      p_big / 0 
label(6):
	retry_me_else            0     ref(8) 
label(7):
	get_constant             a(1)     1.1 
	jmp                      p_float / 0 
label(8):
	retry_me_else            0     ref(10) 
label(9):
	get_constant             a(1)     5_2 
	jmp                      p_rational / 0 
label(10):
	retry_me_else            0     ref(12) 
label(11):
	get_constant             a(1)     0.9__1.1 
	jmp                      p_breal / 0 
label(12):
	retry_me_else            0     ref(14) 
label(13):
	get_string               a(1)     "hello" 
	jmp                      p_string / 0 
label(14):
	retry_me_else            0     ref(16) 
label(15):
	get_atom                 a(1)     hello 
	jmp                      p_atom / 0 
label(16):
	retry_me_else            0     ref(18) 
label(17):
	get_nil                  a(1) 
label(26):
	jmp                      p_nil / 0 
label(18):
	retry_me_else            0     ref(21) 
label(19):
	get_list                 a(1)     ref(20) 
	write_void               2 
label(20):
	jmp                      p_list / 0 
label(21):
	trust_me                 0 
label(22):
	get_structure            a(1)     foo / 1     ref(23) 
	write_atom               bar 
	jmp                      p_struct / 0 
label(23):
	read_atom                bar 
	jmp                      p_struct / 0 

------ Test idx(26) -------
p(A) :-
	(
	    var(A),
	    p_var
	;
	    (
		integer(A),
		p_integer
	    ;
		(
		    float(A),
		    p_float
		;
		    (
			rational(A),
			p_rational
		    ;
			(
			    breal(A),
			    p_breal
			;
			    (
				string(A),
				p_string
			    ;
				(
				    nonvar(A),
				    A = [],
				    !,
				    p_nil
				;
				    (
					atom(A),
					p_atom
				    ;
					(
					    nonvar(A),
					    A = [B|C],
					    !,
					    p_list
					;
					    (
						compound(A),
						p_struct
					    ;
						is_handle(A),
						p_handle
					    )
					)
				    )
				)
			    )
			)
		    )
		)
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [handle] - [11]
    [list] - [9]
    [[]] - [7]
    [structure] - [10]
    [atom] - [8]
    [var] - [1]
    [breal] - [5]
    [rational] - [4]
    [integer] - [2]
    [bignum] - [2]
    [string] - [6]
    [double] - [3]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
    Branch 4: det
    Branch 5: det
    Branch 6: det
    Branch 7: det
    Branch 8: det
    Branch 9: det
    Branch 10: det
    Branch 11: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(26)
		[]: 	ref(27)
		atom: 	ref(28)
		bignum: 	ref(29)
		breal: 	ref(30)
		double: 	ref(31)
		goal: 	ref(fail)
		handle: 	ref(32)
		integer: 	ref(29)
		list: 	ref(33)
		rational: 	ref(34)
		string: 	ref(35)
		structure: 	ref(36)

	branch                   ref(26) 
label(3):
	bi_var                   a(1) 
label(26):
	jmp                      p_var / 0 
label(5):
	bi_integer               a(1) 
label(29):
	jmp                      p_integer / 0 
label(7):
	bi_float                 a(1) 
label(31):
	jmp                      p_float / 0 
label(9):
	bi_rational              a(1) 
label(34):
	jmp                      p_rational / 0 
label(11):
	bi_breal                 a(1) 
label(30):
	jmp                      p_breal / 0 
label(13):
	bi_string                a(1) 
label(35):
	jmp                      p_string / 0 
label(15):
	bi_nonvar                a(1) 
label(27):
	get_nil                  a(1) 
	jmp                      p_nil / 0 
label(17):
	bi_atom                  a(1) 
label(28):
	jmp                      p_atom / 0 
label(19):
	bi_nonvar                a(1) 
label(33):
	get_list                 a(1)     ref(20) 
	write_void               2 
label(20):
	jmp                      p_list / 0 
label(22):
	bi_compound              a(1) 
label(36):
	jmp                      p_struct / 0 
label(24):
	bi_is_handle             a(1) 
label(32):
	jmp                      p_handle / 0 

------ Test idx(27) -------
p(A) :-
	(
	    atom(A),
	    p_string
	;
	    A = hello,
	    p_hello
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [1]
    [var] - [2]
    [atom] - [1]
    [atom, hello] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(5)
		[]: 	ref(8)
		atom: 	ref(7)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(5) 
label(2):
	try_me_else              0     1     ref(4) 
label(3):
	bi_atom                  a(1) 
label(8):
	jmp                      p_string / 0 
label(4):
	trust_me                 0 
label(5):
	get_atom                 a(1)     hello 
	jmp                      p_hello / 0 
label(7):
	atom_switch              a(1) 
		hello: 	ref(2)
		default: 	ref(3)


------ Test idx(28) -------
p(A) :-
	(
	    A = "abc",
	    p1
	;
	    (
		A = "def",
		p2
	    ;
		A = ghi,
		p3
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 2.0
    [] - []
    [atom] - []
    [atom, ghi] - [3]
    [var] - [1, 2, 3]
    [string] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(2)
		[]: 	ref(fail)
		atom: 	ref(7)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(9)
		structure: 	ref(fail)

label(2):
	try_me_else              0     1     ref(4) 
label(3):
	get_string               a(1)     "abc" 
	jmp                      p1 / 0 
label(4):
	retry_me_else            0     ref(6) 
label(5):
	get_string               a(1)     "def" 
	jmp                      p2 / 0 
label(6):
	trust_me                 0 
label(7):
	get_atom                 a(1)     ghi 
	jmp                      p3 / 0 
label(9):
	try                      0     1     ref(3) 
	trust                    0     ref(5) 

------ Test idx(29) -------
p(A) :-
	A = 1,
	p,
	q(A).
p(A) :-
	A = 2,
	q,
	r(A).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	integer_switch           a(1) 
		1: 	ref(7)
		2: 	ref(8)
		default: 	ref(fail)

label(2):
	try_me_else              0     1     ref(4) 
label(3):
	get_integer              a(1)     1 
label(7):
	get_variable             1     a(1)     y(1) 
	callf                    p / 0     Y[1] 
	move_chain               y(1)     a(1)     q / 1 
label(4):
	trust_me                 0 
label(5):
	get_integer              a(1)     2 
label(8):
	get_variable             1     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test idx(30) -------
p(A) :-
	(
	    A = 1,
	    !,
	    p1
	;
	    (
		A = 2,
		!,
		p2
	    ;
		p4
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [3]
    [var] - [1]
    [integer] - [3]
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	integer_switch           a(1) 
		1: 	ref(9)
		2: 	ref(10)
		default: 	ref(7)

label(3):
	get_integer              a(1)     1 
label(9):
	jmp                      p1 / 0 
label(5):
	get_integer              a(1)     2 
label(10):
	jmp                      p2 / 0 
label(7):
	jmp                      p4 / 0 

------ Test idx(31) -------
p(A) :-
	(
	    A = 1,
	    !,
	    p1
	;
	    (
		A = 2,
		!,
		p2
	    ;
		integer(A),
		p4
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [var] - [1]
    [bignum] - [3]
    [integer] - [3]
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(3)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(10)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(9)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

label(3):
	get_integer              a(1)     1 
label(11):
	jmp                      p1 / 0 
label(5):
	get_integer              a(1)     2 
label(12):
	jmp                      p2 / 0 
label(7):
	bi_integer               a(1) 
label(10):
	jmp                      p4 / 0 
label(9):
	integer_switch           a(1) 
		1: 	ref(11)
		2: 	ref(12)
		default: 	ref(7)


------ Test idx(32) -------
p(A) :-
	(
	    A = f(B),
	    !,
	    p1
	;
	    (
		A = g(C),
		!,
		p2
	    ;
		(
		    A = [D|E],
		    !,
		    p3
		;
		    compound(A),
		    p4
		)
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [list] - [3]
    [structure] - [4]
    [structure, f / 1] - [1]
    [structure, g / 1] - [2]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
    Branch 4: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(3)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(9)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(14)

label(3):
	get_structure            a(1)     f / 1     ref(4) 
	write_void           
label(4):
	jmp                      p1 / 0 
label(7):
	jmp                      p2 / 0 
label(9):
	get_list                 a(1)     ref(10) 
	write_void               2 
label(10):
	jmp                      p3 / 0 
label(12):
	bi_compound              a(1) 
	jmp                      p4 / 0 
label(14):
	functor_switch           a(1) 
		f / 1: 	ref(4)
		g / 1: 	ref(7)
		default: 	ref(12)


------ Test idx(33) -------
p(f(A, B, C)) :-
	!,
	p1(A, B, C).
p([A|B]) :-
	!,
	p2(A, B).
p(A) :-
	compound(A),
	p3.

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [list] - [2]
    [structure] - [3]
    [structure, f / 3] - [1]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(3)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(7)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(13)

label(3):
	get_structure            a(1)     f / 3     ref(4) 
	write_variable2          a(1)     a(2) 
	write_variable           a(3) 
	jmp                      p1 / 3 
label(4):
	read_variable2           a(1)     a(2) 
	read_variable            a(3) 
	jmp                      p1 / 3 
label(7):
	get_list                 a(1)     ref(8) 
	write_variable2          a(1)     a(2) 
	jmp                      p2 / 2 
label(8):
	read_variable2           a(1)     a(2) 
	jmp                      p2 / 2 
label(11):
	bi_compound              a(1) 
	jmp                      p3 / 0 
label(13):
	functor_switch           a(1) 
		f / 3: 	ref(4)
		default: 	ref(11)


------ Test idx(34) -------
p(f(A, B, A), C) :-
	!,
	p1(A, B, C).
p([A|B], B) :-
	!,
	p2(A, B).
p(A, B) :-
	compound(A),
	p3.

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - []
    [list] - [2, 3]
    [structure] - [3]
    [structure, f / 3] - [1, 3]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: try
    Branch 3: trust
p / 2:
label(1):
	savecut                  a(3) 
	switch_on_type           a(1) 
		meta: 	ref(3)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(13)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(15)

label(3):
	get_structure            a(1)     f / 3     ref(4) 
	write_variable           a(1) 
	shift                    a(4)     a(3)     a(2) 
	write_variable           a(2) 
	write_value              a(1) 
	cut                      a(4) 
	jmp                      p1 / 3 
label(4):
	read_variable            a(1) 
	shift                    a(4)     a(3)     a(2) 
	read_variable            a(2) 
	read_value               a(1) 
	cut                      a(4) 
	jmp                      p1 / 3 
label(7):
	get_list                 a(1)     ref(8) 
	write_variable           a(1) 
	write_value              a(2) 
	cut                      a(3) 
	jmp                      p2 / 2 
label(8):
	read_variable            a(1) 
	read_value               a(2) 
	cut                      a(3) 
	jmp                      p2 / 2 
label(11):
	bi_compound              a(1) 
	jmp                      p3 / 0 
label(13):
	try                      0     3     ref(7) 
	trust                    0     ref(11) 
label(14):
	try                      0     3     ref(3) 
	trust                    0     ref(11) 
label(15):
	functor_switch           a(1) 
		f / 3: 	ref(14)
		default: 	ref(11)


------ Test idx(35) -------
p(f(A, B, C)) :-
	-?->
	!,
	p1(A, B, C).
p([A|B]) :-
	-?->
	!,
	p2(A, B).
p(A) :-
	compound(A),
	p3.

INDEXES for (semidet) disjunction [2]
1. Quality 0.8
    [] - []
    [list] - [2]
    [structure] - [3]
    [structure, f / 3] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(6)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(11)

	branch                   ref(fail) 
label(4):
	read_variable2           a(1)     a(2) 
	read_variable            a(3) 
	jmp                      p1 / 3 
label(6):
	in_get_list              a(1)     ref(7) 
label(7):
	read_variable2           a(1)     a(2) 
	jmp                      p2 / 2 
label(9):
	bi_compound              a(1) 
	jmp                      p3 / 0 
label(11):
	functor_switch           a(1) 
		f / 3: 	ref(4)
		default: 	ref(9)


------ Test idx(36) -------
p(f(A, B, C), C) :-
	-?->
	!,
	p1(A, B, C).
p([A|B], B) :-
	-?->
	!,
	p2(A, B).
p(A, B) :-
	compound(A),
	p3.

INDEXES for (nondet) disjunction [2]
1. Quality 1.2
    [] - []
    [list] - [2, 3]
    [structure] - [3]
    [structure, f / 3] - [1, 3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: try
    Branch 3: trust
p / 2:
label(1):
	savecut                  a(3) 
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(11)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(13)

	branch                   ref(fail) 
label(3):
	in_get_structure         a(1)     f / 3     ref(4) 
label(4):
	read_variable            a(1) 
	shift                    a(4)     a(3)     a(2) 
	read_variable            a(2) 
	read_matched_value       a(3) 
	cut                      a(4) 
	jmp                      p1 / 3 
label(6):
	in_get_list              a(1)     ref(7) 
label(7):
	read_variable            a(1) 
	read_matched_value       a(2) 
	cut                      a(3) 
	jmp                      p2 / 2 
label(9):
	bi_compound              a(1) 
	jmp                      p3 / 0 
label(11):
	try                      0     3     ref(6) 
	trust                    0     ref(9) 
label(12):
	try                      0     3     ref(3) 
	trust                    0     ref(9) 
label(13):
	functor_switch           a(1) 
		f / 3: 	ref(12)
		default: 	ref(9)


------ Test idx(40) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    (
		meta(A),
		p2
	    ;
		p3
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.7
    [] - [3]
    [var] - [3]
    [var, free] - [1, 3]
    [var, meta] - [2, 3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: try
    Branch 3: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(10)
		[]: 	ref(7)
		atom: 	ref(7)
		bignum: 	ref(7)
		breal: 	ref(7)
		double: 	ref(7)
		goal: 	ref(7)
		handle: 	ref(7)
		integer: 	ref(7)
		list: 	ref(7)
		rational: 	ref(7)
		string: 	ref(7)
		structure: 	ref(7)

label(9):
	try                      0     1     ref(3) 
	trust                    0     ref(7) 
label(3):
	bi_free                  a(1) 
	jmp                      p1 / 0 
label(5):
	bi_meta                  a(1) 
	jmp                      p2 / 0 
label(7):
	jmp                      p3 / 0 
label(10):
	try                      0     1     ref(5) 
	trust                    0     ref(7) 

------ Test idx(41) -------
p(A) :-
	(
	    free(A),
	    !,
	    p1
	;
	    (
		meta(A),
		!,
		p2
	    ;
		p3
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [3]
    [var] - [3]
    [var, free] - [1]
    [var, meta] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(10)
		[]: 	ref(7)
		atom: 	ref(7)
		bignum: 	ref(7)
		breal: 	ref(7)
		double: 	ref(7)
		goal: 	ref(7)
		handle: 	ref(7)
		integer: 	ref(7)
		list: 	ref(7)
		rational: 	ref(7)
		string: 	ref(7)
		structure: 	ref(7)

	branch                   ref(9) 
label(3):
	bi_free                  a(1) 
label(9):
	jmp                      p1 / 0 
label(5):
	bi_meta                  a(1) 
label(10):
	jmp                      p2 / 0 
label(7):
	jmp                      p3 / 0 

------ Test idx(42) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    (
		meta(A),
		p2
	    ;
		atom(A),
		p3
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [[]] - [3]
    [atom] - [3]
    [var] - []
    [var, free] - [1]
    [var, meta] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(10)
		[]: 	ref(11)
		atom: 	ref(11)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(9) 
label(3):
	bi_free                  a(1) 
label(9):
	jmp                      p1 / 0 
label(5):
	bi_meta                  a(1) 
label(10):
	jmp                      p2 / 0 
label(7):
	bi_atom                  a(1) 
label(11):
	jmp                      p3 / 0 

------ Test idx(43) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    p2
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [2]
    [var, free] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(5)
		[]: 	ref(5)
		atom: 	ref(5)
		bignum: 	ref(5)
		breal: 	ref(5)
		double: 	ref(5)
		goal: 	ref(5)
		handle: 	ref(5)
		integer: 	ref(5)
		list: 	ref(5)
		rational: 	ref(5)
		string: 	ref(5)
		structure: 	ref(5)

label(2):
	try_me_else              0     1     ref(4) 
label(3):
	bi_free                  a(1) 
	jmp                      p1 / 0 
label(4):
	trust_me                 0 
label(5):
	jmp                      p2 / 0 

------ Test idx(44) -------
p(A) :-
	(
	    free(A),
	    !,
	    p1
	;
	    p2
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [2]
    [var] - [2]
    [var, free] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(5)
		[]: 	ref(5)
		atom: 	ref(5)
		bignum: 	ref(5)
		breal: 	ref(5)
		double: 	ref(5)
		goal: 	ref(5)
		handle: 	ref(5)
		integer: 	ref(5)
		list: 	ref(5)
		rational: 	ref(5)
		string: 	ref(5)
		structure: 	ref(5)

	branch                   ref(7) 
label(3):
	bi_free                  a(1) 
label(7):
	jmp                      p1 / 0 
label(5):
	jmp                      p2 / 0 

------ Test idx(45) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    p2
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [2]
    [var, free] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(5)
		[]: 	ref(5)
		atom: 	ref(5)
		bignum: 	ref(5)
		breal: 	ref(5)
		double: 	ref(5)
		goal: 	ref(5)
		handle: 	ref(5)
		integer: 	ref(5)
		list: 	ref(5)
		rational: 	ref(5)
		string: 	ref(5)
		structure: 	ref(5)

label(2):
	try_me_else              0     1     ref(4) 
label(3):
	bi_free                  a(1) 
	jmp                      p1 / 0 
label(4):
	trust_me                 0 
label(5):
	jmp                      p2 / 0 

------ Test idx(46) -------
p(A) :-
	(
	    meta(A),
	    p1
	;
	    p2
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [2]
    [var, meta] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(2)
		[]: 	ref(5)
		atom: 	ref(5)
		bignum: 	ref(5)
		breal: 	ref(5)
		double: 	ref(5)
		goal: 	ref(5)
		handle: 	ref(5)
		integer: 	ref(5)
		list: 	ref(5)
		rational: 	ref(5)
		string: 	ref(5)
		structure: 	ref(5)

	branch                   ref(5) 
label(2):
	try_me_else              0     1     ref(4) 
label(3):
	bi_meta                  a(1) 
	jmp                      p1 / 0 
label(4):
	trust_me                 0 
label(5):
	jmp                      p2 / 0 

------ Test idx(47) -------
p(A) :-
	(
	    meta(A),
	    !,
	    p1
	;
	    p2
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [2]
    [var] - [2]
    [var, meta] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(7)
		[]: 	ref(5)
		atom: 	ref(5)
		bignum: 	ref(5)
		breal: 	ref(5)
		double: 	ref(5)
		goal: 	ref(5)
		handle: 	ref(5)
		integer: 	ref(5)
		list: 	ref(5)
		rational: 	ref(5)
		string: 	ref(5)
		structure: 	ref(5)

label(5):
	jmp                      p2 / 0 
label(3):
	bi_meta                  a(1) 
label(7):
	jmp                      p1 / 0 

------ Test idx(48) -------
p(A) :-
	(
	    meta(A),
	    p1
	;
	    p2
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [2]
    [var, meta] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(2)
		[]: 	ref(5)
		atom: 	ref(5)
		bignum: 	ref(5)
		breal: 	ref(5)
		double: 	ref(5)
		goal: 	ref(5)
		handle: 	ref(5)
		integer: 	ref(5)
		list: 	ref(5)
		rational: 	ref(5)
		string: 	ref(5)
		structure: 	ref(5)

	branch                   ref(5) 
label(2):
	try_me_else              0     1     ref(4) 
label(3):
	bi_meta                  a(1) 
	jmp                      p1 / 0 
label(4):
	trust_me                 0 
label(5):
	jmp                      p2 / 0 

------ Test idx(49) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    (
		var(A),
		p2
	    ;
		p3
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 2.0
    [] - [3]
    [var] - [2, 3]
    [var, free] - [1, 2, 3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(9)
		[]: 	ref(7)
		atom: 	ref(7)
		bignum: 	ref(7)
		breal: 	ref(7)
		double: 	ref(7)
		goal: 	ref(7)
		handle: 	ref(7)
		integer: 	ref(7)
		list: 	ref(7)
		rational: 	ref(7)
		string: 	ref(7)
		structure: 	ref(7)

label(2):
	try_me_else              0     1     ref(4) 
label(3):
	bi_free                  a(1) 
	jmp                      p1 / 0 
label(4):
	retry_me_else            0     ref(6) 
label(5):
	bi_var                   a(1) 
	jmp                      p2 / 0 
label(6):
	trust_me                 0 
label(7):
	jmp                      p3 / 0 
label(9):
	try                      0     1     ref(5) 
	trust                    0     ref(7) 

------ Test idx(50) -------
p(A) :-
	(
	    free(A),
	    !,
	    p1
	;
	    (
		var(A),
		!,
		p2
	    ;
		p3
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [3]
    [var] - [2]
    [var, free] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(10)
		[]: 	ref(7)
		atom: 	ref(7)
		bignum: 	ref(7)
		breal: 	ref(7)
		double: 	ref(7)
		goal: 	ref(7)
		handle: 	ref(7)
		integer: 	ref(7)
		list: 	ref(7)
		rational: 	ref(7)
		string: 	ref(7)
		structure: 	ref(7)

	branch                   ref(9) 
label(3):
	bi_free                  a(1) 
label(9):
	jmp                      p1 / 0 
label(5):
	bi_var                   a(1) 
label(10):
	jmp                      p2 / 0 
label(7):
	jmp                      p3 / 0 

------ Test idx(51) -------
p(A) :-
	(
	    free(A),
	    p1
	;
	    (
		var(A),
		p2
	    ;
		atom(A),
		p3
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [3]
    [atom] - [3]
    [var] - [2]
    [var, free] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(10)
		[]: 	ref(11)
		atom: 	ref(11)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

label(9):
	try                      0     1     ref(3) 
	trust                    0     ref(5) 
label(3):
	bi_free                  a(1) 
	jmp                      p1 / 0 
label(5):
	bi_var                   a(1) 
label(10):
	jmp                      p2 / 0 
label(7):
	bi_atom                  a(1) 
label(11):
	jmp                      p3 / 0 

------ Test idx(52) -------
p(A) :-
	(
	    var(A),
	    !,
	    p1
	;
	    p2
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [2]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(7)
		[]: 	ref(5)
		atom: 	ref(5)
		bignum: 	ref(5)
		breal: 	ref(5)
		double: 	ref(5)
		goal: 	ref(5)
		handle: 	ref(5)
		integer: 	ref(5)
		list: 	ref(5)
		rational: 	ref(5)
		string: 	ref(5)
		structure: 	ref(5)

	branch                   ref(7) 
label(3):
	bi_var                   a(1) 
label(7):
	jmp                      p1 / 0 
label(5):
	jmp                      p2 / 0 

------ Test idx(53) -------
p(A) :-
	(
	    var(A),
	    !,
	    p1
	;
	    (
		A = 1,
		p2
	    ;
		A = 2,
		p3
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [var] - [1]
    [integer] - []
    [integer, 1] - [2]
    [integer, 2] - [3]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	integer_switch           a(1) 
		1: 	ref(9)
		2: 	ref(10)
		default: 	ref(fail)

label(3):
	bi_var                   a(1) 
	jmp                      p1 / 0 
label(5):
	get_integer              a(1)     1 
label(9):
	jmp                      p2 / 0 
label(7):
	get_integer              a(1)     2 
label(10):
	jmp                      p3 / 0 

------ Test idx(54) -------
p(A) :-
	(
	    var(A),
	    !,
	    p1
	;
	    (
		integer(A),
		A = 1,
		p2
	    ;
		integer(A),
		A = 2,
		p3
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [var] - [1]
    [integer] - []
    [integer, 1] - [2]
    [integer, 2] - [3]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	integer_switch           a(1) 
		1: 	ref(5)
		2: 	ref(7)
		default: 	ref(fail)

label(3):
	bi_var                   a(1) 
	jmp                      p1 / 0 
label(5):
	bi_integer               a(1) 
	get_integer              a(1)     1 
	jmp                      p2 / 0 
label(7):
	bi_integer               a(1) 
	get_integer              a(1)     2 
	jmp                      p3 / 0 

------ Test idx(55) -------
p(A) :-
	(
	    var(A),
	    !,
	    p1
	;
	    (
		A = 1,
		!,
		p2
	    ;
		integer(A),
		p3
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [var] - [1]
    [bignum] - [3]
    [integer] - [3]
    [integer, 1] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(10)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(11)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(9)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(10) 
label(3):
	bi_var                   a(1) 
label(10):
	jmp                      p1 / 0 
label(5):
	get_integer              a(1)     1 
label(12):
	jmp                      p2 / 0 
label(7):
	bi_integer               a(1) 
label(11):
	jmp                      p3 / 0 
label(9):
	integer_switch           a(1) 
		1: 	ref(12)
		default: 	ref(7)


------ Test idx(56) -------
p(A, B) :-
	(
	    integer(A),
	    B = a,
	    p1
	;
	    (
		integer(A),
		B = b,
		p2
	    ;
		(
		    integer(A),
		    B = c,
		    p3
		;
		    atom(A),
		    p4
		)
	    )
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [4]
    [atom] - [4]
    [integer] - [1, 2, 3]
    [bignum] - [1, 2, 3]
2. Quality 2.2
    [] - [4]
    [atom] - [4]
    [atom, a] - [1, 4]
    [atom, b] - [2, 4]
    [atom, c] - [3, 4]
    [var] - [1, 2, 3, 4]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: trust
    Branch 4: det
p / 2:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(16)
		atom: 	ref(16)
		bignum: 	ref(12)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(12)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(fail) 
label(4):
	bi_integer               a(1) 
	get_atom                 a(2)     a 
	jmp                      p1 / 0 
label(6):
	bi_integer               a(1) 
	get_atom                 a(2)     b 
	jmp                      p2 / 0 
label(8):
	bi_integer               a(1) 
	get_atom                 a(2)     c 
	jmp                      p3 / 0 
label(10):
	bi_atom                  a(1) 
label(16):
	jmp                      p4 / 0 
label(12):
	try                      0     2     ref(4) 
	retry                    0     ref(6) 
	trust                    0     ref(8) 

------ Test idx(60) -------
p(A) :-
	(
	    var(A),
	    p_var
	;
	    (
		(
		    integer(A)
		;
		    (
			float(A)
		    ;
			rational(A)
		    )
		),
		p_intfloatrat
	    ;
		(
		    breal(A),
		    p_breal
		;
		    (
			nonvar(A),
			A = [],
			!,
			p_nil
		    ;
			(
			    (
				string(A)
			    ->
				true
			    ;
				atom(A)
			    ),
			    p_atomstring
			;
			    (
				nonvar(A),
				A = [B|C],
				!,
				p_list
			    ;
				(
				    compound(A),
				    p_struct
				;
				    is_handle(A),
				    p_handle
				)
			    )
			)
		    )
		)
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [handle] - [8]
    [list] - [6]
    [[]] - [4]
    [structure] - [7]
    [atom] - [5]
    [var] - [1]
    [breal] - [3]
    [rational] - [2]
    [integer] - [2]
    [bignum] - [2]
    [string] - [5]
    [double] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
    Branch 4: det
    Branch 5: det
    Branch 6: det
    Branch 7: det
    Branch 8: det
INDEXES for (semidet) disjunction [2, 2, 2]
1. Quality 0.8
    [] - []
    [rational] - [3]
    [integer] - [1]
    [bignum] - [1]
    [double] - [2]
Branch determinisms for disjunction [2, 2, 2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
INDEXES for (semidet) disjunction [2, 5, 2]
1. Quality 0.7
    [] - []
    [[]] - [2]
    [atom] - [2]
    [string] - [1]
Branch determinisms for disjunction [2, 5, 2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(32)
		[]: 	ref(33)
		atom: 	ref(18)
		bignum: 	ref(5)
		breal: 	ref(34)
		double: 	ref(5)
		goal: 	ref(fail)
		handle: 	ref(35)
		integer: 	ref(5)
		list: 	ref(36)
		rational: 	ref(5)
		string: 	ref(18)
		structure: 	ref(37)

	branch                   ref(32) 
label(3):
	bi_var                   a(1) 
label(32):
	jmp                      p_var / 0 
label(5):
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(40)
		breal: 	ref(fail)
		double: 	ref(41)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(40)
		list: 	ref(fail)
		rational: 	ref(42)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(fail) 
label(7):
	bi_integer               a(1) 
label(40):
	jmp                      p_intfloatrat / 0 
label(9):
	bi_float                 a(1) 
label(41):
	jmp                      p_intfloatrat / 0 
label(11):
	bi_rational              a(1) 
label(42):
	jmp                      p_intfloatrat / 0 
label(14):
	bi_breal                 a(1) 
label(34):
	jmp                      p_breal / 0 
label(16):
	bi_nonvar                a(1) 
label(33):
	get_nil                  a(1) 
	jmp                      p_nil / 0 
label(18):
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(38)
		atom: 	ref(38)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(39)
		structure: 	ref(fail)

	branch                   ref(fail) 
label(20):
	bi_string                a(1) 
label(39):
	jmp                      p_atomstring / 0 
label(22):
	bi_atom                  a(1) 
label(38):
	jmp                      p_atomstring / 0 
label(25):
	bi_nonvar                a(1) 
label(36):
	get_list                 a(1)     ref(26) 
	write_void               2 
label(26):
	jmp                      p_list / 0 
label(28):
	bi_compound              a(1) 
label(37):
	jmp                      p_struct / 0 
label(30):
	bi_is_handle             a(1) 
label(35):
	jmp                      p_handle / 0 

------ Test idx(70) -------
p(f(A), A) :-
	atom(A).
p(g(A), A) :-
	atom(A).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [structure] - []
    [structure, f / 1] - [1]
    [structure, g / 1] - [2]
    [var] - [1, 2]
2. Quality 2.0
    [] - []
    [[]] - [1, 2]
    [var] - [1, 2]
    [atom] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 2:
label(1):
	functor_switch           a(1) 
		f / 1: 	ref(5)
		g / 1: 	ref(9)
		default: 	ref(fail)

label(3):
	try_me_else              0     2     ref(7) 
label(4):
	get_structure            a(1)     f / 1     ref(5) 
	write_value              a(2) 
	bi_atom                  a(2) 
	ret                  
label(5):
	read_value               a(2) 
	bi_atom                  a(2) 
	ret                  
label(7):
	trust_me                 0 
label(8):
	get_structure            a(1)     g / 1     ref(9) 
	write_value              a(2) 
	bi_atom                  a(2) 
	ret                  
label(9):
	read_value               a(2) 
	bi_atom                  a(2) 
	ret                  

------ Test idx(71) -------
p(A, B) :-
	A = B,
	atom(B).
p(A, B) :-
	A = B,
	integer(B).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [1]
    [var] - [1, 2]
    [atom] - [1]
    [integer] - [2]
    [bignum] - [2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 2:
label(1):
	switch_on_type           a(2) 
		meta: 	ref(2)
		[]: 	ref(3)
		atom: 	ref(3)
		bignum: 	ref(5)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(5)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

label(2):
	try_me_else              0     2     ref(4) 
label(3):
	get_value                a(1)     a(2) 
	bi_atom                  a(2) 
	ret                  
label(4):
	trust_me                 0 
label(5):
	get_value                a(1)     a(2) 
	bi_integer               a(2) 
	ret                  

------ Test idx(72) -------
p(A / B, A, B) :-
	atom(A),
	integer(B),
	B >= 0.
p(A // B, A, B) :-
	atom(A),
	integer(B),
	B >= 0.

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [structure] - []
    [structure, / / 2] - [1]
    [structure, // / 2] - [2]
    [var] - [1, 2]
2. Quality 2.0
    [] - []
    [[]] - [1, 2]
    [var] - [1, 2]
    [atom] - [1, 2]
3. Quality 2.0
    [] - []
    [var] - [1, 2]
    [integer] - [1, 2]
    [bignum] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 3:
label(1):
	functor_switch           a(1) 
		(/) / 2: 	ref(5)
		(//) / 2: 	ref(9)
		default: 	ref(fail)

label(3):
	try_me_else              0     3     ref(7) 
label(4):
	get_structure            a(1)     (/) / 2     ref(5) 
	write_value              a(2) 
	write_value              a(3) 
	branch                   ref(6) 
label(5):
	read_value               a(2) 
	read_value               a(3) 
label(6):
	bi_atom                  a(2) 
	bi_integer               a(3) 
	put_integer              a(1)     0 
	bi_ge                    a(3)     a(1)     eclipse     48 
	ret                  
label(7):
	trust_me                 0 
label(8):
	get_structure            a(1)     (//) / 2     ref(9) 
	write_value              a(2) 
	write_value              a(3) 
	branch                   ref(10) 
label(9):
	read_value               a(2) 
	read_value               a(3) 
label(10):
	bi_atom                  a(2) 
	bi_integer               a(3) 
	put_integer              a(1)     0 
	bi_ge                    a(3)     a(1)     eclipse     48 
	ret                  

------ Test idx(100) -------
p(1) :-
	-?->
	p_1.
p(2) :-
	-?->
	p_2.

INDEXES for (semidet) disjunction [2]
1. Quality 0.7
    [] - []
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	integer_switch           a(1) 
		1: 	ref(7)
		2: 	ref(8)
		default: 	ref(fail)

	branch                   ref(fail) 
label(3):
	in_get_integer           a(1)     1 
label(7):
	jmp                      p_1 / 0 
label(5):
	in_get_integer           a(1)     2 
label(8):
	jmp                      p_2 / 0 

------ Test idx(101) -------
p(1) :-
	-?->
	p_integer.
p(10000000000000000000) :-
	-?->
	p_big.
p(1.1) :-
	-?->
	p_float.
p(5_2) :-
	-?->
	p_rational.
p(0.9__1.1) :-
	-?->
	p_breal.
p("hello") :-
	-?->
	p_string.
p(hello) :-
	-?->
	p_atom.
p([]) :-
	-?->
	p_nil.
p([A|B]) :-
	-?->
	p_list.
p(foo(bar)) :-
	-?->
	p_struct.

INDEXES for (semidet) disjunction [2]
1. Quality 0.9
    [] - []
    [list] - [9]
    [[]] - [8]
    [structure] - []
    [structure, foo / 1] - [10]
    [atom] - []
    [atom, hello] - [7]
    [breal] - [5]
    [rational] - [4]
    [bignum] - [2]
    [integer] - []
    [integer, 1] - [1]
    [string] - [6]
    [double] - [3]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
    Branch 4: det
    Branch 5: det
    Branch 6: det
    Branch 7: det
    Branch 8: det
    Branch 9: det
    Branch 10: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(25)
		atom: 	ref(15)
		bignum: 	ref(5)
		breal: 	ref(11)
		double: 	ref(7)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(3)
		list: 	ref(19)
		rational: 	ref(9)
		string: 	ref(13)
		structure: 	ref(22)

	branch                   ref(fail) 
label(3):
	in_get_integer           a(1)     1 
	jmp                      p_integer / 0 
label(5):
	in_get_constant          a(1)     10000000000000000000 
	jmp                      p_big / 0 
label(7):
	in_get_constant          a(1)     1.1 
	jmp                      p_float / 0 
label(9):
	in_get_constant          a(1)     5_2 
	jmp                      p_rational / 0 
label(11):
	in_get_constant          a(1)     0.9__1.1 
	jmp                      p_breal / 0 
label(13):
	in_get_string            a(1)     "hello" 
	jmp                      p_string / 0 
label(15):
	in_get_atom              a(1)     hello 
	jmp                      p_atom / 0 
label(17):
	in_get_nil               a(1) 
label(25):
	jmp                      p_nil / 0 
label(19):
	in_get_list              a(1)     ref(20) 
label(20):
	jmp                      p_list / 0 
label(22):
	in_get_structure         a(1)     foo / 1     ref(23) 
label(23):
	read_test_var        
	read_atom                bar 
	jmp                      p_struct / 0 

------ Test idx(102) -------
p(a, 1).
p(b, 2).
p(c, 3).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
    [atom, c] - [3]
    [var] - [1, 2, 3]
2. Quality 1.5
    [] - []
    [var] - [1, 2, 3]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
    [integer, 3] - [3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: trust
p / 2:
label(1):
	atom_switch              a(1) 
		a: 	ref(10)
		b: 	ref(11)
		c: 	ref(12)
		default: 	ref(fail)

	integer_switch           a(2) 
		1: 	ref(4)
		2: 	ref(6)
		3: 	ref(8)
		default: 	ref(fail)

label(3):
	try_me_else              0     2     ref(5) 
label(4):
	get_atom                 a(1)     a 
label(10):
	get_integer              a(2)     1 
	ret                  
label(5):
	retry_me_else            0     ref(7) 
label(6):
	get_atom                 a(1)     b 
label(11):
	get_integer              a(2)     2 
	ret                  
label(7):
	trust_me                 0 
label(8):
	get_atom                 a(1)     c 
label(12):
	get_integer              a(2)     3 
	ret                  

------ Test idx(103) -------
p(1) :-
	-?->
	p_small1.
p(2) :-
	-?->
	p_small2.
p(10000000000) :-
	-?->
	p_medium1.
p(20000000000) :-
	-?->
	p_medium2.
p(10000000000000000000) :-
	-?->
	p_big1.
p(20000000000000000000) :-
	-?->
	p_big2.

INDEXES for (nondet) disjunction [2]
1. Quality 1.0
    [] - []
    [bignum] - [5, 6]
    [integer] - []
    [integer, 20000000000] - [4]
    [integer, 10000000000] - [3]
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
    Branch 4: det
    Branch 5: try
    Branch 6: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(15)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(16)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(fail) 
label(3):
	in_get_integer           a(1)     1 
label(19):
	jmp                      p_small1 / 0 
label(5):
	in_get_integer           a(1)     2 
label(20):
	jmp                      p_small2 / 0 
label(7):
	in_get_integer           a(1)     10000000000 
label(18):
	jmp                      p_medium1 / 0 
label(9):
	in_get_integer           a(1)     20000000000 
label(17):
	jmp                      p_medium2 / 0 
label(11):
	in_get_constant          a(1)     10000000000000000000 
	jmp                      p_big1 / 0 
label(13):
	in_get_constant          a(1)     20000000000000000000 
	jmp                      p_big2 / 0 
label(15):
	try                      0     1     ref(11) 
	trust                    0     ref(13) 
label(16):
	integer_switch           a(1) 
		20000000000: 	ref(17)
		10000000000: 	ref(18)
		1: 	ref(19)
		2: 	ref(20)
		default: 	ref(fail)


------ Test idx(200) -------
p(A, B, C) :-
	var(A),
	!,
	B = C.
p(a, A, B) :-
	!,
	a(A, B).
p(A, B, C) :-
	q(A, B, C).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [3]
    [atom] - [3]
    [atom, a] - [2]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 3:
label(1):
	atom_switch              a(1) 
		a: 	ref(9)
		default: 	ref(7)

label(3):
	bi_var                   a(1) 
	get_value                a(2)     a(3) 
	ret                  
label(5):
	get_atom                 a(1)     a 
label(9):
	shift                    a(1)     a(2)     a(3) 
	jmp                      a / 2 
label(7):
	jmp                      q / 3 

------ Test idx(201) -------
p(A, B) :-
	+(A, 1, C),
	(
	    p1(C, B)
	;
	    p2(A, B)
	).

p / 2:
label(1):
	bi_addi                  a(1)     1     a(3)     24 
	try_me_else              0     3     ref(3) 
label(2):
	move                     a(3)     a(1) 
	jmp                      p1 / 2 
label(3):
	trust_me                 0 
label(4):
	jmp                      p2 / 2 

------ Test idx(202) -------
p(A, B) :-
	true,
	+(A, 1, C),
	(
	    p1(C, B)
	;
	    p2(C, B)
	).

p / 2:
label(1):
	get_variable             2     a(1)     y(2) 
	move                     a(2)     y(1) 
	callf                    true / 0     Y[1,2] 
	move                     y(2)     a(2) 
	bi_addi                  a(2)     1     a(1)     24 
	try_me_else              0     1     ref(3) 
label(2):
	move_chain               y(1)     a(2)     p1 / 2 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	move_chain               y(1)     a(2)     p2 / 2 

------ Test idx(203) -------
p(A, B) :-
	true,
	+(A, 1, C),
	(
	    p1(C, B)
	;
	    p2(C, C, B)
	).

p / 2:
label(1):
	get_variable             2     a(1)     y(2) 
	move                     a(2)     y(1) 
	callf                    true / 0     Y[1,2] 
	move                     y(2)     a(2) 
	bi_addi                  a(2)     1     a(1)     24 
	try_me_else              0     1     ref(3) 
label(2):
	move_chain               y(1)     a(2)     p1 / 2 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	move                     a(1)     a(2) 
	move_chain               y(1)     a(3)     p2 / 3 

------ Test idx(204) -------
p(A, B) :-
	true,
	+(A, 1, C),
	integer(C),
	(
	    p1(C, B)
	;
	    p2(C, B)
	).

p / 2:
label(1):
	get_variable             2     a(1)     y(2) 
	move                     a(2)     y(1) 
	callf                    true / 0     Y[1,2] 
	move                     y(2)     a(2) 
	bi_addi                  a(2)     1     a(1)     24 
	bi_integer               a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	move_chain               y(1)     a(2)     p1 / 2 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	move_chain               y(1)     a(2)     p2 / 2 

------ Test idx(300) -------
p(A) :-
	(
	    A = 1,
	    p1
	;
	    A = 2,
	    p2
	),
	q(A).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	integer_switch           a(1) 
		1: 	ref(7)
		2: 	ref(8)
		default: 	ref(fail)

label(2):
	try_me_else              0     1     ref(4) 
label(3):
	get_integer              a(1)     1 
label(7):
	get_variable             1     a(1)     y(1) 
	callf                    p1 / 0     Y[1] 
	move_chain               y(1)     a(1)     q / 1 
label(4):
	trust_me                 0 
label(5):
	get_integer              a(1)     2 
label(8):
	get_variable             1     a(1)     y(1) 
	callf                    p2 / 0     Y[1] 
	move_chain               y(1)     a(1)     q / 1 

------ Test head(100) -------
p(a) :-
	q.

p / 1:
label(1):
	get_atom                 a(1)     a 
	jmp                      q / 0 

------ Test head(101) -------
p(a, A, 3) :-
	q.

p / 3:
label(1):
	get_atom                 a(1)     a 
	get_integer              a(3)     3 
	jmp                      q / 0 

------ Test head(102) -------
p(A, A) :-
	q.

p / 2:
label(1):
	get_value                a(2)     a(1) 
	jmp                      q / 0 

------ Test head(103) -------
p(a, A, B, 3.5, 5_2, "hello", A) :-
	q.

p / 7:
label(1):
	get_atom                 a(1)     a 
	get_constant             a(4)     3.5 
	get_constant             a(5)     5_2 
	get_string               a(6)     "hello" 
	get_value                a(7)     a(2) 
	jmp                      q / 0 

------ Test head(1) -------
p(f(1)) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 1     ref(2) 
	write_integer            1 
	jmp                      q / 0 
label(2):
	read_integer             1 
	jmp                      q / 0 

------ Test head(2) -------
p(f(1, 2)) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 2     ref(2) 
	write_integer2           1     2 
	jmp                      q / 0 
label(2):
	read_integer             1 
	read_integer             2 
	jmp                      q / 0 

------ Test head(3) -------
p(f(g(1))) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 1     ref(3) 
	write_structure          g / 1 
label(2):
	write_integer            1 
	jmp                      q / 0 
label(3):
	read_last_structure      g / 1     ref(2) 
	read_integer             1 
	jmp                      q / 0 

------ Test head(4) -------
p(f(g(1), h(2))) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 2     ref(4) 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	mode                     t(0)     ref(5) 
	write_structure          h / 1 
label(3):
	write_integer            2 
	space                    -1 
	jmp                      q / 0 
label(4):
	read_structure           g / 1     ref(2) 
	read_integer             1 
	mode                     t(0) 
label(5):
	read_last_structure      h / 1     ref(3) 
	read_integer             2 
	space                    -1 
	jmp                      q / 0 

------ Test head(5) -------
p(f(g(1), h(2), i(3))) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 3     ref(5) 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	write_next_structure     h / 1     t(0)     ref(6) 
label(3):
	write_integer            2 
	mode                     t(0)     ref(7) 
	write_structure          i / 1 
label(4):
	write_integer            3 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_structure           g / 1     ref(2) 
	read_integer             1 
label(6):
	read_next_structure      h / 1     t(0)     ref(3) 
	read_integer             2 
	mode                     t(0) 
label(7):
	read_last_structure      i / 1     ref(4) 
	read_integer             3 
	space                    -1 
	jmp                      q / 0 

------ Test head(6) -------
p(f(4, g(1), h(2), i(3))) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 4     ref(5) 
	write_integer            4 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	write_next_structure     h / 1     t(0)     ref(6) 
label(3):
	write_integer            2 
	mode                     t(0)     ref(7) 
	write_structure          i / 1 
label(4):
	write_integer            3 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_integer             4 
	read_structure           g / 1     ref(2) 
	read_integer             1 
label(6):
	read_next_structure      h / 1     t(0)     ref(3) 
	read_integer             2 
	mode                     t(0) 
label(7):
	read_last_structure      i / 1     ref(4) 
	read_integer             3 
	space                    -1 
	jmp                      q / 0 

------ Test head(7) -------
p(f(4, g(1), 5, h(2), i(3))) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 5     ref(5) 
	write_integer            4 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	mode                     t(0)     ref(6) 
	write_integer            5 
	write_next_structure     h / 1     t(0) 
label(3):
	write_integer            2 
	mode                     t(0)     ref(7) 
	write_structure          i / 1 
label(4):
	write_integer            3 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_integer             4 
	read_structure           g / 1     ref(2) 
	read_integer             1 
	mode                     t(0) 
label(6):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(3) 
	read_integer             2 
	mode                     t(0) 
label(7):
	read_last_structure      i / 1     ref(4) 
	read_integer             3 
	space                    -1 
	jmp                      q / 0 

------ Test head(8) -------
p(f(4, g(1), 5, h(2), 6, i(3))) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 6     ref(5) 
	write_integer            4 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	mode                     t(0)     ref(6) 
	write_integer            5 
	write_next_structure     h / 1     t(0) 
label(3):
	write_integer            2 
	mode                     t(0)     ref(7) 
	write_integer            6 
	write_structure          i / 1 
label(4):
	write_integer            3 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_integer             4 
	read_structure           g / 1     ref(2) 
	read_integer             1 
	mode                     t(0) 
label(6):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(3) 
	read_integer             2 
	mode                     t(0) 
label(7):
	read_integer             6 
	read_last_structure      i / 1     ref(4) 
	read_integer             3 
	space                    -1 
	jmp                      q / 0 

------ Test head(9) -------
p(f(4, g(1), 5, h(2), 6, i(3), 7)) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 7     ref(5) 
	write_integer            4 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	mode                     t(0)     ref(6) 
	write_integer            5 
	write_next_structure     h / 1     t(0) 
label(3):
	write_integer            2 
	mode                     t(0)     ref(7) 
	write_integer            6 
	write_next_structure     i / 1     t(0) 
label(4):
	write_integer            3 
	mode                     t(0)     ref(8) 
	write_integer            7 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_integer             4 
	read_structure           g / 1     ref(2) 
	read_integer             1 
	mode                     t(0) 
label(6):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(3) 
	read_integer             2 
	mode                     t(0) 
label(7):
	read_integer             6 
	read_structure           i / 1     t(0)     ref(4) 
	read_integer             3 
	mode                     t(0) 
label(8):
	read_integer             7 
	space                    -1 
	jmp                      q / 0 

------ Test head(10) -------
p(f(4, g(1), 5, h(2), 6, i(3), 7)) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 7     ref(5) 
	write_integer            4 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	mode                     t(0)     ref(6) 
	write_integer            5 
	write_next_structure     h / 1     t(0) 
label(3):
	write_integer            2 
	mode                     t(0)     ref(7) 
	write_integer            6 
	write_next_structure     i / 1     t(0) 
label(4):
	write_integer            3 
	mode                     t(0)     ref(8) 
	write_integer            7 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_integer             4 
	read_structure           g / 1     ref(2) 
	read_integer             1 
	mode                     t(0) 
label(6):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(3) 
	read_integer             2 
	mode                     t(0) 
label(7):
	read_integer             6 
	read_structure           i / 1     t(0)     ref(4) 
	read_integer             3 
	mode                     t(0) 
label(8):
	read_integer             7 
	space                    -1 
	jmp                      q / 0 

------ Test head(11) -------
p(f(4, g(1), 5, h(2), 6, i(3), 7, 8)) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 8     ref(5) 
	write_integer            4 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	mode                     t(0)     ref(6) 
	write_integer            5 
	write_next_structure     h / 1     t(0) 
label(3):
	write_integer            2 
	mode                     t(0)     ref(7) 
	write_integer            6 
	write_next_structure     i / 1     t(0) 
label(4):
	write_integer            3 
	mode                     t(0)     ref(8) 
	write_integer2           7     8 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_integer             4 
	read_structure           g / 1     ref(2) 
	read_integer             1 
	mode                     t(0) 
label(6):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(3) 
	read_integer             2 
	mode                     t(0) 
label(7):
	read_integer             6 
	read_structure           i / 1     t(0)     ref(4) 
	read_integer             3 
	mode                     t(0) 
label(8):
	read_integer             7 
	read_integer             8 
	space                    -1 
	jmp                      q / 0 

------ Test head(12) -------
p(f(g(1), 5, h(2), 6, i(3), 7, 8)) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 7     ref(5) 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	mode                     t(0)     ref(6) 
	write_integer            5 
	write_next_structure     h / 1     t(0) 
label(3):
	write_integer            2 
	mode                     t(0)     ref(7) 
	write_integer            6 
	write_next_structure     i / 1     t(0) 
label(4):
	write_integer            3 
	mode                     t(0)     ref(8) 
	write_integer2           7     8 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_structure           g / 1     ref(2) 
	read_integer             1 
	mode                     t(0) 
label(6):
	read_integer             5 
	read_structure           h / 1     t(0)     ref(3) 
	read_integer             2 
	mode                     t(0) 
label(7):
	read_integer             6 
	read_structure           i / 1     t(0)     ref(4) 
	read_integer             3 
	mode                     t(0) 
label(8):
	read_integer             7 
	read_integer             8 
	space                    -1 
	jmp                      q / 0 

------ Test head(13) -------
p(f(g(1), h(2), 6, i(3), 7, 8)) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 6     ref(5) 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	write_next_structure     h / 1     t(0)     ref(6) 
label(3):
	write_integer            2 
	mode                     t(0)     ref(7) 
	write_integer            6 
	write_next_structure     i / 1     t(0) 
label(4):
	write_integer            3 
	mode                     t(0)     ref(8) 
	write_integer2           7     8 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_structure           g / 1     ref(2) 
	read_integer             1 
label(6):
	read_next_structure      h / 1     t(0)     ref(3) 
	read_integer             2 
	mode                     t(0) 
label(7):
	read_integer             6 
	read_structure           i / 1     t(0)     ref(4) 
	read_integer             3 
	mode                     t(0) 
label(8):
	read_integer             7 
	read_integer             8 
	space                    -1 
	jmp                      q / 0 

------ Test head(14) -------
p(f(g(1), h(2), i(3), 7, 8)) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 5     ref(5) 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	write_next_structure     h / 1     t(0)     ref(6) 
label(3):
	write_integer            2 
	write_next_structure     i / 1     t(0)     ref(7) 
label(4):
	write_integer            3 
	mode                     t(0)     ref(8) 
	write_integer2           7     8 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_structure           g / 1     ref(2) 
	read_integer             1 
label(6):
	read_next_structure      h / 1     t(0)     ref(3) 
	read_integer             2 
label(7):
	read_next_structure      i / 1     t(0)     ref(4) 
	read_integer             3 
	mode                     t(0) 
label(8):
	read_integer             7 
	read_integer             8 
	space                    -1 
	jmp                      q / 0 

------ Test head(15) -------
p(f(g(1), h(2), i(3), 8)) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 4     ref(5) 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	write_next_structure     h / 1     t(0)     ref(6) 
label(3):
	write_integer            2 
	write_next_structure     i / 1     t(0)     ref(7) 
label(4):
	write_integer            3 
	mode                     t(0)     ref(8) 
	write_integer            8 
	space                    -1 
	jmp                      q / 0 
label(5):
	read_structure           g / 1     ref(2) 
	read_integer             1 
label(6):
	read_next_structure      h / 1     t(0)     ref(3) 
	read_integer             2 
label(7):
	read_next_structure      i / 1     t(0)     ref(4) 
	read_integer             3 
	mode                     t(0) 
label(8):
	read_integer             8 
	space                    -1 
	jmp                      q / 0 

------ Test head(16) -------
p(A, B) :-
	A = f(B, C),
	q(A, C).

p / 2:
label(1):
	get_structure            a(1)     f / 2     ref(2) 
	write_value              a(2) 
	write_variable           a(2) 
	jmp                      q / 2 
label(2):
	read_value               a(2) 
	read_variable            a(2) 
	jmp                      q / 2 

------ Test head(17) -------
p(A, B) :-
	A = f(C, B),
	q(A, C).

p / 2:
label(1):
	get_structure            a(1)     f / 2     ref(2) 
	move                     a(2)     a(3) 
	write_variable           a(2) 
	write_value              a(3) 
	jmp                      q / 2 
label(2):
	move                     a(2)     a(3) 
	read_variable            a(2) 
	read_value               a(3) 
	jmp                      q / 2 

------ Test head(18) -------
p(A, B) :-
	A = f(g(B), C),
	q(A, C).

p / 2:
label(1):
	get_structure            a(1)     f / 2     ref(3) 
	write_first_structure     g / 1 
label(2):
	write_value              a(2) 
	mode                     t(0)     ref(4) 
	write_variable           a(2) 
	space                    -1 
	jmp                      q / 2 
label(3):
	read_structure           g / 1     ref(2) 
	read_value               a(2) 
	mode                     t(0) 
label(4):
	read_variable            a(2) 
	space                    -1 
	jmp                      q / 2 

------ Test head(19) -------
p(f(A)) :-
	q,
	r(A).

p / 1:
label(1):
	allocate                 1 
	get_structure            a(1)     f / 1     ref(2) 
	write_variable           y(1) 
	branch                   ref(3) 
label(2):
	read_variable            y(1) 
label(3):
	callf                    q / 0     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test head(20) -------
p(f(A, A)) :-
	q,
	r(A).

p / 1:
label(1):
	allocate                 1 
	get_structure            a(1)     f / 2     ref(2) 
	write_variable           y(1) 
	write_value              y(1) 
	branch                   ref(3) 
label(2):
	read_variable            y(1) 
	read_value               y(1) 
label(3):
	callf                    q / 0     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test head(20) -------
p([g(1), h(2)]) :-
	q.

p / 1:
label(1):
	get_list                 a(1)     ref(5) 
	write_first_structure     g / 1 
label(2):
	write_integer            1 
	mode                     t(0)     ref(6) 
	write_list           
label(3):
	write_first_structure     h / 1 
label(4):
	write_integer            2 
	mode                     t(0)     ref(7) 
	write_nil            
	space                    -2 
	jmp                      q / 0 
label(5):
	read_structure           g / 1     ref(2) 
	read_integer             1 
	mode                     t(0) 
label(6):
	read_last_list           ref(3) 
	read_structure           h / 1     ref(4) 
	read_integer             2 
	mode                     t(0) 
label(7):
	read_nil             
	space                    -2 
	jmp                      q / 0 

------ Test head(21) -------
p([[1, 2], [3|A], [4, 5], c]) :-
	q(A).

p / 1:
label(1):
	get_list                 a(1)     ref(10) 
	write_first_list     
label(2):
	write_integer            1 
	write_list           
label(3):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(11) 
	write_list           
label(4):
	write_first_list     
label(5):
	write_integer            3 
	write_variable           a(1) 
	mode                     t(0)     ref(12) 
	write_list           
label(6):
	write_first_list     
label(7):
	write_integer            4 
	write_list           
label(8):
	write_integer            5 
	write_nil            
	mode                     t(0)     ref(13) 
	write_list           
label(9):
	write_atom               c 
	write_nil            
	space                    -3 
	jmp                      q / 1 
label(10):
	read_list                ref(2) 
	read_integer             1 
	read_last_list           ref(3) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(11):
	read_last_list           ref(4) 
	read_list                ref(5) 
	read_integer             3 
	read_variable            a(1) 
	mode                     t(0) 
label(12):
	read_last_list           ref(6) 
	read_list                ref(7) 
	read_integer             4 
	read_last_list           ref(8) 
	read_integer             5 
	read_nil             
	mode                     t(0) 
label(13):
	read_last_list           ref(9) 
	read_atom                c 
	read_nil             
	space                    -3 
	jmp                      q / 1 

------ Test head(22) -------
p([a, [1, 2], [3, 4], b, [5|A], c]) :-
	q(A).

p / 1:
label(1):
	get_list                 a(1)     ref(12) 
	write_atom               a 
	write_list           
label(2):
	write_first_list     
label(3):
	write_integer            1 
	write_list           
label(4):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(13) 
	write_list           
label(5):
	write_first_list     
label(6):
	write_integer            3 
	write_list           
label(7):
	write_integer            4 
	write_nil            
	mode                     t(0)     ref(14) 
	write_list           
label(8):
	write_atom               b 
	write_list           
label(9):
	write_first_list     
label(10):
	write_integer            5 
	write_variable           a(1) 
	mode                     t(0)     ref(15) 
	write_list           
label(11):
	write_atom               c 
	write_nil            
	space                    -3 
	jmp                      q / 1 
label(12):
	read_atom                a 
	read_last_list           ref(2) 
	read_list                ref(3) 
	read_integer             1 
	read_last_list           ref(4) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(13):
	read_last_list           ref(5) 
	read_list                ref(6) 
	read_integer             3 
	read_last_list           ref(7) 
	read_integer             4 
	read_nil             
	mode                     t(0) 
label(14):
	read_last_list           ref(8) 
	read_atom                b 
	read_last_list           ref(9) 
	read_list                ref(10) 
	read_integer             5 
	read_variable            a(1) 
	mode                     t(0) 
label(15):
	read_last_list           ref(11) 
	read_atom                c 
	read_nil             
	space                    -3 
	jmp                      q / 1 

------ Test head(23) -------
p([a, [1, 2], [3, 4], b, [5|A]|c]) :-
	q(A).

p / 1:
label(1):
	get_list                 a(1)     ref(11) 
	write_atom               a 
	write_list           
label(2):
	write_first_list     
label(3):
	write_integer            1 
	write_list           
label(4):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(12) 
	write_list           
label(5):
	write_first_list     
label(6):
	write_integer            3 
	write_list           
label(7):
	write_integer            4 
	write_nil            
	mode                     t(0)     ref(13) 
	write_list           
label(8):
	write_atom               b 
	write_list           
label(9):
	write_first_list     
label(10):
	write_integer            5 
	write_variable           a(1) 
	mode                     t(0)     ref(14) 
	write_atom               c 
	space                    -3 
	jmp                      q / 1 
label(11):
	read_atom                a 
	read_last_list           ref(2) 
	read_list                ref(3) 
	read_integer             1 
	read_last_list           ref(4) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(12):
	read_last_list           ref(5) 
	read_list                ref(6) 
	read_integer             3 
	read_last_list           ref(7) 
	read_integer             4 
	read_nil             
	mode                     t(0) 
label(13):
	read_last_list           ref(8) 
	read_atom                b 
	read_last_list           ref(9) 
	read_list                ref(10) 
	read_integer             5 
	read_variable            a(1) 
	mode                     t(0) 
label(14):
	read_atom                c 
	space                    -3 
	jmp                      q / 1 

------ Test head(24) -------
p([a, [1, 2], [3, 4], b, [5|A]]) :-
	q(A).

p / 1:
label(1):
	get_list                 a(1)     ref(11) 
	write_atom               a 
	write_list           
label(2):
	write_first_list     
label(3):
	write_integer            1 
	write_list           
label(4):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(12) 
	write_list           
label(5):
	write_first_list     
label(6):
	write_integer            3 
	write_list           
label(7):
	write_integer            4 
	write_nil            
	mode                     t(0)     ref(13) 
	write_list           
label(8):
	write_atom               b 
	write_list           
label(9):
	write_first_list     
label(10):
	write_integer            5 
	write_variable           a(1) 
	mode                     t(0)     ref(14) 
	write_nil            
	space                    -3 
	jmp                      q / 1 
label(11):
	read_atom                a 
	read_last_list           ref(2) 
	read_list                ref(3) 
	read_integer             1 
	read_last_list           ref(4) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(12):
	read_last_list           ref(5) 
	read_list                ref(6) 
	read_integer             3 
	read_last_list           ref(7) 
	read_integer             4 
	read_nil             
	mode                     t(0) 
label(13):
	read_last_list           ref(8) 
	read_atom                b 
	read_last_list           ref(9) 
	read_list                ref(10) 
	read_integer             5 
	read_variable            a(1) 
	mode                     t(0) 
label(14):
	read_nil             
	space                    -3 
	jmp                      q / 1 

------ Test head(30) -------
p(f([1, 2], [3|A], c)) :-
	q(A).

p / 1:
label(1):
	get_structure            a(1)     f / 3     ref(5) 
	write_first_list     
label(2):
	write_integer            1 
	write_list           
label(3):
	write_integer            2 
	write_nil            
	write_next_list          t(0)     ref(6) 
label(4):
	write_integer            3 
	write_variable           a(1) 
	mode                     t(0)     ref(7) 
	write_atom               c 
	space                    -1 
	jmp                      q / 1 
label(5):
	read_list                ref(2) 
	read_integer             1 
	read_last_list           ref(3) 
	read_integer             2 
	read_nil             
label(6):
	read_next_list           t(0)     ref(4) 
	read_integer             3 
	read_variable            a(1) 
	mode                     t(0) 
label(7):
	read_atom                c 
	space                    -1 
	jmp                      q / 1 

------ Test head(31) -------
p(f(a, [1, 2], b, [3|A], c)) :-
	q(A).

p / 1:
label(1):
	get_structure            a(1)     f / 5     ref(5) 
	write_atom               a 
	write_first_list     
label(2):
	write_integer            1 
	write_list           
label(3):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(6) 
	write_atom               b 
	write_next_list          t(0) 
label(4):
	write_integer            3 
	write_variable           a(1) 
	mode                     t(0)     ref(7) 
	write_atom               c 
	space                    -1 
	jmp                      q / 1 
label(5):
	read_atom                a 
	read_list                ref(2) 
	read_integer             1 
	read_last_list           ref(3) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(6):
	read_atom                b 
	read_list                t(0)     ref(4) 
	read_integer             3 
	read_variable            a(1) 
	mode                     t(0) 
label(7):
	read_atom                c 
	space                    -1 
	jmp                      q / 1 

------ Test head(32) -------
p(f(a, [1, 2], [3|A], c)) :-
	q(A).

p / 1:
label(1):
	get_structure            a(1)     f / 4     ref(5) 
	write_atom               a 
	write_first_list     
label(2):
	write_integer            1 
	write_list           
label(3):
	write_integer            2 
	write_nil            
	write_next_list          t(0)     ref(6) 
label(4):
	write_integer            3 
	write_variable           a(1) 
	mode                     t(0)     ref(7) 
	write_atom               c 
	space                    -1 
	jmp                      q / 1 
label(5):
	read_atom                a 
	read_list                ref(2) 
	read_integer             1 
	read_last_list           ref(3) 
	read_integer             2 
	read_nil             
label(6):
	read_next_list           t(0)     ref(4) 
	read_integer             3 
	read_variable            a(1) 
	mode                     t(0) 
label(7):
	read_atom                c 
	space                    -1 
	jmp                      q / 1 

------ Test head(33) -------
p(f(a, [1, 2], b, [3|A])) :-
	q(A).

p / 1:
label(1):
	get_structure            a(1)     f / 4     ref(5) 
	write_atom               a 
	write_first_list     
label(2):
	write_integer            1 
	write_list           
label(3):
	write_integer            2 
	write_nil            
	mode                     t(0)     ref(6) 
	write_atom               b 
	write_list           
label(4):
	write_integer            3 
	write_variable           a(1) 
	space                    -1 
	jmp                      q / 1 
label(5):
	read_atom                a 
	read_list                ref(2) 
	read_integer             1 
	read_last_list           ref(3) 
	read_integer             2 
	read_nil             
	mode                     t(0) 
label(6):
	read_atom                b 
	read_last_list           ref(4) 
	read_integer             3 
	read_variable            a(1) 
	space                    -1 
	jmp                      q / 1 

------ Test head(34) -------
p(f("hello", 3.5, 5_3)) :-
	q.

p / 1:
label(1):
	get_structure            a(1)     f / 3     ref(2) 
	write_string             "hello" 
	write_constant           3.5 
	write_constant           5_3 
	jmp                      q / 0 
label(2):
	read_string              "hello" 
	read_constant            3.5 
	read_constant            5_3 
	jmp                      q / 0 

------ Test head(40) -------
p([A, B, C, D, E]).

p / 1:
label(1):
	get_list                 a(1)     ref(6) 
	write_void           
	write_list           
label(2):
	write_void           
	write_list           
label(3):
	write_void           
	write_list           
label(4):
	write_void           
	write_list           
label(5):
	write_void           
	write_nil            
	ret                  
label(6):
	read_void            
	read_last_list           ref(2) 
	read_void            
	read_last_list           ref(3) 
	read_void            
	read_last_list           ref(4) 
	read_void            
	read_last_list           ref(5) 
	read_void            
	read_nil             
	ret                  

------ Test head(41) -------
p(f(A, B, C, D, E)).

p / 1:
label(1):
	get_structure            a(1)     f / 5     ref(2) 
	write_void               5 
label(2):
	ret                  

------ Test head(42) -------
p(f(A, s(B, C), D, E)).

p / 1:
label(1):
	get_structure            a(1)     f / 4     ref(3) 
	write_void           
	write_first_structure     s / 2 
label(2):
	write_void               2 
	mode                     t(0)     ref(4) 
	write_void               2 
	space                    -1 
	ret                  
label(3):
	read_void            
	read_structure           s / 2     ref(2) 
	mode                     t(0) 
	space                    -1 
	ret                  
label(4):
	space                    -1 
	ret                  

------ Test match(1) -------
p(1, 2.3, 3_4, a, "s", []) ?-
	true.

p / 6:
label(1):
	in_get_integer           a(1)     1 
	in_get_constant          a(2)     2.3 
	in_get_constant          a(3)     3_4 
	in_get_atom              a(4)     a 
	in_get_string            a(5)     "s" 
	in_get_nil               a(6) 
	ret                  

------ Test match(2) -------
p(A, B, C, D, D) ?-
	q(A),
	r(B).

p / 5:
label(1):
	get_matched_value        a(5)     a(4) 
	get_variable             1     a(2)     y(1) 
	callf                    q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test match(3) -------
p(A, A, B, B) ?-
	q(A),
	r(B).

p / 4:
label(1):
	get_matched_value        a(2)     a(1) 
	get_matched_value        a(4)     a(3) 
	get_variable             1     a(3)     y(1) 
	callf                    q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test match(4) -------
p(foo(bar(1), A, baz(2))) ?-
	true.

p / 1:
label(1):
	in_get_structure         a(1)     foo / 3     ref(2) 
label(2):
	read_structure           bar / 1     ref(fail) 
	read_test_var        
	read_integer             1 
	mode                     t(0) 
label(3):
	read_void            
	read_last_structure      baz / 1     ref(fail) 
	read_test_var        
	read_integer             2 
	space                    -1 
	ret                  

------ Test match(5) -------
p([1, 2, [3, 4]]) ?-
	true.

p / 1:
label(1):
	in_get_list              a(1)     ref(2) 
label(2):
	read_test_var        
	read_integer             1 
	read_last_list           ref(fail) 
	read_test_var        
	read_integer             2 
	read_last_list           ref(fail) 
	read_list                ref(fail) 
	read_test_var        
	read_integer             3 
	read_last_list           ref(fail) 
	read_test_var        
	read_integer             4 
	read_test_var        
	read_nil             
	mode                     t(0) 
label(3):
	read_test_var        
	read_nil             
	space                    -1 
	ret                  

------ Test match(6) -------
p(foo(A, A)) ?-
	true.

p / 1:
label(1):
	in_get_structure         a(1)     foo / 2     ref(2) 
label(2):
	read_variable            a(1) 
	read_matched_value       a(1) 
	ret                  

------ Test match(7) -------
p(foo(A, A, B, B)) ?-
	q(A),
	r(B).

p / 1:
label(1):
	allocate                 1 
	in_get_structure         a(1)     foo / 4     ref(2) 
label(2):
	read_variable            a(1) 
	read_matched_value       a(1) 
	read_variable            y(1) 
	read_matched_value       y(1) 
	callf                    q / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test match(8) -------
p(A, foo(A, B), B) ?-
	true.

p / 3:
label(1):
	in_get_structure         a(2)     foo / 2     ref(2) 
label(2):
	read_matched_value       a(1) 
	read_matched_value       a(3) 
	ret                  

------ Test match(9) -------
p(A, foo(A, B), B) ?-
	p(A),
	r(B).

p / 3:
label(1):
	in_get_structure         a(2)     foo / 2     ref(2) 
label(2):
	read_matched_value       a(1) 
	read_matched_value       a(3) 
	get_variable             1     a(3)     y(1) 
	callf                    p / 1     Y[1] 
	move_chain               y(1)     a(1)     r / 1 

------ Test match(10) -------
p(A) ?-
	p(A, B).

p / 1:
label(1):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	jmp                      p / 2 

------ Test match(11) -------
p(A) ?-
	p(a, A, B).

p / 1:
label(1):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(3) 
	move                     a(1)     a(2) 
	put_atom                 a(1)     a 
	jmp                      p / 3 

------ Test match(12) -------
p(A, A) ?-
	p(a, b, A, B).

p / 2:
label(1):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(4) 
	get_matched_value        a(2)     a(1) 
	move                     a(1)     a(3) 
	put_atom                 a(1)     a 
	put_atom                 a(2)     b 
	jmp                      p / 4 

------ Test match(13) -------
p(A) ?-
	q,
	p(A, B).

p / 1:
label(1):
	allocate                 2 
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            y(2) 
	move                     a(1)     y(1) 
	callf                    q / 0     Y[1,2] 
	move                     2     y(1)     a(1) 
	chain                    p / 2 

------ Test match(14) -------
p(A, A) ?-
	q,
	p(A, B).

p / 2:
label(1):
	allocate                 2 
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            y(2) 
	get_matched_value        a(2)     a(1) 
	move                     a(1)     y(1) 
	callf                    q / 0     Y[1,2] 
	move                     2     y(1)     a(1) 
	chain                    ref(1) 

------ Test match(20) -------
p(f(A)) ?-
	p(A, B).

p / 1:
label(1):
	in_get_structure         a(1)     f / 1     ref(2) 
label(2):
	match_last_meta      
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	jmp                      p / 2 

------ Test match(21) -------
p(f(a, A)) ?-
	p(A, B).

p / 1:
label(1):
	in_get_structure         a(1)     f / 2     ref(2) 
label(2):
	read_test_var        
	read_atom                a 
	match_last_meta      
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	jmp                      p / 2 

------ Test match(22) -------
p(f(a, A, c)) ?-
	p(A, B).

p / 1:
label(1):
	in_get_structure         a(1)     f / 3     ref(2) 
label(2):
	read_test_var        
	read_atom                a 
	match_meta           
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	mode                     t(0) 
label(3):
	read_test_var        
	read_atom                c 
	space                    -1 
	jmp                      p / 2 

------ Test match(23) -------
p(f(bar(baz), A, c)) ?-
	p(A, B).

p / 1:
label(1):
	in_get_structure         a(1)     f / 3     ref(2) 
label(2):
	read_structure           bar / 1     ref(fail) 
	read_test_var        
	read_atom                baz 
	match_next_meta          t(0) 
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	mode                     t(0) 
label(3):
	read_test_var        
	read_atom                c 
	space                    -1 
	jmp                      p / 2 

------ Test match(24) -------
p(f(A, A)) ?-
	p(A, B).

p / 1:
label(1):
	in_get_structure         a(1)     f / 2     ref(2) 
label(2):
	match_meta           
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	mode                     t(0) 
label(3):
	match_last_meta      
	read_matched_value       a(1) 
	read_attribute           suspend 
	read_matched_value       a(2) 
	space                    -1 
	jmp                      p / 2 

------ Test match(25) -------
p(f(bar(baz), a, A, c)) ?-
	p(A, B).

p / 1:
label(1):
	in_get_structure         a(1)     f / 4     ref(2) 
label(2):
	read_structure           bar / 1     ref(fail) 
	read_test_var        
	read_atom                baz 
	mode                     t(0) 
label(3):
	read_test_var        
	read_atom                a 
	match_meta               t(0) 
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
	mode                     t(0) 
label(4):
	read_test_var        
	read_atom                c 
	space                    -1 
	jmp                      p / 2 

------ Test match(26) -------
p(f(A, bar(baz), c)) ?-
	p(A, B).

p / 1:
label(1):
	in_get_structure         a(1)     f / 3     ref(2) 
label(2):
	match_meta           
	read_variable            a(1) 
	read_attribute           suspend 
	read_variable            a(2) 
label(3):
	read_next_structure      bar / 1     t(0)     ref(fail) 
	read_test_var        
	read_atom                baz 
	mode                     t(0) 
label(4):
	read_test_var        
	read_atom                c 
	space                    -1 
	jmp                      p / 2 

------ Test match(30) -------
p(A) ?-
	p(A, B).
p(A) :-
	integer(A),
	q(A).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [var] - []
    [var, meta] - [1]
    [integer] - [2]
    [bignum] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(7)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(8)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(8)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(fail) 
label(3):
	in_get_meta              a(1)     ref(fail) 
label(7):
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	jmp                      p / 2 
label(5):
	bi_integer               a(1) 
label(8):
	jmp                      q / 1 

------ Test match(31) -------
p(A) ?-
	!,
	p(A, B).
p(A) :-
	q(A).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [2]
    [var, meta] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	savecut                  a(2) 
	switch_on_type           a(1) 
		meta: 	ref(2)
		[]: 	ref(5)
		atom: 	ref(5)
		bignum: 	ref(5)
		breal: 	ref(5)
		double: 	ref(5)
		goal: 	ref(5)
		handle: 	ref(5)
		integer: 	ref(5)
		list: 	ref(5)
		rational: 	ref(5)
		string: 	ref(5)
		structure: 	ref(5)

	branch                   ref(5) 
label(2):
	try_me_else              0     2     ref(4) 
label(3):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	move                     a(2)     a(3) 
	read_variable            a(2) 
	cut                      a(3) 
	jmp                      p / 2 
label(4):
	trust_me                 0 
label(5):
	jmp                      q / 1 

------ Test match(32) -------
p(A) ?-
	p(A, B).
p(A) :-
	free(A),
	q(A).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [var] - []
    [var, free] - [2]
    [var, meta] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(8)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(7) 
label(5):
	bi_free                  a(1) 
label(7):
	jmp                      q / 1 
label(3):
	in_get_meta              a(1)     ref(fail) 
label(8):
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	jmp                      p / 2 

------ Test match(33) -------
p(A) ?-
	p(A, B).
p(A) :-
	meta(A),
	q(A).

INDEXES for (nondet) disjunction [2]
1. Quality 2.0
    [] - []
    [var] - []
    [var, meta] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	try_me_else              0     1     ref(3) 
label(2):
	in_get_meta              a(1)     ref(fail) 
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	jmp                      p / 2 
label(3):
	trust_me                 0 
label(4):
	bi_meta                  a(1) 
	jmp                      q / 1 

------ Test match(34) -------
p(A) :-
	free(A),
	q(A).
p(A) ?-
	p(A, B).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [var] - []
    [var, free] - [1]
    [var, meta] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(8)
		[]: 	ref(fail)
		atom: 	ref(fail)
		bignum: 	ref(fail)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(fail)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(7) 
label(3):
	bi_free                  a(1) 
label(7):
	jmp                      q / 1 
label(5):
	in_get_meta              a(1)     ref(fail) 
label(8):
	read_void            
	read_attribute           suspend 
	read_variable            a(2) 
	jmp                      p / 2 

------ Test match(40) -------
p([A, B, C, D, E]) ?-
	true.

p / 1:
label(1):
	in_get_list              a(1)     ref(2) 
label(2):
	read_void            
	read_last_list           ref(fail) 
	read_void            
	read_last_list           ref(fail) 
	read_void            
	read_last_list           ref(fail) 
	read_void            
	read_last_list           ref(fail) 
	read_void            
	read_test_var        
	read_nil             
	ret                  

------ Test match(41) -------
p(f(A, B, C, D, E)) ?-
	true.

p / 1:
label(1):
	in_get_structure         a(1)     f / 5     ref(2) 
label(2):
	ret                  

------ Test match(42) -------
p(f(A, s(B, C), D, E)) ?-
	true.

p / 1:
label(1):
	in_get_structure         a(1)     f / 4     ref(2) 
label(2):
	read_void            
	read_structure           s / 2     ref(fail) 
	mode                     t(0) 
	space                    -1 
	ret                  

------ Test unify(1) -------
p(A, B, C) :-
	q,
	A = f(1, g(B, D), E, h(C, B)),
	r(C, D),
	s(E).

p / 3:
label(1):
	get_variable             4     a(1)     y(2) 
	move                     2     a(2)     y(3) 
	callf                    q / 0     Y[2,3,4] 
	move                     y(2)     a(3) 
	get_structure            a(3)     f / 4     ref(4) 
	write_integer            1 
	write_first_structure     g / 2 
label(2):
	write_value              y(3) 
	write_variable           a(2) 
	mode                     t(0)     ref(5) 
	write_variable           y(1) 
	write_structure          h / 2 
label(3):
	write_value              y(4) 
	write_value              y(3) 
	branch                   ref(6) 
label(4):
	read_integer             1 
	read_structure           g / 2     ref(2) 
	read_value               y(3) 
	read_variable            a(2) 
	mode                     t(0) 
label(5):
	read_variable            y(1) 
	read_last_structure      h / 2     ref(3) 
	read_value               y(4) 
	read_value               y(3) 
label(6):
	space                    -1 
	move_callf               y(4)     a(1)     r / 2     Y[1] 
	move_chain               y(1)     a(1)     s / 1 

------ Test dis(1) -------
p :-
	(
	    a
	;
	    (
		b
	    ;
		(
		    c
		;
		    d
		)
	    )
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	jmp                      a / 0 
label(3):
	retry_me_else            0     ref(5) 
label(4):
	jmp                      b / 0 
label(5):
	retry_me_else            0     ref(7) 
label(6):
	jmp                      c / 0 
label(7):
	trust_me                 0 
label(8):
	jmp                      d / 0 

------ Test dis(2) -------
p :-
	(
	    (
		(
		    a
		;
		    b
		)
	    ;
		c
	    )
	;
	    d
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	jmp                      a / 0 
label(3):
	retry_me_else            0     ref(5) 
label(4):
	jmp                      b / 0 
label(5):
	retry_me_else            0     ref(7) 
label(6):
	jmp                      c / 0 
label(7):
	trust_me                 0 
label(8):
	jmp                      d / 0 

------ Test dis(3) -------
p :-
	(
	    a
	;
	    (
		(
		    b
		;
		    c
		)
	    ;
		d
	    )
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	jmp                      a / 0 
label(3):
	retry_me_else            0     ref(5) 
label(4):
	jmp                      b / 0 
label(5):
	retry_me_else            0     ref(7) 
label(6):
	jmp                      c / 0 
label(7):
	trust_me                 0 
label(8):
	jmp                      d / 0 

------ Test dis(4) -------
p :-
	(
	    a
	->
	    aa
	;
	    b
	).

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	chain                    aa / 0 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	chain                    b / 0 

------ Test dis(5) -------
p :-
	q,
	(
	    a
	->
	    aa
	;
	    b
	).

p / 0:
label(1):
	allocate                 1 
	callf                    q / 0     Y[] 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	chain                    aa / 0 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	chain                    b / 0 

------ Test dis(6) -------
p :-
	(
	    a
	->
	    aa
	;
	    (
		b
	    ->
		bb
	    ;
		(
		    c
		->
		    cc
		;
		    d
		)
	    )
	).

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	chain                    aa / 0 
label(3):
	retry_me_inline          0     ref(5)     Y[1] 
label(4):
	callf                    b / 0     Y[1] 
	cut                      y(1)     0 
	chain                    bb / 0 
label(5):
	retry_me_inline          0     ref(7)     Y[1] 
label(6):
	callf                    c / 0     Y[1] 
	cut                      y(1)     0 
	chain                    cc / 0 
label(7):
	trust_me_inline          0     Y[] 
label(8):
	chain                    d / 0 

------ Test dis(7) -------
p :-
	(
	    a
	->
	    aa
	;
	    (
		b
	    ->
		bb
	    ;
		(
		    c
		->
		    cc
		;
		    (
			d
		    ->
			dd
		    )
		)
	    )
	).

p / 0:
label(1):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	chain                    aa / 0 
label(3):
	retry_me_inline          0     ref(5)     Y[1] 
label(4):
	callf                    b / 0     Y[1] 
	cut                      y(1)     0 
	chain                    bb / 0 
label(5):
	retry_me_inline          0     ref(7)     Y[1] 
label(6):
	callf                    c / 0     Y[1] 
	cut                      y(1)     0 
	chain                    cc / 0 
label(7):
	trust_me_inline          0     Y[] 
label(8):
	savecut                  y(2) 
	callf                    d / 0     Y[2] 
	cut                      y(2)     0 
	chain                    dd / 0 

------ Test dis(8) -------
p :-
	(
	    a
	;
	    (
		b
	    ->
		bb
	    ;
		(
		    c
		->
		    cc
		;
		    d
		)
	    )
	).

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	chain                    a / 0 
label(3):
	retry_me_inline          0     ref(5)     Y[1] 
label(4):
	callf                    b / 0     Y[1] 
	cut                      y(1)     0 
	chain                    bb / 0 
label(5):
	retry_me_inline          0     ref(7)     Y[1] 
label(6):
	callf                    c / 0     Y[1] 
	cut                      y(1)     0 
	chain                    cc / 0 
label(7):
	trust_me_inline          0     Y[] 
label(8):
	chain                    d / 0 

------ Test dis(9) -------
p :-
	(
	    a
	->
	    aa
	;
	    (
		b
	    ;
		(
		    c
		->
		    cc
		;
		    d
		)
	    )
	).

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	chain                    aa / 0 
label(3):
	retry_me_inline          0     ref(5)     Y[1] 
label(4):
	chain                    b / 0 
label(5):
	retry_me_inline          0     ref(7)     Y[1] 
label(6):
	callf                    c / 0     Y[1] 
	cut                      y(1)     0 
	chain                    cc / 0 
label(7):
	trust_me_inline          0     Y[] 
label(8):
	chain                    d / 0 

------ Test dis(10) -------
p :-
	(
	    a
	->
	    aa
	;
	    (
		b
	    ->
		bb
	    ;
		(
		    c
		;
		    d
		)
	    )
	).

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	chain                    aa / 0 
label(3):
	retry_me_inline          0     ref(5)     Y[1] 
label(4):
	callf                    b / 0     Y[1] 
	cut                      y(1)     0 
	chain                    bb / 0 
label(5):
	retry_me_inline          0     ref(7)     Y[] 
label(6):
	chain                    c / 0 
label(7):
	trust_me_inline          0     Y[] 
label(8):
	chain                    d / 0 

------ Test dis(11) -------
p :-
	(
	    a
	->
	    aa
	;
	    (
		(
		    b
		->
		    bb
		;
		    c
		)
	    ;
		d
	    )
	).

p / 0:
label(1):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	chain                    aa / 0 
label(3):
	retry_me_inline          0     ref(8)     Y[] 
label(4):
	savecut                  y(2) 
	try_me_else              0     0     ref(6) 
label(5):
	callf                    b / 0     Y[2] 
	cut                      y(2)     0 
	chain                    bb / 0 
label(6):
	trust_me_inline          0     Y[] 
label(7):
	chain                    c / 0 
label(8):
	trust_me_inline          0     Y[] 
label(9):
	chain                    d / 0 

------ Test dis(12) -------
p :-
	(
	    \+ a
	->
	    b
	;
	    c
	).

p / 0:
label(1):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     0     ref(6) 
label(2):
	savecut                  y(2) 
	try_me_else              0     0     ref(4) 
label(3):
	callf                    a / 0     Y[1,2] 
	cut                      y(2)     1 
	failure              
label(4):
	trust_me_inline          0     Y[1] 
label(5):
	cut                      y(1)     0 
	chain                    b / 0 
label(6):
	trust_me_inline          0     Y[] 
label(7):
	chain                    c / 0 

------ Test clause(1) -------
p :-
	a.
p :-
	b.

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	jmp                      a / 0 
label(3):
	trust_me                 0 
label(4):
	jmp                      b / 0 

------ Test clause(2) -------
p :-
	a.
p :-
	b.
p :-
	c,
	d.

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	jmp                      a / 0 
label(3):
	retry_me_else            0     ref(5) 
label(4):
	jmp                      b / 0 
label(5):
	trust_me                 0 
label(6):
	allocate                 0 
	callf                    c / 0     Y[] 
	chain                    d / 0 

------ Test clause(3) -------
p :-
	(
	    a
	->
	    aa
	).
p :-
	b.

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 1 
	savecut                  y(1) 
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	chain                    aa / 0 
label(3):
	trust_me                 0 
label(4):
	jmp                      b / 0 

------ Test special(1) -------
p(A) :-
	A.

p / 1:
label(1):
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : call_ / 2 

------ Test special(2) -------
p(A) :-
	call(A).

p / 1:
label(1):
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : call_ / 2 

------ Test special(3) -------
p(A, B) :-
	A @ B.

p / 2:
label(1):
	jmp                      sepia_kernel : call_ / 2 

------ Test special(4) -------
p(A) :-
	A @ lists.

p / 1:
label(1):
	put_atom                 a(2)     lists 
	jmp                      sepia_kernel : call_ / 2 

------ Test special(5) -------
p(A, B) :-
	B : A.

p / 2:
label(1):
	put_module               a(3)     eclipse 
	swap                     a(1)     a(2) 
	jmp                      sepia_kernel : '[]:@' / 3 

------ Test special(6) -------
p(A) :-
	lists : A.

p / 1:
label(1):
	move                     a(1)     a(2) 
	put_atom                 a(1)     lists 
	put_module               a(3)     eclipse 
	jmp                      sepia_kernel : '[]:@' / 3 

------ Test special(7) -------
p :-
	3 = 3.

p / 0:
label(1):
	ret                  

------ Test special(8) -------
p :-
	3 = 4.

p / 0:
label(1):
	failure              

------ Test special(9) -------
p :-
	call(q).

p / 0:
label(1):
	put_atom                 a(1)     q 
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : call_ / 2 

------ Test special(10) -------
p :-
	q,
	call((a, !, b)),
	r.

p / 0:
label(1):
	allocate                 0 
	callf                    q / 0     Y[] 
	put_structure            a(1)     (',') / 2 
	write_atom               a 
	push_structure           3 
	write_didatom            (',') / 2     ! 
	write_atom               b 
	put_module               a(2)     eclipse 
	callf                    sepia_kernel : call_ / 2     Y[] 
	chain                    r / 0 

------ Test special(11) -------
p(A) :-
	call(q) @ A.

p / 1:
label(1):
	move                     a(1)     a(2) 
	put_atom                 a(1)     q 
	jmp                      sepia_kernel : call_ / 2 

------ Test special(12) -------
p :-
	call(q) @ lists.

p / 0:
label(1):
	put_atom                 a(1)     q 
	put_atom                 a(2)     lists 
	jmp                      sepia_kernel : call_ / 2 

------ Test special(13) -------
p :-
	call(writeln(hello)) @ lists.

p / 0:
label(1):
	put_structure            a(1)     writeln / 1 
	write_atom               hello 
	put_atom                 a(2)     lists 
	jmp                      sepia_kernel : call_ / 2 

------ Test special(13) -------
p :-
	writeln(hello) @ lists.

p / 0:
label(1):
	put_atom                 a(1)     hello 
	put_atom                 a(2)     lists 
	jmp                      sepia_kernel : writeln_body / 2 

------ Test special(14) -------
p :-
	(writeln(hello), nl) @ lists.

p / 0:
label(1):
	put_atom                 a(1)     hello 
	put_atom                 a(2)     lists 
	allocate                 0 
	callf                    sepia_kernel : writeln_body / 2     Y[] 
	chain                    lists : nl / 0 

------ Test tool(1) -------
p(A) :-
	get_flag(p / 0, definition_module, A).

p / 1:
label(1):
	move                     a(1)     a(3) 
	put_structure            a(1)     (/) / 2 
	write_atom               p 
	push_integer             0 
	put_atom                 a(2)     definition_module 
	put_module               a(4)     eclipse 
	jmp                      sepia_kernel : get_flag_body / 4 

------ Test tool(2) -------
p(A) :-
	get_flag(p / 0, definition_module, A) @ lists.

p / 1:
label(1):
	move                     a(1)     a(3) 
	put_structure            a(1)     (/) / 2 
	write_atom               p 
	push_integer             0 
	put_atom                 a(2)     definition_module 
	put_atom                 a(4)     lists 
	jmp                      sepia_kernel : get_flag_body / 4 

------ Test tool(3) -------
p(A, B) :-
	get_flag(p / 0, definition_module, B) @ A.

p / 2:
label(1):
	move                     a(1)     a(4) 
	put_structure            a(1)     (/) / 2 
	write_atom               p 
	push_integer             0 
	move                     a(2)     a(3) 
	put_atom                 a(2)     definition_module 
	jmp                      sepia_kernel : get_flag_body / 4 

------ Test tool(4) -------
p :-
	q @ lists.

p / 0:
label(1):
	jmp                      q / 0 

------ Test tool(5) -------
p(A) :-
	q @ A.

p / 1:
label(1):
	jmp                      q / 0 

------ Test cut(1) -------
p :-
	!.

p / 0:
label(1):
	ret                  

------ Test cut(2) -------
p :-
	q,
	!.

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	callf                    q / 0     Y[1] 
	cut                      y(1)     0 
	exit                 

------ Test cut(3) -------
p :-
	q,
	!,
	r.

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	callf                    q / 0     Y[1] 
	cut                      y(1)     0 
	chain                    r / 0 

------ Test cut(4) -------
p :-
	q,
	!,
	r.
p :-
	s.

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    q / 0     Y[1] 
	cut                      y(1)     0 
	chain                    r / 0 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	chain                    s / 0 

------ Test cut(5) -------
p :-
	a.
p :-
	!,
	bb.
p :-
	c,
	d.

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	jmp                      a / 0 
label(3):
	retry_me_else            0     ref(5) 
label(4):
	cut                      a(1) 
	jmp                      bb / 0 
label(5):
	trust_me                 0 
label(6):
	allocate                 0 
	callf                    c / 0     Y[] 
	chain                    d / 0 

------ Test cut(6) -------
p :-
	a.
p :-
	b,
	!,
	bb.
p :-
	c,
	d.

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	chain                    a / 0 
label(3):
	retry_me_inline          0     ref(5)     Y[1] 
label(4):
	callf                    b / 0     Y[1] 
	cut                      y(1)     0 
	chain                    bb / 0 
label(5):
	trust_me_inline          0     Y[] 
label(6):
	callf                    c / 0     Y[] 
	chain                    d / 0 

------ Test cut_to(1) -------
p(A) :-
	q,
	sepia_kernel : cut_to(A).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	cut                      a(1) 
	exit                 

------ Test cut_to(2) -------
p(A) :-
	q,
	nonvar(A),
	sepia_kernel : cut_to(A).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move                     y(1)     a(1) 
	bi_nonvar                a(1) 
	cut                      a(1) 
	exit                 

------ Test cut_to(3) -------
p(A) :-
	nonvar(A),
	sepia_kernel : cut_to(A).

p / 1:
label(1):
	bi_nonvar                a(1) 
	cut                      a(1) 
	ret                  

------ Test cut_to(4) -------
p(A) :-
	sepia_kernel : cut_to(A).

p / 1:
label(1):
	cut                      a(1) 
	ret                  

------ Test env(1) -------
p :-
	q(A, B, C, D, E, F, G),
	r(H, I, J, K, L, M, N),
	q(A, B, C, D, E, F, G),
	r(H, I, J, K, L, M, N).

p / 0:
label(1):
	allocate                 14 
	put_global_variable2     a(1)     y(8)     a(2)     y(9) 
	put_global_variable2     a(3)     y(10)     a(4)     y(11) 
	put_global_variable2     a(5)     y(12)     a(6)     y(13) 
	put_global_variable_callf     a(7)     y(14)     q / 7     Y[8,9,10,11,12,13,14] 
	put_global_variable2     a(1)     y(1)     a(2)     y(2) 
	put_global_variable2     a(3)     y(3)     a(4)     y(4) 
	put_global_variable2     a(5)     y(5)     a(6)     y(6) 
	put_global_variable_callf     a(7)     y(7)     r / 7     Y[1,2,3,4,5,6,7,8,9,10,11,12,13,14] 
	move                     7     y(8)     a(1) 
	callf                    q / 7     Y[1,2,3,4,5,6,7] 
	move                     7     y(1)     a(1) 
	chain                    r / 7 

------ Test env(2) -------
p :-
	q(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T),
	r(U, V, W, X, Y, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1),
	s(A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T),
	t(U, V, W, X, Y, Z, A1, B1, C1, D1, E1, F1, G1, H1, I1, J1, K1, L1, M1, N1).

p / 0:
label(1):
	allocate                 40 
	put_global_variable2     a(1)     y(21)     a(2)     y(22) 
	put_global_variable2     a(3)     y(23)     a(4)     y(24) 
	put_global_variable2     a(5)     y(25)     a(6)     y(26) 
	put_global_variable2     a(7)     y(27)     a(8)     y(28) 
	put_global_variable2     a(9)     y(29)     a(10)     y(30) 
	put_global_variable2     a(11)     y(31)     a(12)     y(32) 
	put_global_variable2     a(13)     y(33)     a(14)     y(34) 
	put_global_variable2     a(15)     y(35)     a(16)     y(36) 
	put_global_variable2     a(17)     y(37)     a(18)     y(38) 
	put_global_variable2     a(19)     y(39)     a(20)     y(40) 
	callf                    q / 20     Y[21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40] 
	put_global_variable2     a(1)     y(1)     a(2)     y(2) 
	put_global_variable2     a(3)     y(3)     a(4)     y(4) 
	put_global_variable2     a(5)     y(5)     a(6)     y(6) 
	put_global_variable2     a(7)     y(7)     a(8)     y(8) 
	put_global_variable2     a(9)     y(9)     a(10)     y(10) 
	put_global_variable2     a(11)     y(11)     a(12)     y(12) 
	put_global_variable2     a(13)     y(13)     a(14)     y(14) 
	put_global_variable2     a(15)     y(15)     a(16)     y(16) 
	put_global_variable2     a(17)     y(17)     a(18)     y(18) 
	put_global_variable2     a(19)     y(19)     a(20)     y(20) 
	callf                    r / 20     Y[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40] 
	move                     20     y(21)     a(1) 
	callf                    s / 20     Y[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20] 
	move                     20     y(1)     a(1) 
	chain                    t / 20 

------ Test env(3) -------
p(A, B, C) :-
	a,
	b(A),
	c(B),
	d(C),
	e.

p / 3:
label(1):
	get_variable             3     a(1)     y(3) 
	move                     a(2)     y(2)     a(3)     y(1) 
	callf                    a / 0     Y[1,2,3] 
	move_callf               y(3)     a(1)     b / 1     Y[1,2] 
	move_callf               y(2)     a(1)     c / 1     Y[1] 
	move_callf               y(1)     a(1)     d / 1     Y[] 
	chain                    e / 0 

------ Test env(4) -------
p(A, B, C) :-
	a,
	b(A),
	c(C),
	d(B),
	e.

p / 3:
label(1):
	get_variable             3     a(1)     y(3) 
	move                     2     a(2)     y(1) 
	callf                    a / 0     Y[1,2,3] 
	move_callf               y(3)     a(1)     b / 1     Y[1,2] 
	move_callf               y(2)     a(1)     c / 1     Y[1] 
	move_callf               y(1)     a(1)     d / 1     Y[] 
	chain                    e / 0 

------ Test env(5) -------
p(A, B, C, D) :-
	t,
	a(A),
	e.
p(A, B, C, D) :-
	t,
	b(B),
	e.
p(A, B, C, D) :-
	t,
	c(C),
	d(D),
	e.
p(A, B, C, D) :-
	t,
	a(A),
	e.

p / 4:
label(1):
	get_variable             4     a(1)     y(1) 
	move                     3     a(2)     y(2) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    t / 0     Y[1] 
	move_callf               y(1)     a(1)     a / 1     Y[] 
	chain                    e / 0 
label(3):
	retry_me_inline          0     ref(5)     Y[1,2,3,4] 
label(4):
	callf                    t / 0     Y[2] 
	move_callf               y(2)     a(1)     b / 1     Y[] 
	chain                    e / 0 
label(5):
	retry_me_inline          0     ref(7)     Y[1,3,4] 
label(6):
	callf                    t / 0     Y[3,4] 
	move_callf               y(3)     a(1)     c / 1     Y[4] 
	move_callf               y(4)     a(1)     d / 1     Y[] 
	chain                    e / 0 
label(7):
	trust_me_inline          0     Y[1] 
label(8):
	callf                    t / 0     Y[1] 
	move_callf               y(1)     a(1)     a / 1     Y[] 
	chain                    e / 0 

------ Test env(6) -------
p(a, A, B, C, D) :-
	t,
	a(A),
	e.
p(a, A, B, C, D) :-
	t,
	b(B),
	e.
p(b, A, B, C, D) :-
	t,
	c(C),
	d(D),
	e.
p(a, A, B, C, D) :-
	t,
	a(A),
	e.

INDEXES for (nondet) disjunction [2]
1. Quality 2.7
    [] - []
    [atom] - []
    [atom, a] - [1, 2, 4]
    [atom, b] - [3]
    [var] - [1, 2, 3, 4]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: retry
    Branch 4: trust
p / 5:
label(1):
	get_variable             4     a(2)     y(1) 
	move                     3     a(3)     y(2) 
	atom_switch              a(1) 
		a: 	ref(12)
		b: 	ref(13)
		default: 	ref(fail)

label(3):
	try_me_else              0     1     ref(5) 
label(4):
	get_atom                 a(1)     a 
	callf                    t / 0     Y[1] 
	move_callf               y(1)     a(1)     a / 1     Y[] 
	chain                    e / 0 
label(5):
	retry_me_inline          0     ref(7)     Y[1,2,3,4] 
label(6):
	get_atom                 a(1)     a 
	callf                    t / 0     Y[2] 
	move_callf               y(2)     a(1)     b / 1     Y[] 
	chain                    e / 0 
label(7):
	retry_me_inline          0     ref(9)     Y[1,3,4] 
label(8):
	get_atom                 a(1)     b 
label(13):
	callf                    t / 0     Y[3,4] 
	move_callf               y(3)     a(1)     c / 1     Y[4] 
	move_callf               y(4)     a(1)     d / 1     Y[] 
	chain                    e / 0 
label(9):
	trust_me_inline          0     Y[1] 
label(10):
	get_atom                 a(1)     a 
	callf                    t / 0     Y[1] 
	move_callf               y(1)     a(1)     a / 1     Y[] 
	chain                    e / 0 
label(12):
	try                      0     1     ref(4) 
	retry_inline             0     ref(6)     Y[1,2] 
	trust_inline             0     ref(10)     Y[1] 

------ Test env(7) -------
p(a, A, B, C, D) :-
	t,
	a(A),
	e.
p(a, A, B, C, D) :-
	t,
	b(B),
	e.
p(a, A, B, C, D) :-
	t,
	c(C),
	d(D),
	e.
p(b, A, B, C, D) :-
	t,
	a(A),
	e.

INDEXES for (nondet) disjunction [2]
1. Quality 2.7
    [] - []
    [atom] - []
    [atom, a] - [1, 2, 3]
    [atom, b] - [4]
    [var] - [1, 2, 3, 4]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: retry
    Branch 4: trust
p / 5:
label(1):
	get_variable             4     a(2)     y(1) 
	move                     3     a(3)     y(2) 
	atom_switch              a(1) 
		a: 	ref(12)
		b: 	ref(13)
		default: 	ref(fail)

label(3):
	try_me_else              0     1     ref(5) 
label(4):
	get_atom                 a(1)     a 
	callf                    t / 0     Y[1] 
	move_callf               y(1)     a(1)     a / 1     Y[] 
	chain                    e / 0 
label(5):
	retry_me_inline          0     ref(7)     Y[1,2,3,4] 
label(6):
	get_atom                 a(1)     a 
	callf                    t / 0     Y[2] 
	move_callf               y(2)     a(1)     b / 1     Y[] 
	chain                    e / 0 
label(7):
	retry_me_inline          0     ref(9)     Y[1,3,4] 
label(8):
	get_atom                 a(1)     a 
	callf                    t / 0     Y[3,4] 
	move_callf               y(3)     a(1)     c / 1     Y[4] 
	move_callf               y(4)     a(1)     d / 1     Y[] 
	chain                    e / 0 
label(9):
	trust_me_inline          0     Y[1] 
label(10):
	get_atom                 a(1)     b 
label(13):
	callf                    t / 0     Y[1] 
	move_callf               y(1)     a(1)     a / 1     Y[] 
	chain                    e / 0 
label(12):
	try                      0     1     ref(4) 
	retry_inline             0     ref(6)     Y[2,3,4] 
	trust_inline             0     ref(8)     Y[3,4] 

------ Test env(8) -------
p(a, A, B, C, D) :-
	t,
	a(A),
	e.
p(b, A, B, C, D) :-
	t,
	b(B),
	e.
p(a, A, B, C, D) :-
	t,
	c(C),
	d(D),
	e.
p(b, A, B, C, D) :-
	t,
	a(A),
	e.

INDEXES for (nondet) disjunction [2]
1. Quality 2.7
    [] - []
    [atom] - []
    [atom, a] - [1, 3]
    [atom, b] - [2, 4]
    [var] - [1, 2, 3, 4]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: retry
    Branch 4: trust
p / 5:
label(1):
	get_variable             4     a(2)     y(1) 
	move                     3     a(3)     y(2) 
	atom_switch              a(1) 
		a: 	ref(12)
		b: 	ref(13)
		default: 	ref(fail)

label(3):
	try_me_else              0     1     ref(5) 
label(4):
	get_atom                 a(1)     a 
	callf                    t / 0     Y[1] 
	move_callf               y(1)     a(1)     a / 1     Y[] 
	chain                    e / 0 
label(5):
	retry_me_inline          0     ref(7)     Y[1,2,3,4] 
label(6):
	get_atom                 a(1)     b 
	callf                    t / 0     Y[2] 
	move_callf               y(2)     a(1)     b / 1     Y[] 
	chain                    e / 0 
label(7):
	retry_me_inline          0     ref(9)     Y[1,3,4] 
label(8):
	get_atom                 a(1)     a 
	callf                    t / 0     Y[3,4] 
	move_callf               y(3)     a(1)     c / 1     Y[4] 
	move_callf               y(4)     a(1)     d / 1     Y[] 
	chain                    e / 0 
label(9):
	trust_me_inline          0     Y[1] 
label(10):
	get_atom                 a(1)     b 
	callf                    t / 0     Y[1] 
	move_callf               y(1)     a(1)     a / 1     Y[] 
	chain                    e / 0 
label(12):
	try                      0     1     ref(4) 
	trust_inline             0     ref(8)     Y[3,4] 
label(13):
	try                      0     1     ref(6) 
	trust_inline             0     ref(10)     Y[1] 

------ Test env(20) -------
p(A) :-
	p,
	q(A).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    p / 0     Y[1] 
	move_chain               y(1)     a(1)     q / 1 

------ Test env(21) -------
p(A) :-
	p,
	q(A),
	atom(a).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    p / 0     Y[1] 
	move_callf               y(1)     a(1)     q / 1     Y[] 
	put_atom                 a(1)     a 
	bi_atom                  a(1) 
	exit                 

------ Test env(22) -------
p(A) :-
	p,
	q(A),
	atom(A).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    p / 0     Y[1] 
	move_callf               y(1)     a(1)     q / 1     Y[1] 
	move                     y(1)     a(1) 
	bi_atom                  a(1) 
	exit                 

------ Test env(23) -------
p(A) :-
	q(A).

p / 1:
label(1):
	jmp                      q / 1 

------ Test env(24) -------
p(A) :-
	q(A),
	atom(a).

p / 1:
label(1):
	allocate                 0 
	callf                    q / 1     Y[] 
	put_atom                 a(1)     a 
	bi_atom                  a(1) 
	exit                 

------ Test env(25) -------
p(A) :-
	q(A),
	atom(A).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    q / 1     Y[1] 
	move                     y(1)     a(1) 
	bi_atom                  a(1) 
	exit                 

------ Test env(26) -------
p(A) :-
	(
	    atom(A)
	;
	    number(A)
	),
	integer(A).

INDEXES for (semidet) disjunction [2]
1. Quality 0.7
    [] - []
    [[]] - [1]
    [atom] - [1]
    [rational] - [2]
    [integer] - [2]
    [breal] - [2]
    [bignum] - [2]
    [double] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(fail)
		[]: 	ref(7)
		atom: 	ref(7)
		bignum: 	ref(8)
		breal: 	ref(8)
		double: 	ref(8)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(8)
		list: 	ref(fail)
		rational: 	ref(8)
		string: 	ref(fail)
		structure: 	ref(fail)

	branch                   ref(fail) 
label(3):
	bi_atom                  a(1) 
label(7):
	get_variable             1     a(1)     y(1) 
	branch                   ref(6) 
label(5):
	bi_number                a(1) 
label(8):
	get_variable             1     a(1)     y(1) 
label(6):
	move                     y(1)     a(1) 
	bi_integer               a(1) 
	exit                 

------ Test env(27) -------
p(A) :-
	p,
	q(A),
	!.

p / 1:
label(1):
	allocate                 2 
	savecut                  y(1) 
	move                     a(1)     y(2) 
	callf                    p / 0     Y[1,2] 
	move_callf               y(2)     a(1)     q / 1     Y[1] 
	cut                      y(1)     0 
	exit                 

------ Test env(28) -------
p(A) :-
	p,
	q(A),
	!,
	atom(a).

p / 1:
label(1):
	allocate                 2 
	savecut                  y(1) 
	move                     a(1)     y(2) 
	callf                    p / 0     Y[1,2] 
	move_callf               y(2)     a(1)     q / 1     Y[1] 
	cut                      y(1)     0 
	put_atom                 a(1)     a 
	bi_atom                  a(1) 
	exit                 

------ Test env(29) -------
p(A) :-
	p,
	q(A),
	!,
	atom(A).

p / 1:
label(1):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	callf                    p / 0     Y[1,2] 
	move_callf               y(1)     a(1)     q / 1     Y[1,2] 
	cut                      y(2)     1 
	move                     y(1)     a(1) 
	bi_atom                  a(1) 
	exit                 

------ Test env(30) -------
p(A) :-
	p,
	q(A),
	atom(a),
	!.

p / 1:
label(1):
	allocate                 2 
	savecut                  y(1) 
	move                     a(1)     y(2) 
	callf                    p / 0     Y[1,2] 
	move_callf               y(2)     a(1)     q / 1     Y[1] 
	put_atom                 a(1)     a 
	bi_atom                  a(1) 
	cut                      y(1)     0 
	exit                 

------ Test env(31) -------
p(A) :-
	p,
	q(A),
	atom(A),
	!.

p / 1:
label(1):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	callf                    p / 0     Y[1,2] 
	move_callf               y(1)     a(1)     q / 1     Y[1,2] 
	move                     y(1)     a(1) 
	bi_atom                  a(1) 
	cut                      y(2)     0 
	exit                 

------ Test env(32) -------
p(A) :-
	p(A),
	q(A),
	atom(a),
	(
	    var(B)
	->
	    integer(3)
	;
	    atom(b)
	).

p / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    ref(1)     Y[1] 
	move_callf               y(1)     a(1)     q / 1     Y[] 
	put_atom                 a(2)     a 
	bi_atom                  a(2) 
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1)     0 
	put_integer              a(1)     3 
	bi_integer               a(1) 
	exit                 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	put_atom                 a(1)     b 
	bi_atom                  a(1) 
	exit                 

------ Test true(1) -------
p.

p / 0:
label(1):
	ret                  

------ Test true(2) -------
p :-
	true,
	true,
	true.

p / 0:
label(1):
	ret                  

------ Test true(3) -------
p :-
	true,
	a,
	true,
	b,
	true.

p / 0:
label(1):
	allocate                 0 
	callf                    a / 0     Y[] 
	chain                    b / 0 

------ Test true(4) -------
p :-
	a,
	true,
	true,
	true,
	b,
	true,
	true,
	true.

p / 0:
label(1):
	allocate                 0 
	callf                    a / 0     Y[] 
	chain                    b / 0 

------ Test true(5) -------
p :-
	a,
	true,
	var(A),
	b.

p / 0:
label(1):
	allocate                 0 
	callf                    a / 0     Y[] 
	callf                    true / 0     Y[] 
	put_variable             a(1) 
	bi_var                   a(1) 
	chain                    b / 0 

------ Test true(6) -------
p :-
	a,
	true,
	!,
	b.
p.

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	callf                    true / 0     Y[1] 
	cut                      y(1)     0 
	chain                    b / 0 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	exit                 

------ Test true(7) -------
p :-
	true,
	!,
	b.
p.

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	get_variable             1     a(1)     y(1) 
	callf                    true / 0     Y[1] 
	cut                      y(1)     0 
	chain                    b / 0 
label(3):
	trust_me                 0 
label(4):
	ret                  

------ Test true(8) -------
p :-
	true,
	true,
	!.
p.

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	get_variable             1     a(1)     y(1) 
	callf                    true / 0     Y[1] 
	cut                      y(1)     0 
	deallocate           
	branch                   ref(4) 
label(3):
	trust_me                 0 
label(4):
	ret                  

------ Test true(9) -------
p :-
	(
	    var(A),
	    true
	->
	    true
	;
	    true
	),
	p.

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	put_variable             a(2) 
	bi_var                   a(2) 
	get_variable             1     a(1)     y(1) 
	callf                    true / 0     Y[1] 
	cut                      y(1)     0 
	chain                    ref(1) 
label(3):
	trust_me                 0 
label(4):
	jmp                      ref(1) 

------ Test true(10) -------
p :-
	q,
	(
	    true
	->
	    r
	;
	    s
	).

p / 0:
label(1):
	allocate                 1 
	callf                    q / 0     Y[] 
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	move                     a(1)     y(1) 
	callf                    true / 0     Y[1] 
	cut                      y(1)     0 
	chain                    r / 0 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	chain                    s / 0 

------ Test true(11) -------
p(A) :-
	true,
	q(A).

p / 1:
label(1):
	jmp                      q / 1 

------ Test true(12) -------
p(A) :-
	q(A),
	true.

p / 1:
label(1):
	jmp                      q / 1 

------ Test true(13) -------
p :-
	(
	    true
	;
	    true
	),
	(
	    true
	;
	    true
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 0 
label(5):
	try_me_else              0     0     ref(7) 
label(6):
	exit                 
label(3):
	trust_me                 0 
label(4):
	allocate                 0 
	branch                   ref(5) 
label(7):
	trust_me_inline          0     Y[] 
label(8):
	exit                 

------ Test true(14) -------
p :-
	a,
	(
	    true
	;
	    true
	).

p / 0:
label(1):
	allocate                 0 
	callf                    a / 0     Y[] 
	try_me_else              0     0     ref(3) 
label(2):
	exit                 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	exit                 

------ Test true(15) -------
p :-
	true,
	sepia_kernel : var(A),
	b.

p / 0:
label(1):
	allocate                 0 
	callf                    true / 0     Y[] 
	put_variable             a(1) 
	bi_var                   a(1) 
	chain                    b / 0 

------ Test true(16) -------
p :-
	true,
	A : var(B),
	b.

p / 0:
label(1):
	put_variable             a(1) 
	put_structure            a(2)     var / 1 
	push_void            
	put_module               a(3)     eclipse 
	allocate                 0 
	callf                    sepia_kernel : '[]:@' / 3     Y[] 
	chain                    b / 0 

------ Test true(17) -------
p :-
	true,
	sepia_kernel : nl,
	b.

p / 0:
label(1):
	allocate                 0 
	callf                    sepia_kernel : nl / 0     Y[] 
	chain                    b / 0 

------ Test true(18) -------
p :-
	true,
	(
	    a
	;
	    b
	).

p / 0:
label(1):
	allocate                 0 
	callf                    true / 0     Y[] 
	try_me_else              0     0     ref(3) 
label(2):
	chain                    a / 0 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	chain                    b / 0 

------ Test true(19) -------
p :-
	true,
	(
	    a
	->
	    b
	).

p / 0:
label(1):
	allocate                 1 
	callf                    true / 0     Y[] 
	savecut                  y(1) 
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	chain                    b / 0 

------ Test true(20) -------
p :-
	true,
	(
	    a
	->
	    b
	;
	    c
	).

p / 0:
label(1):
	allocate                 1 
	callf                    true / 0     Y[] 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	chain                    b / 0 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	chain                    c / 0 

------ Test true(21) -------
p :-
	true,
	once a.

p / 0:
label(1):
	allocate                 1 
	callf                    true / 0     Y[] 
	savecut                  y(1) 
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	exit                 

------ Test true(22) -------
p :-
	true,
	\+ a.

p / 0:
label(1):
	allocate                 1 
	callf                    true / 0     Y[] 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	failure              
label(3):
	trust_me_inline          0     Y[] 
label(4):
	exit                 

------ Test true(23) -------
p :-
	true,
	not a.

p / 0:
label(1):
	allocate                 1 
	callf                    true / 0     Y[] 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	callf                    a / 0     Y[1] 
	cut                      y(1)     0 
	failure              
label(3):
	trust_me_inline          0     Y[] 
label(4):
	exit                 

------ Test true(24) -------
p :-
	true,
	(4 > 3) @ lists.

p / 0:
label(1):
	allocate                 0 
	callf                    true / 0     Y[] 
	put_integer              a(1)     4 
	put_integer              a(2)     3 
	bi_gt                    a(1)     a(2)     lists     48 
	exit                 

------ Test true(25) -------
p :-
	true,
	writeln(hello) @ lists.

p / 0:
label(1):
	put_atom                 a(1)     hello 
	put_atom                 a(2)     lists 
	jmp                      sepia_kernel : writeln_body / 2 

------ Test bip(type_tests) -------
p(A) :-
	free(A).
p(A) :-
	is_suspension(A).
p(A) :-
	is_event(A).
p(A) :-
	is_handle(A).
p(A) :-
	nonvar(A).
p(A) :-
	var(A).
p(A) :-
	meta(A).
p(A) :-
	atom(A).
p(A) :-
	integer(A).
p(A) :-
	sepia_kernel : bignum(A).
p(A) :-
	rational(A).
p(A) :-
	real(A).
p(A) :-
	float(A).
p(A) :-
	breal(A).
p(A) :-
	string(A).
p(A) :-
	number(A).
p(A) :-
	atomic(A).
p(A) :-
	callable(A).
p(A) :-
	compound(A).
p(A) :-
	is_list(A).
p(A) :-
	fail.

INDEXES for (nondet) disjunction [2]
1. Quality 4.4
    [] - [21]
    [[]] - [5, 8, 17, 18, 20, 21]
    [var] - [6, 21]
    [var, free] - [1, 6, 21]
    [var, meta] - [6, 7, 21]
    [atom] - [3, 5, 8, 17, 18, 21]
    [bignum] - [5, 9, 10, 16, 17, 21]
    [goal] - [2, 5, 17, 21]
    [double] - [5, 12, 13, 16, 17, 21]
    [list] - [5, 18, 19, 20, 21]
    [structure] - [5, 18, 19, 21]
    [rational] - [5, 11, 16, 17, 21]
    [handle] - [3, 4, 5, 17, 21]
    [breal] - [5, 12, 14, 16, 17, 21]
    [integer] - [5, 9, 16, 17, 21]
    [string] - [5, 15, 17, 21]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: try
    Branch 3: try
    Branch 4: retry
    Branch 5: retry
    Branch 6: retry
    Branch 7: retry
    Branch 8: retry
    Branch 9: retry
    Branch 10: retry
    Branch 11: retry
    Branch 12: retry
    Branch 13: retry
    Branch 14: retry
    Branch 15: retry
    Branch 16: retry
    Branch 17: retry
    Branch 18: retry
    Branch 19: retry
    Branch 20: retry
    Branch 21: trust
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(58)
		[]: 	ref(45)
		atom: 	ref(46)
		bignum: 	ref(47)
		breal: 	ref(48)
		double: 	ref(49)
		goal: 	ref(50)
		handle: 	ref(51)
		integer: 	ref(52)
		list: 	ref(53)
		rational: 	ref(54)
		string: 	ref(55)
		structure: 	ref(56)

label(57):
	try                      0     1     ref(3) 
	retry                    0     ref(13) 
	trust                    0     ref(43) 
label(3):
	bi_free                  a(1) 
	ret                  
label(5):
	bi_is_suspension         a(1) 
	ret                  
label(7):
	bi_is_event              a(1) 
	ret                  
label(9):
	bi_is_handle             a(1) 
	ret                  
label(11):
	bi_nonvar                a(1) 
	ret                  
label(13):
	bi_var                   a(1) 
	ret                  
label(15):
	bi_meta                  a(1) 
	ret                  
label(17):
	bi_atom                  a(1) 
	ret                  
label(19):
	bi_integer               a(1) 
	ret                  
label(21):
	bi_bignum                a(1) 
	ret                  
label(23):
	bi_rational              a(1) 
	ret                  
label(25):
	bi_real                  a(1) 
	ret                  
label(27):
	bi_float                 a(1) 
	ret                  
label(29):
	bi_breal                 a(1) 
	ret                  
label(31):
	bi_string                a(1) 
	ret                  
label(33):
	bi_number                a(1) 
	ret                  
label(35):
	bi_atomic                a(1) 
	ret                  
label(37):
	bi_callable              a(1) 
	ret                  
label(39):
	bi_compound              a(1) 
	ret                  
label(41):
	bi_is_list               a(1) 
	ret                  
label(43):
	failure              
label(45):
	try                      0     1     ref(11) 
	retry                    0     ref(17) 
	retry                    0     ref(35) 
	retry                    0     ref(37) 
	retry                    0     ref(41) 
	trust                    0     ref(43) 
label(46):
	try                      0     1     ref(7) 
	retry                    0     ref(11) 
	retry                    0     ref(17) 
	retry                    0     ref(35) 
	retry                    0     ref(37) 
	trust                    0     ref(43) 
label(47):
	try                      0     1     ref(11) 
	retry                    0     ref(19) 
	retry                    0     ref(21) 
	retry                    0     ref(33) 
	retry                    0     ref(35) 
	trust                    0     ref(43) 
label(48):
	try                      0     1     ref(11) 
	retry                    0     ref(25) 
	retry                    0     ref(29) 
	retry                    0     ref(33) 
	retry                    0     ref(35) 
	trust                    0     ref(43) 
label(49):
	try                      0     1     ref(11) 
	retry                    0     ref(25) 
	retry                    0     ref(27) 
	retry                    0     ref(33) 
	retry                    0     ref(35) 
	trust                    0     ref(43) 
label(50):
	try                      0     1     ref(5) 
	retry                    0     ref(11) 
	retry                    0     ref(35) 
	trust                    0     ref(43) 
label(51):
	try                      0     1     ref(7) 
	retry                    0     ref(9) 
	retry                    0     ref(11) 
	retry                    0     ref(35) 
	trust                    0     ref(43) 
label(52):
	try                      0     1     ref(11) 
	retry                    0     ref(19) 
	retry                    0     ref(33) 
	retry                    0     ref(35) 
	trust                    0     ref(43) 
label(53):
	try                      0     1     ref(11) 
	retry                    0     ref(37) 
	retry                    0     ref(39) 
	retry                    0     ref(41) 
	trust                    0     ref(43) 
label(54):
	try                      0     1     ref(11) 
	retry                    0     ref(23) 
	retry                    0     ref(33) 
	retry                    0     ref(35) 
	trust                    0     ref(43) 
label(55):
	try                      0     1     ref(11) 
	retry                    0     ref(31) 
	retry                    0     ref(35) 
	trust                    0     ref(43) 
label(56):
	try                      0     1     ref(11) 
	retry                    0     ref(37) 
	retry                    0     ref(39) 
	trust                    0     ref(43) 
label(58):
	try                      0     1     ref(13) 
	retry                    0     ref(15) 
	trust                    0     ref(43) 

------ Test bip(type_tests_det1) -------
p(A) :-
	var(A).
p(A) :-
	atomic(A).
p(A) :-
	compound(A).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [[]] - [2]
    [var] - [1]
    [atom] - [2]
    [bignum] - [2]
    [goal] - [2]
    [double] - [2]
    [list] - [3]
    [structure] - [3]
    [rational] - [2]
    [handle] - [2]
    [breal] - [2]
    [integer] - [2]
    [string] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(9)
		[]: 	ref(10)
		atom: 	ref(10)
		bignum: 	ref(10)
		breal: 	ref(10)
		double: 	ref(10)
		goal: 	ref(10)
		handle: 	ref(10)
		integer: 	ref(10)
		list: 	ref(11)
		rational: 	ref(10)
		string: 	ref(10)
		structure: 	ref(11)

	branch                   ref(9) 
label(3):
	bi_var                   a(1) 
label(9):
	ret                  
label(5):
	bi_atomic                a(1) 
label(10):
	ret                  
label(7):
	bi_compound              a(1) 
label(11):
	ret                  

------ Test bip(type_tests_det2) -------
p(A) :-
	var(A).
p(A) :-
	atom(A).
p(A) :-
	number(A).
p(A) :-
	string(A).
p(A) :-
	compound(A).
p(A) :-
	is_handle(A).
p(A) :-
	is_suspension(A).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [[]] - [2]
    [var] - [1]
    [atom] - [2]
    [bignum] - [3]
    [goal] - [7]
    [double] - [3]
    [list] - [5]
    [structure] - [5]
    [rational] - [3]
    [handle] - [6]
    [breal] - [3]
    [integer] - [3]
    [string] - [4]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
    Branch 4: det
    Branch 5: det
    Branch 6: det
    Branch 7: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(17)
		[]: 	ref(18)
		atom: 	ref(18)
		bignum: 	ref(19)
		breal: 	ref(19)
		double: 	ref(19)
		goal: 	ref(15)
		handle: 	ref(20)
		integer: 	ref(19)
		list: 	ref(21)
		rational: 	ref(19)
		string: 	ref(22)
		structure: 	ref(21)

	branch                   ref(17) 
label(3):
	bi_var                   a(1) 
label(17):
	ret                  
label(5):
	bi_atom                  a(1) 
label(18):
	ret                  
label(7):
	bi_number                a(1) 
label(19):
	ret                  
label(9):
	bi_string                a(1) 
label(22):
	ret                  
label(11):
	bi_compound              a(1) 
label(21):
	ret                  
label(13):
	bi_is_handle             a(1) 
label(20):
	ret                  
label(15):
	bi_is_suspension         a(1) 
	ret                  

------ Test bip(type_tests_det3) -------
p(A) :-
	free(A).
p(A) :-
	meta(A).
p(A) :-
	callable(A).
p(A) :-
	number(A).
p(A) :-
	string(A).
p(A) :-
	is_handle(A).
p(A) :-
	is_suspension(A).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [[]] - [3]
    [var] - []
    [var, free] - [1]
    [var, meta] - [2]
    [atom] - [3]
    [bignum] - [4]
    [goal] - [7]
    [double] - [4]
    [list] - [3]
    [structure] - [3]
    [rational] - [4]
    [handle] - [6]
    [breal] - [4]
    [integer] - [4]
    [string] - [5]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
    Branch 4: det
    Branch 5: det
    Branch 6: det
    Branch 7: det
p / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(18)
		[]: 	ref(19)
		atom: 	ref(19)
		bignum: 	ref(20)
		breal: 	ref(20)
		double: 	ref(20)
		goal: 	ref(15)
		handle: 	ref(21)
		integer: 	ref(20)
		list: 	ref(19)
		rational: 	ref(20)
		string: 	ref(22)
		structure: 	ref(19)

	branch                   ref(17) 
label(3):
	bi_free                  a(1) 
label(17):
	ret                  
label(5):
	bi_meta                  a(1) 
label(18):
	ret                  
label(7):
	bi_callable              a(1) 
label(19):
	ret                  
label(9):
	bi_number                a(1) 
label(20):
	ret                  
label(11):
	bi_string                a(1) 
label(22):
	ret                  
label(13):
	bi_is_handle             a(1) 
label(21):
	ret                  
label(15):
	bi_is_suspension         a(1) 
	ret                  

------ Test bip(other) -------
p(A) :-
	sepia_kernel : set_bip_error(A).
p(A) :-
	make_suspension(true, 3, A).
p(A) :-
	sepia_kernel : make_suspension(true, 3, A, eclipse).

p / 1:
label(1):
	try_me_else              0     1     ref(3) 
label(2):
	bi_set_bip_error         a(1) 
	ret                  
label(3):
	retry_me_else            0     ref(5) 
label(4):
	put_atom                 a(2)     true 
	put_integer              a(3)     3 
	put_module               a(4)     eclipse 
	bi_make_suspension       a(2)     a(3)     a(1)     a(4)     0 
	ret                  
label(5):
	trust_me                 0 
label(6):
	put_atom                 a(2)     true 
	put_integer              a(3)     3 
	put_module               a(4)     eclipse 
	bi_make_suspension       a(2)     a(3)     a(1)     a(4)     0 
	ret                  

------ Test bip(eq) -------
p(A, B) :-
	A = B.
p(A, B) :-
	A == B.
p(A, B) :-
	A \== B.
p(A, B) :-
	A ~= B.
p(A, B) :-
	sepia_kernel : \==(A, B, []).

p / 2:
label(1):
	try_me_else              0     2     ref(3) 
label(2):
	get_value                a(1)     a(2) 
	ret                  
label(3):
	retry_me_else            0     ref(5) 
label(4):
	get_matched_value        a(1)     a(2) 
	ret                  
label(5):
	retry_me_else            0     ref(7) 
label(6):
	bi_not_identical         a(1)     a(2) 
	ret                  
label(7):
	retry_me_else            0     ref(9) 
label(8):
	bi_inequality            a(1)     a(2) 
	ret                  
label(9):
	trust_me                 0 
label(10):
	put_nil                  a(3) 
	bi_not_ident_list        a(1)     a(2)     a(3) 
	ret                  

------ Test bip(arith_comp) -------
p(A, B) :-
	A < B.
p(A, B) :-
	A =< B.
p(A, B) :-
	A =:= B.
p(A, B) :-
	A >= B.
p(A, B) :-
	A > B.
p(A, B) :-
	A =\= B.

p / 2:
label(1):
	try_me_else              0     2     ref(3) 
label(2):
	bi_lt                    a(1)     a(2)     eclipse     48 
	ret                  
label(3):
	retry_me_else            0     ref(5) 
label(4):
	bi_le                    a(1)     a(2)     eclipse     48 
	ret                  
label(5):
	retry_me_else            0     ref(7) 
label(6):
	bi_eq                    a(1)     a(2)     eclipse     48 
	ret                  
label(7):
	retry_me_else            0     ref(9) 
label(8):
	bi_ge                    a(1)     a(2)     eclipse     48 
	ret                  
label(9):
	retry_me_else            0     ref(11) 
label(10):
	bi_gt                    a(1)     a(2)     eclipse     48 
	ret                  
label(11):
	trust_me                 0 
label(12):
	bi_ne                    a(1)     a(2)     eclipse     48 
	ret                  

------ Test bip(arith_comp_mod) -------
p(A, B, C) :-
	sepia_kernel : <(A, B, C).
p(A, B, C) :-
	sepia_kernel : =<(A, B, C).
p(A, B, C) :-
	sepia_kernel : =:=(A, B, C).
p(A, B, C) :-
	sepia_kernel : >=(A, B, C).
p(A, B, C) :-
	sepia_kernel : >(A, B, C).
p(A, B, C) :-
	sepia_kernel : =\=(A, B, C).

p / 3:
label(1):
	try_me_else              0     3     ref(3) 
label(2):
	bi_lt                    a(1)     a(2)     a(3)     0 
	ret                  
label(3):
	retry_me_else            0     ref(5) 
label(4):
	bi_le                    a(1)     a(2)     a(3)     0 
	ret                  
label(5):
	retry_me_else            0     ref(7) 
label(6):
	bi_eq                    a(1)     a(2)     a(3)     0 
	ret                  
label(7):
	retry_me_else            0     ref(9) 
label(8):
	bi_ge                    a(1)     a(2)     a(3)     0 
	ret                  
label(9):
	retry_me_else            0     ref(11) 
label(10):
	bi_gt                    a(1)     a(2)     a(3)     0 
	ret                  
label(11):
	trust_me                 0 
label(12):
	bi_ne                    a(1)     a(2)     a(3)     0 
	ret                  

------ Test bip(functions) -------
p(A) :-
	get_bip_error(B),
	B - C,
	+(C, 1, D),
	+(B, C, D),
	-(D, 1, E),
	-(D, C, E),
	*(E, 2, F),
	/(F, 2, G),
	//(G, 2, H),
	rem(H, 2, I),
	div(I, 2, J),
	mod(J, 2, K),
	/\(K, 2, L),
	\/(L, 2, M),
	xor(M, 2, N),
	\(N, O),
	arity(foo(a, b, c), 3),
	arg(O, foo(a, b, c), A).

p / 1:
label(1):
	get_variable             2     a(1)     y(1) 
	put_global_variable_callf     a(1)     y(2)     get_bip_error / 1     Y[1,2] 
	move                     y(2)     a(1) 
	bi_minus                 a(1)     a(2)     4 
	bi_addi                  a(2)     1     a(3)     24 
	bi_add                   a(1)     a(2)     a(1)     16 
	get_value                a(1)     a(3) 
	bi_addi                  a(3)     -1     a(1)     24 
	bi_sub                   a(3)     a(2)     a(2)     16 
	get_value                a(2)     a(1) 
	put_integer              a(2)     2 
	bi_mul                   a(1)     a(2)     a(1)     16 
	put_integer              a(2)     2 
	bi_quot                  a(1)     a(2)     a(1)     16 
	put_integer              a(2)     2 
	bi_div                   a(1)     a(2)     a(1)     16 
	put_integer              a(2)     2 
	bi_rem                   a(1)     a(2)     a(1)     16 
	put_integer              a(2)     2 
	bi_fdiv                  a(1)     a(2)     a(1)     16 
	put_integer              a(2)     2 
	bi_mod                   a(1)     a(2)     a(1)     16 
	put_integer              a(2)     2 
	bi_and                   a(1)     a(2)     a(1)     16 
	put_integer              a(2)     2 
	bi_or                    a(1)     a(2)     a(1)     16 
	put_integer              a(2)     2 
	bi_xor                   a(1)     a(2)     a(1)     16 
	bi_bitnot                a(1)     a(1)     4 
	put_structure            a(2)     foo / 3 
	write_atom2              a     b 
	write_atom               c 
	bi_arity                 a(2)     a(2)     4 
	get_integer              a(2)     3 
	put_structure            a(2)     foo / 3 
	write_atom2              a     b 
	write_atom               c 
	bi_arg                   a(1)     a(2)     a(1)     16 
	get_value                a(1)     y(1) 
	exit                 

------ Test bip(1) -------
p(A, B) :-
	+(A, B, C),
	-(C, 1, D),
	p(D).

p / 2:
label(1):
	bi_add                   a(1)     a(2)     a(2)     16 
	bi_addi                  a(2)     -1     a(1)     24 
	jmp                      p / 1 

------ Test bip(2) -------
p(A, B) :-
	+(A, B, C),
	-(A, B, C).

p / 2:
label(1):
	bi_add                   a(1)     a(2)     a(3)     16 
	bi_sub                   a(1)     a(2)     a(1)     16 
	get_value                a(1)     a(3) 
	ret                  

------ Test bip(3) -------
p(A, B) :-
	+(A, B, 0).

p / 2:
label(1):
	bi_add                   a(1)     a(2)     a(1)     16 
	get_integer              a(1)     0 
	ret                  

------ Test bip(4) -------
p(A, B) :-
	+(A, B, foo(bar)).

p / 2:
label(1):
	bi_add                   a(1)     a(2)     a(1)     16 
	get_structure            a(1)     foo / 1     ref(2) 
	write_atom               bar 
	ret                  
label(2):
	read_atom                bar 
	ret                  

------ Test bip(5) -------
p(A, B) :-
	+(A, 1, B).

p / 2:
label(1):
	bi_addi                  a(1)     1     a(1)     24 
	get_value                a(1)     a(2) 
	ret                  

------ Test bip(6) -------
p(A, B) :-
	+(A, B, C),
	q,
	p(C).

p / 2:
label(1):
	bi_add                   a(1)     a(2)     a(1)     16 
	get_variable             1     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	move_chain               y(1)     a(1)     p / 1 

------ Test bip(7) -------
p(A, B) :-
	q,
	+(A, B, C),
	p(C).

p / 2:
label(1):
	get_variable             2     a(1)     y(1) 
	move                     a(2)     y(2) 
	callf                    q / 0     Y[1,2] 
	move                     2     y(1)     a(2) 
	bi_add                   a(2)     a(3)     a(1)     16 
	chain                    p / 1 

------ Test bip(8) -------
p(A, B) :-
	q(C),
	+(A, B, C),
	p(C).

p / 2:
label(1):
	get_variable             3     a(1)     y(1) 
	move                     a(2)     y(2) 
	put_global_variable_callf     a(1)     y(3)     q / 1     Y[1,2,3] 
	move                     2     y(1)     a(2) 
	bi_add                   a(2)     a(3)     a(2)     16 
	get_value                a(2)     y(3) 
	move_chain               y(3)     a(1)     p / 1 

------ Test bip(9) -------
p(A, B) :-
	q(C),
	+(A, B, C),
	-(A, B, C),
	p(C).

p / 2:
label(1):
	get_variable             3     a(1)     y(1) 
	move                     a(2)     y(2) 
	put_global_variable_callf     a(1)     y(3)     q / 1     Y[1,2,3] 
	move                     2     y(1)     a(2) 
	bi_add                   a(2)     a(3)     a(4)     16 
	get_value                a(4)     y(3) 
	bi_sub                   a(2)     a(3)     a(2)     16 
	get_value                a(2)     y(3) 
	move_chain               y(3)     a(1)     p / 1 

------ Test bip(10) -------
p(A, B) :-
	+(A, B, C).

p / 2:
label(1):
	bi_add                   a(1)     a(2)     a(1)     16 
	ret                  

------ Test bip(20) -------
p(A, B) :-
	A > B.

p / 2:
label(1):
	bi_gt                    a(1)     a(2)     eclipse     48 
	ret                  

------ Test inline(1) -------
:- inline(i1 / 1).
i1(1).
i1(2).
p(A) :-
	i1(A).
q(A) :-
	r,
	i1(A),
	s.

:- inline(i1 / 1).
INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
i1 / 1:
label(1):
	integer_switch           a(1) 
		1: 	ref(7)
		2: 	ref(8)
		default: 	ref(fail)

label(2):
	try_me_else              0     1     ref(4) 
label(3):
	get_integer              a(1)     1 
label(7):
	ret                  
label(4):
	trust_me                 0 
label(5):
	get_integer              a(1)     2 
label(8):
	ret                  
INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
p / 1:
label(1):
	integer_switch           a(1) 
		1: 	ref(7)
		2: 	ref(8)
		default: 	ref(fail)

label(2):
	try_me_else              0     1     ref(4) 
label(3):
	get_integer              a(1)     1 
label(7):
	ret                  
label(4):
	trust_me                 0 
label(5):
	get_integer              a(1)     2 
label(8):
	ret                  
INDEXES for (nondet) disjunction [3]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [3]
    Branch 1: try
    Branch 2: trust
q / 1:
label(1):
	get_variable             1     a(1)     y(1) 
	callf                    r / 0     Y[1] 
	integer_switch           y(1) 
		1: 	ref(4)
		2: 	ref(6)
		default: 	ref(fail)

label(3):
	try_me_else              0     0     ref(5) 
label(4):
	move                     y(1)     a(1) 
	get_integer              a(1)     1 
	chain                    s / 0 
label(5):
	trust_me_inline          0     Y[1] 
label(6):
	move                     y(1)     a(1) 
	get_integer              a(1)     2 
	chain                    s / 0 

------ Test inline(2) -------
:- inline(i2 / 1).
i2(A) :-
	r(A),
	!.
i2(A) :-
	s.
p(A) :-
	q,
	i2(A),
	t(A).

:- inline(i2 / 1).
i2 / 1:
label(1):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     1     ref(3) 
label(2):
	callf                    r / 1     Y[1] 
	cut                      y(1)     0 
	exit                 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	chain                    s / 0 
p / 1:
label(1):
	get_variable             2     a(1)     y(1) 
	callf                    q / 0     Y[1] 
	savecut                  y(2) 
	try_me_else              0     0     ref(3) 
label(2):
	move_callf               y(1)     a(1)     r / 1     Y[1,2] 
	cut                      y(2)     1 
	move_chain               y(1)     a(1)     t / 1 
label(3):
	trust_me_inline          0     Y[1] 
label(4):
	callf                    s / 0     Y[1] 
	move_chain               y(1)     a(1)     t / 1 

------ Test bench(1) -------
conc([], A, A).
conc([A|B], C, [A|D]) :-
	conc(B, C, D).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [list] - [2]
    [[]] - [1]
    [var] - [1, 2]
2. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
conc / 3:
label(1):
	list_switch              a(1)     ref(7)     ref(12)     ref(fail) 
	list_switch              a(3)     ref(3)     ref(4)     ref(4) 
label(3):
	try_me_else              0     3     ref(5) 
label(4):
	get_nil                  a(1) 
label(12):
	get_value                a(3)     a(2) 
	ret                  
label(5):
	trust_me                 0 
label(6):
	get_list                 a(1)     ref(7) 
	write_variable2          a(4)     a(1) 
	branch                   ref(8) 
label(7):
	read_variable2           a(4)     a(1) 
label(8):
	get_list                 a(3)     ref(9) 
	write_value              a(4) 
	write_variable           a(3) 
	jmp                      ref(1) 
label(9):
	read_value               a(4) 
	read_variable            a(3) 
	jmp                      ref(1) 

------ Test bench(2) -------
conc(A, B, C) :-
	(
	    A = [],
	    B = D,
	    C = D
	;
	    A = [E|F],
	    B = D,
	    C = [E|G],
	    conc(F, D, G)
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [list] - [2]
    [[]] - [1]
    [var] - [1, 2]
2. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
conc / 3:
label(1):
	list_switch              a(1)     ref(7)     ref(12)     ref(fail) 
	list_switch              a(3)     ref(3)     ref(4)     ref(4) 
label(3):
	try_me_else              0     3     ref(5) 
label(4):
	get_nil                  a(1) 
label(12):
	move                     a(2)     a(1) 
	get_value                a(3)     a(1) 
	ret                  
label(5):
	trust_me                 0 
label(6):
	get_list                 a(1)     ref(7) 
	write_variable2          a(4)     a(1) 
	branch                   ref(8) 
label(7):
	read_variable2           a(4)     a(1) 
label(8):
	get_list                 a(3)     ref(9) 
	write_value              a(4) 
	write_variable           a(3) 
	jmp                      ref(1) 
label(9):
	read_value               a(4) 
	read_variable            a(3) 
	jmp                      ref(1) 

------ Test bench(3) -------
conc(A, B, C) :-
	(
	    A = [D|E],
	    B = F,
	    C = [D|G],
	    conc(E, F, G)
	;
	    A = [],
	    B = F,
	    C = F
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [2]
    [list] - [1]
    [var] - [1, 2]
2. Quality 1.5
    [] - [2]
    [list] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
conc / 3:
label(1):
	list_switch              a(1)     ref(5)     ref(12)     ref(fail) 
	list_switch              a(3)     ref(3)     ref(10)     ref(10) 
label(3):
	try_me_else              0     3     ref(9) 
label(4):
	get_list                 a(1)     ref(5) 
	write_variable2          a(4)     a(1) 
	branch                   ref(6) 
label(5):
	read_variable2           a(4)     a(1) 
label(6):
	get_list                 a(3)     ref(7) 
	write_value              a(4) 
	write_variable           a(3) 
	jmp                      ref(1) 
label(7):
	read_value               a(4) 
	read_variable            a(3) 
	jmp                      ref(1) 
label(9):
	trust_me                 0 
label(10):
	get_nil                  a(1) 
label(12):
	move                     a(2)     a(1) 
	get_value                a(3)     a(1) 
	ret                  

------ Test bench(4) -------
conc(e(A), B, B).
conc(f(A, B), C, f(A, D)) :-
	conc(B, C, D).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [structure] - []
    [structure, e / 1] - [1]
    [structure, f / 2] - [2]
    [var] - [1, 2]
2. Quality 1.5
    [] - [1]
    [structure] - [1]
    [structure, f / 2] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
conc / 3:
label(1):
	functor_switch           a(1) 
		e / 1: 	ref(6)
		f / 2: 	ref(9)
		default: 	ref(fail)

	functor_switch           a(3) 
		f / 2: 	ref(4)
		default: 	ref(5)

label(4):
	try_me_else              0     3     ref(7) 
label(5):
	get_structure            a(1)     e / 1     ref(6) 
	write_void           
label(6):
	get_value                a(3)     a(2) 
	ret                  
label(7):
	trust_me                 0 
label(8):
	get_structure            a(1)     f / 2     ref(9) 
	write_variable2          a(4)     a(1) 
	branch                   ref(10) 
label(9):
	read_variable2           a(4)     a(1) 
label(10):
	get_structure            a(3)     f / 2     ref(11) 
	write_value              a(4) 
	write_variable           a(3) 
	jmp                      ref(1) 
label(11):
	read_value               a(4) 
	read_variable            a(3) 
	jmp                      ref(1) 

------ Test bench(5) -------
conc(A, B, C) :-
	(
	    A = e(D),
	    B = E,
	    C = E
	;
	    A = f(F, G),
	    B = E,
	    C = f(F, H),
	    conc(G, E, H)
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [structure] - []
    [structure, e / 1] - [1]
    [structure, f / 2] - [2]
    [var] - [1, 2]
2. Quality 1.5
    [] - [1]
    [structure] - [1]
    [structure, f / 2] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
conc / 3:
label(1):
	functor_switch           a(1) 
		e / 1: 	ref(6)
		f / 2: 	ref(9)
		default: 	ref(fail)

	functor_switch           a(3) 
		f / 2: 	ref(4)
		default: 	ref(5)

label(4):
	try_me_else              0     3     ref(7) 
label(5):
	get_structure            a(1)     e / 1     ref(6) 
	write_void           
label(6):
	move                     a(2)     a(1) 
	get_value                a(3)     a(1) 
	ret                  
label(7):
	trust_me                 0 
label(8):
	get_structure            a(1)     f / 2     ref(9) 
	write_variable2          a(4)     a(1) 
	branch                   ref(10) 
label(9):
	read_variable2           a(4)     a(1) 
label(10):
	get_structure            a(3)     f / 2     ref(11) 
	write_value              a(4) 
	write_variable           a(3) 
	jmp                      ref(1) 
label(11):
	read_value               a(4) 
	read_variable            a(3) 
	jmp                      ref(1) 

------ Test bench(6) -------
conc([], A, B) :-
	!,
	A = B.
conc([A|B], C, [A|D]) :-
	conc(B, C, D).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [list] - [2]
    [[]] - [1]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
conc / 3:
label(1):
	list_switch              a(1)     ref(6)     ref(11)     ref(fail) 
label(3):
	get_nil                  a(1) 
label(11):
	get_value                a(2)     a(3) 
	ret                  
label(6):
	read_variable2           a(4)     a(1) 
label(7):
	get_list                 a(3)     ref(8) 
	write_value              a(4) 
	write_variable           a(3) 
	jmp                      ref(1) 
label(8):
	read_value               a(4) 
	read_variable            a(3) 
	jmp                      ref(1) 

------ Test bench(7) -------
conc([], A, B) :-
	t,
	!,
	A = B.
conc([A|B], C, [A|D]) :-
	conc(B, C, D).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [list] - [2]
    [[]] - [1]
    [var] - [1, 2]
2. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
conc / 3:
label(1):
	allocate                 3 
	savecut                  y(1) 
	list_switch              a(1)     ref(7)     ref(12)     ref(fail) 
	list_switch              a(3)     ref(3)     ref(4)     ref(4) 
label(3):
	try_me_else              0     3     ref(5) 
label(4):
	get_nil                  a(1) 
label(12):
	move                     2     a(2)     y(2) 
	callf                    t / 0     Y[1,2,3] 
	cut                      y(1)     3 
	get_value                y(2)     y(3) 
	exit                 
label(5):
	trust_me_inline          0     Y[] 
label(6):
	get_list                 a(1)     ref(7) 
	write_variable2          a(4)     a(1) 
	branch                   ref(8) 
label(7):
	read_variable2           a(4)     a(1) 
label(8):
	get_list                 a(3)     ref(9) 
	write_value              a(4) 
	write_variable           a(3) 
	chain                    ref(1) 
label(9):
	read_value               a(4) 
	read_variable            a(3) 
	chain                    ref(1) 

------ Test bench(tak) -------
tak(A, B, C, D) :-
	(
	    A =< B
	->
	    C = D
	;
	    E is A - 1,
	    tak(E, B, C, F),
	    G is B - 1,
	    tak(G, C, A, H),
	    I is C - 1,
	    tak(I, A, B, J),
	    tak(F, H, J, D)
	).

tak / 4:
label(1):
	savecut                  a(5) 
	try_me_else              0     5     ref(3) 
label(2):
	bi_le                    a(1)     a(2)     eclipse     48 
	cut                      a(5) 
	get_value                a(3)     a(4) 
	ret                  
label(3):
	trust_me                 0 
label(4):
	bi_addi                  a(1)     -1     a(5)     24 
	get_variable             7     a(1)     y(5) 
	move                     2     a(2)     y(6) 
	move                     a(4)     y(3) 
	put_global_variable      a(4)     y(4) 
	move                     a(5)     a(1) 
	callf                    ref(1)     Y[3,4,5,6,7] 
	move                     y(6)     a(5) 
	bi_addi                  a(5)     -1     a(1)     24 
	put_global_variable      a(4)     y(2) 
	move                     y(7)     a(2)     y(5)     a(3) 
	callf                    ref(1)     Y[2,3,4,5,6,7] 
	move                     y(7)     a(5) 
	bi_addi                  a(5)     -1     a(1)     24 
	put_global_variable      a(4)     y(1) 
	move                     2     y(5)     a(2) 
	callf                    ref(1)     Y[1,2,3,4] 
	move                     y(4)     a(1)     y(2)     a(2)     y(1)     a(3) 
	move_chain               y(3)     a(4)     ref(1) 

------ Test bench(takc) -------
tak(A, B, C, D) :-
	A =< B,
	!,
	C = D.
tak(A, B, C, D) :-
	E is A - 1,
	tak(E, B, C, F),
	G is B - 1,
	tak(G, C, A, H),
	I is C - 1,
	tak(I, A, B, J),
	tak(F, H, J, D).

tak / 4:
label(1):
	savecut                  a(5) 
	try_me_else              0     5     ref(3) 
label(2):
	bi_le                    a(1)     a(2)     eclipse     48 
	cut                      a(5) 
	get_value                a(3)     a(4) 
	ret                  
label(3):
	trust_me                 0 
label(4):
	bi_addi                  a(1)     -1     a(5)     24 
	get_variable             7     a(1)     y(5) 
	move                     2     a(2)     y(6) 
	move                     a(4)     y(3) 
	put_global_variable      a(4)     y(4) 
	move                     a(5)     a(1) 
	callf                    ref(1)     Y[3,4,5,6,7] 
	move                     y(6)     a(5) 
	bi_addi                  a(5)     -1     a(1)     24 
	put_global_variable      a(4)     y(2) 
	move                     y(7)     a(2)     y(5)     a(3) 
	callf                    ref(1)     Y[2,3,4,5,6,7] 
	move                     y(7)     a(5) 
	bi_addi                  a(5)     -1     a(1)     24 
	put_global_variable      a(4)     y(1) 
	move                     2     y(5)     a(2) 
	callf                    ref(1)     Y[1,2,3,4] 
	move                     y(4)     a(1)     y(2)     a(2)     y(1)     a(3) 
	move_chain               y(3)     a(4)     ref(1) 

------ Test bug(1) -------
simplify_code([], []).
simplify_code([code(A, B, C)|D], E) :-
	(
	    simplify(A, D, F)
	->
	    simplify_code(F, E)
	;
	    E = [A|F],
	    simplify_code(D, F)
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [list] - [2]
    [[]] - [1]
    [var] - [1, 2]
2. Quality 1.5
    [] - [2]
    [[]] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
INDEXES for (nondet) disjunction [2, 2, 2]
1. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2, 2, 2]
    Branch 1: try
    Branch 2: trust
simplify_code / 2:
label(1):
	list_switch              a(1)     ref(8)     ref(18)     ref(fail) 
	list_switch              a(2)     ref(6)     ref(3)     ref(6) 
label(3):
	try_me_else              0     2     ref(5) 
label(4):
	get_nil                  a(1) 
label(18):
	get_nil                  a(2) 
	ret                  
label(5):
	trust_me                 0 
label(6):
	get_list                 a(1)     ref(8) 
	write_first_structure     code / 3 
label(7):
	write_variable           a(3) 
	write_void               2 
	mode                     t(0)     ref(9) 
	write_variable           a(1) 
	branch                   ref(10) 
label(8):
	read_structure           code / 3     ref(7) 
	read_variable            a(3) 
	mode                     t(0) 
label(9):
	read_variable            a(1) 
label(10):
	space                    -1 
	allocate                 3 
	savecut                  y(1) 
	list_switch              a(2)     ref(11)     ref(12)     ref(12) 
label(11):
	try_me_else              0     3     ref(13) 
label(12):
	move                     a(2)     y(2) 
	shift                    a(2)     a(1)     a(3) 
	put_global_variable_callf     a(3)     y(3)     simplify / 3     Y[1,2,3] 
	cut                      y(1)     3 
	move                     y(3)     a(1)     y(2)     a(2) 
	chain                    ref(1) 
label(13):
	trust_me_inline          0     Y[] 
label(14):
	get_list                 a(2)     ref(15) 
	write_value              a(3) 
	write_variable           a(2) 
	chain                    ref(1) 
label(15):
	read_value               a(3) 
	read_variable            a(2) 
	chain                    ref(1) 

------ Test bug(2) -------
loop(A) :-
	(
	    foreach(B, A)
	do
	    writeln(B)
	).

loop / 1:
label(1):
	jmp                      do__2 / 1 

------ Test bug(3) -------
p(A, B, C) :-
	(
	    A = B
	->
	    C = foo
	;
	    else
	).

p / 3:
label(1):
	savecut                  a(4) 
	try_me_else              0     4     ref(3) 
label(2):
	get_value                a(1)     a(2) 
	cut                      a(4) 
	get_atom                 a(3)     foo 
	ret                  
label(3):
	trust_me                 0 
label(4):
	jmp                      (else) / 0 

------ Test bug(4) -------
p(A, B, C) :-
	(
	    A == B
	->
	    D = temp,
	    C = E
	;
	    C = [F|E]
	).

p / 3:
label(1):
	savecut                  a(4) 
	try_me_else              0     4     ref(3) 
label(2):
	get_matched_value        a(1)     a(2) 
	cut                      a(4) 
	ret                  
label(3):
	trust_me                 0 
label(4):
	get_list                 a(3)     ref(5) 
	write_void               2 
	ret                  
label(5):
	ret                  

------ Test bug(5) -------
indexing_transformation([A|B], C) :-
	(
	    A = disjunction(D)
	->
	    then
	;
	    C = [E|F]
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [2]
    [structure] - [2]
    [structure, disjunction / 1] - [1]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
indexing_transformation / 2:
label(1):
	get_list                 a(1)     ref(2) 
	write_variable           a(1) 
	write_void           
	functor_switch           a(1) 
		disjunction / 1: 	ref(6)
		default: 	ref(8)

label(5):
	get_structure            a(1)     disjunction / 1     ref(6) 
	write_void           
label(6):
	jmp                      (then) / 0 
label(2):
	read_variable            a(1) 
	functor_switch           a(1) 
		disjunction / 1: 	ref(6)
		default: 	ref(8)

	branch                   ref(5) 
label(8):
	get_list                 a(2)     ref(9) 
	write_void               2 
label(9):
	ret                  

------ Test bug(6) -------
insert_after_head(A, B, C) :-
	(
	    B = [D|E],
	    D = goal(head, F)
	->
	    C = [D, A|E]
	;
	    C = [A|B]
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - [2]
    [list] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
insert_after_head / 3:
label(1):
	savecut                  a(4) 
	list_switch              a(2)     ref(2)     ref(11)     ref(11) 
label(2):
	try_me_else              0     4     ref(10) 
label(3):
	get_list                 a(2)     ref(4) 
	write_variable2          a(2)     a(5) 
	branch                   ref(5) 
label(4):
	read_variable2           a(2)     a(5) 
label(5):
	get_structure            a(2)     goal / 2     ref(6) 
	write_atom               head 
	write_void           
	branch                   ref(7) 
label(6):
	read_atom                head 
label(7):
	cut                      a(4) 
	get_list                 a(3)     ref(9) 
	write_value              a(2) 
	write_list           
label(8):
	write_value              a(1) 
	write_value              a(5) 
	ret                  
label(9):
	read_value               a(2) 
	read_last_list           ref(8) 
	read_value               a(1) 
	read_value               a(5) 
	ret                  
label(10):
	trust_me                 0 
label(11):
	get_list                 a(3)     ref(12) 
	write_value              a(1) 
	write_value              a(2) 
	ret                  
label(12):
	read_value               a(1) 
	read_value               a(2) 
	ret                  

------ Test bug(7) -------
declaration_warning_handler(A, B, lists) :-
	!.
declaration_warning_handler(A, B, profile) :-
	!.
declaration_warning_handler(75, A, B) :-
	!,
	get_flag_body(A, definition_module, C, B),
	get_deprecation_advice(A, C, D),
	!,
	warning_handler(75, A, B),
	printf(warning_output, " Advice: %w%n", [D]).
declaration_warning_handler(85, A : B, C) :-
	known_library(A),
	!.
declaration_warning_handler(A, B, C) :-
	warning_handler(A, B, C).

INDEXES for (nondet) disjunction [2]
1. Quality 1.7
    [] - [3, 4, 5]
    [atom] - [3, 4, 5]
    [atom, profile] - [2]
    [atom, lists] - [1]
    [var] - [1]
2. Quality 3.3
    [] - [1, 2, 5]
    [var] - [1, 2, 3]
    [integer] - [1, 2, 5]
    [integer, 85] - [1, 2, 4, 5]
    [integer, 75] - [1, 2, 3]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: try
    Branch 4: retry
    Branch 5: trust
declaration_warning_handler / 3:
label(1):
	savecut                  a(4) 
	atom_switch              a(3) 
		profile: 	ref(21)
		lists: 	ref(22)
		default: 	ref(17)

label(5):
	get_atom                 a(3)     lists 
label(22):
	ret                  
label(7):
	get_atom                 a(3)     profile 
label(21):
	ret                  
label(9):
	get_integer              a(1)     75 
	cut                      a(4) 
	get_variable             5     a(2)     y(2) 
	move                     2     a(3)     y(3) 
	put_atom                 a(2)     definition_module 
	put_global_variable      a(3)     y(5) 
	move                     y(2)     a(1)     y(3)     a(4) 
	callf                    get_flag_body / 4     Y[2,3,4,5] 
	put_global_variable      a(3)     y(1) 
	move                     y(2)     a(1)     y(5)     a(2) 
	callf                    get_deprecation_advice / 3     Y[1,2,3,4] 
	cut                      y(4)     3 
	put_integer              a(1)     75 
	move                     2     y(2)     a(2) 
	callf                    warning_handler / 3     Y[1] 
	put_list                 a(3) 
	push_value               y(1) 
	push_nil             
	put_atom                 a(1)     warning_output 
	put_string               a(2)     " Advice: %w%n" 
	put_module               a(4)     eclipse 
	chain                    sepia_kernel : printf_body / 4 
label(11):
	get_integer              a(1)     85 
	get_structure            a(2)     (:) / 2     ref(12) 
	write_variable           a(1) 
	write_void           
	branch                   ref(13) 
label(12):
	read_variable            a(1) 
label(13):
	get_variable             1     a(4)     y(1) 
	callf                    known_library / 1     Y[1] 
	cut                      y(1)     0 
	exit                 
label(15):
	jmp                      warning_handler / 3 
label(17):
	try                      0     4     ref(9) 
	retry                    0     ref(11) 
	trust                    0     ref(15) 

------ Test bug(8) -------
attach_suspensions(postponed, A) ?-
	!,
	postpone_suspensions(A).
attach_suspensions(A, B) :-
	atom(A),
	!,
	attach_suspensions1(A, B).
attach_suspensions(A, B) :-
	nonvar(A),
	!,
	error(5, attach_suspensions(A, B)).
attach_suspensions(A, B) :-
	error(4, attach_suspensions(A, B)).

INDEXES for (semidet) disjunction [2]
1. Quality 0.8
    [] - [4]
    [handle] - [3]
    [list] - [3]
    [[]] - [2]
    [structure] - [3]
    [atom] - [2]
    [atom, postponed] - [1]
    [rational] - [3]
    [integer] - [3]
    [breal] - [3]
    [bignum] - [3]
    [string] - [3]
    [double] - [3]
    [goal] - [3]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
    Branch 4: det
attach_suspensions / 2:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(9)
		[]: 	ref(12)
		atom: 	ref(11)
		bignum: 	ref(13)
		breal: 	ref(13)
		double: 	ref(13)
		goal: 	ref(13)
		handle: 	ref(13)
		integer: 	ref(13)
		list: 	ref(13)
		rational: 	ref(13)
		string: 	ref(13)
		structure: 	ref(13)

label(9):
	move                     a(2)     a(4) 
	put_structure            a(2)     attach_suspensions / 2 
	push_value               a(1) 
	push_value               a(4) 
	put_integer              a(1)     4 
	put_module               a(3)     eclipse 
	jmp                      sepia_kernel : error_ / 3 
label(3):
	in_get_atom              a(1)     postponed 
label(14):
	move                     a(2)     a(1) 
	jmp                      postpone_suspensions / 1 
label(5):
	bi_atom                  a(1) 
label(12):
	jmp                      attach_suspensions1 / 2 
label(7):
	bi_nonvar                a(1) 
label(13):
	move                     a(2)     a(4) 
	put_structure            a(2)     attach_suspensions / 2 
	push_value               a(1) 
	push_value               a(4) 
	put_integer              a(1)     5 
	put_module               a(3)     eclipse 
	jmp                      sepia_kernel : error_ / 3 
label(11):
	atom_switch              a(1) 
		postponed: 	ref(14)
		default: 	ref(5)


------ Test bug(9) -------
execute(A, B, C) :-
	(
	    [A|B] = C
	;
	    C = []
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [2]
    [list] - [1]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
execute / 3:
label(1):
	list_switch              a(3)     ref(4)     ref(8)     ref(fail) 
label(2):
	try_me_else              0     3     ref(5) 
label(3):
	get_list                 a(3)     ref(4) 
	write_value              a(1) 
	write_value              a(2) 
	ret                  
label(4):
	read_value               a(1) 
	read_value               a(2) 
	ret                  
label(5):
	trust_me                 0 
label(6):
	get_nil                  a(3) 
label(8):
	ret                  

------ Test bug(10) -------
do_x(0, [], A, A).
do_x(A, B, C, D) :-
	C is E + 1,
	F is A >> 1,
	(
	    A /\ 1 =:= 0
	->
	    B = G
	;
	    B = [E|G]
	),
	do_x(F, G, C, D).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - [2]
    [var] - [1, 2]
    [integer] - [2]
    [integer, 0] - [1, 2]
2. Quality 1.5
    [] - [2]
    [[]] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
INDEXES for (nondet) disjunction [2, 2, 3]
1. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2, 2, 3]
    Branch 1: try
    Branch 2: trust
do_x / 4:
label(1):
	integer_switch           a(1) 
		0: 	ref(3)
		default: 	ref(7)

label(3):
	list_switch              a(2)     ref(7)     ref(4)     ref(7) 
label(4):
	try_me_else              0     4     ref(6) 
label(5):
	get_integer              a(1)     0 
	get_nil                  a(2) 
	get_value                a(4)     a(3) 
	ret                  
label(6):
	trust_me                 0 
label(7):
	allocate                 7 
	put_global_variable      a(5)     y(7) 
	bi_addi                  a(5)     1     a(5)     24 
	get_value                a(5)     a(3) 
	move                     2     a(1)     y(5) 
	move                     2     a(3)     y(2) 
	put_integer              a(2)     1 
	put_global_variable_callf     a(3)     y(4)     sepia_kernel : (>>) / 3     Y[2,3,4,5,6,7] 
	savecut                  a(1) 
	list_switch              y(6)     ref(8)     ref(9)     ref(9) 
label(8):
	try_me_else              0     1     ref(10) 
label(9):
	put_integer              a(2)     1 
	move                     y(5)     a(3) 
	bi_and                   a(3)     a(2)     a(2)     16 
	put_integer              a(3)     0 
	bi_eq                    a(2)     a(3)     eclipse     48 
	cut                      a(1)     6 
	move                     y(6)     y(1) 
	branch                   ref(13) 
label(10):
	trust_me_inline          0     Y[2,3,4,6,7] 
label(11):
	move                     y(6)     a(1) 
	get_list                 a(1)     ref(12) 
	write_value              y(7) 
	write_variable           y(1) 
	branch                   ref(13) 
label(12):
	read_value               y(7) 
	read_variable            y(1) 
label(13):
	move                     y(4)     a(1) 
	move                     3     y(1)     a(2) 
	chain                    ref(1) 

------ Test bug(11) -------
add_incoming(A, B, C, D) :-
	arg(A, C, E),
	(
	    var(E)
	->
	    arg(A, B, E),
	    do__N(E, D, B, C, D)
	;
	    true
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [2]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
add_incoming / 4:
label(1):
	bi_arg                   a(1)     a(3)     a(5)     16 
	switch_on_type           a(5) 
		meta: 	ref(6)
		[]: 	ref(5)
		atom: 	ref(5)
		bignum: 	ref(5)
		breal: 	ref(5)
		double: 	ref(5)
		goal: 	ref(5)
		handle: 	ref(5)
		integer: 	ref(5)
		list: 	ref(5)
		rational: 	ref(5)
		string: 	ref(5)
		structure: 	ref(5)

	branch                   ref(6) 
label(3):
	bi_var                   a(5) 
label(6):
	bi_arg                   a(1)     a(2)     a(6)     16 
	get_value                a(6)     a(5) 
	move                     a(5)     a(1) 
	rot                      a(3)     a(2)     a(4) 
	move                     a(2)     a(5) 
	jmp                      do__N / 5 
label(5):
	ret                  

------ Test bug(12) -------
i_np_head0(np_head(A), B - C, B - C, void).
i_np_head0(name(A), B - A, B - A, id).
i_np_head0(wh(A), A, A, id).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - []
    [structure] - []
    [structure, name / 1] - [2]
    [structure, wh / 1] - [3]
    [structure, np_head / 1] - [1]
    [var] - [1, 2, 3]
2. Quality 2.0
    [] - [3]
    [structure] - [3]
    [structure, - / 2] - [1, 2, 3]
    [var] - [1, 2, 3]
3. Quality 2.0
    [] - [3]
    [structure] - [3]
    [structure, - / 2] - [1, 2, 3]
    [var] - [1, 2, 3]
4. Quality 2.0
    [] - []
    [atom] - []
    [atom, id] - [2, 3]
    [atom, void] - [1]
    [var] - [1, 2, 3]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: retry
    Branch 3: trust
i_np_head0 / 4:
label(1):
	functor_switch           a(1) 
		name / 1: 	ref(15)
		wh / 1: 	ref(23)
		np_head / 1: 	ref(8)
		default: 	ref(fail)

	functor_switch           a(2) 
		(-) / 2: 	ref(4)
		default: 	ref(22)

label(4):
	functor_switch           a(3) 
		(-) / 2: 	ref(5)
		default: 	ref(22)

	atom_switch              a(4) 
		id: 	ref(26)
		void: 	ref(7)
		default: 	ref(fail)

label(6):
	try_me_else              0     4     ref(13) 
label(7):
	get_structure            a(1)     np_head / 1     ref(8) 
	write_void           
label(8):
	get_structure            a(2)     (-) / 2     ref(9) 
	write_variable2          a(1)     a(2) 
	branch                   ref(10) 
label(9):
	read_variable2           a(1)     a(2) 
label(10):
	get_structure            a(3)     (-) / 2     ref(11) 
	write_value              a(1) 
	write_value              a(2) 
	get_atom                 a(4)     void 
	ret                  
label(11):
	read_value               a(1) 
	read_value               a(2) 
	get_atom                 a(4)     void 
	ret                  
label(13):
	retry_me_else            0     ref(21) 
label(14):
	get_structure            a(1)     name / 1     ref(15) 
	write_variable           a(1) 
	branch                   ref(16) 
label(15):
	read_variable            a(1) 
label(16):
	get_structure            a(2)     (-) / 2     ref(17) 
	write_variable           a(2) 
	write_value              a(1) 
	branch                   ref(18) 
label(17):
	read_variable            a(2) 
	read_value               a(1) 
label(18):
	get_structure            a(3)     (-) / 2     ref(19) 
	write_value              a(2) 
	write_value              a(1) 
	get_atom                 a(4)     id 
	ret                  
label(19):
	read_value               a(2) 
	read_value               a(1) 
	get_atom                 a(4)     id 
	ret                  
label(21):
	trust_me                 0 
label(22):
	get_structure            a(1)     wh / 1     ref(23) 
	write_value              a(2) 
	get_value                a(3)     a(2) 
	get_atom                 a(4)     id 
	ret                  
label(23):
	read_value               a(2) 
	get_value                a(3)     a(2) 
	get_atom                 a(4)     id 
	ret                  
label(26):
	try                      0     4     ref(14) 
	trust                    0     ref(22) 
label(5):
	atom_switch              a(4) 
		id: 	ref(26)
		void: 	ref(7)
		default: 	ref(fail)

	branch                   ref(6) 

------ Test bugzilla(68) -------
xgt0(pinf) :-
	!.
xgt0(A) :-
	integer(A),
	A > 0.

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - []
    [atom] - []
    [atom, pinf] - [1]
    [var] - [1]
    [integer] - [2]
    [bignum] - [2]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
xgt0 / 1:
label(1):
	switch_on_type           a(1) 
		meta: 	ref(3)
		[]: 	ref(fail)
		atom: 	ref(3)
		bignum: 	ref(7)
		breal: 	ref(fail)
		double: 	ref(fail)
		goal: 	ref(fail)
		handle: 	ref(fail)
		integer: 	ref(7)
		list: 	ref(fail)
		rational: 	ref(fail)
		string: 	ref(fail)
		structure: 	ref(fail)

label(3):
	get_atom                 a(1)     pinf 
	ret                  
label(5):
	bi_integer               a(1) 
label(7):
	put_integer              a(2)     0 
	bi_gt                    a(1)     a(2)     eclipse     48 
	ret                  

------ Test bugzilla(165) -------
compute_stop(A) :-
	var(A),
	!,
	writeln(var).
compute_stop(1) :-
	!,
	writeln(1).
compute_stop(-1) :-
	!,
	writeln(-1).
compute_stop(A) :-
	integer(A),
	A > 1,
	!,
	writeln(pos).
compute_stop(A) :-
	integer(A),
	A < 0,
	!,
	writeln(neg).
compute_stop(A) :-
	writeln(other).

INDEXES for (nondet) disjunction [2]
1. Quality 1.4
    [] - [6]
    [var] - [1]
    [bignum] - [4, 5, 6]
    [integer] - [4, 5, 6]
    [integer, 1] - [2]
    [integer, -1] - [3]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
    Branch 4: try
    Branch 5: retry
    Branch 6: trust
compute_stop / 1:
label(1):
	savecut                  a(2) 
	switch_on_type           a(1) 
		meta: 	ref(17)
		[]: 	ref(13)
		atom: 	ref(13)
		bignum: 	ref(15)
		breal: 	ref(13)
		double: 	ref(13)
		goal: 	ref(13)
		handle: 	ref(13)
		integer: 	ref(16)
		list: 	ref(13)
		rational: 	ref(13)
		string: 	ref(13)
		structure: 	ref(13)

	branch                   ref(17) 
label(3):
	bi_var                   a(1) 
label(17):
	put_atom                 a(1)     var 
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : writeln_body / 2 
label(5):
	get_integer              a(1)     1 
label(18):
	put_integer              a(1)     1 
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : writeln_body / 2 
label(7):
	get_integer              a(1)     -1 
label(19):
	put_integer              a(1)     -1 
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : writeln_body / 2 
label(9):
	bi_integer               a(1) 
	put_integer              a(3)     1 
	bi_gt                    a(1)     a(3)     eclipse     48 
	cut                      a(2) 
	put_atom                 a(1)     pos 
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : writeln_body / 2 
label(11):
	bi_integer               a(1) 
	put_integer              a(3)     0 
	bi_lt                    a(1)     a(3)     eclipse     48 
	cut                      a(2) 
	put_atom                 a(1)     neg 
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : writeln_body / 2 
label(13):
	put_atom                 a(1)     other 
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : writeln_body / 2 
label(15):
	try                      0     2     ref(9) 
	retry                    0     ref(11) 
	trust                    0     ref(13) 
label(16):
	integer_switch           a(1) 
		1: 	ref(18)
		-1: 	ref(19)
		default: 	ref(15)


------ Test bugzilla(408) -------
dan :-
	A = B,
	A = 2,
	write(B).
b :-
	a,
	A = 2,
	B = 3,
	writeln(A),
	c(B).

dan / 0:
label(1):
	put_variable             a(3) 
	move                     a(3)     a(1) 
	get_integer              a(3)     2 
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : write_ / 2 
b / 0:
label(1):
	allocate                 1 
	callf                    a / 0     Y[] 
	put_integer              a(1)     2 
	put_integer              a(3)     3 
	move                     a(3)     y(1) 
	put_module               a(2)     eclipse 
	callf                    sepia_kernel : writeln_body / 2     Y[1] 
	move_chain               y(1)     a(1)     c / 1 

------ Test bugzilla(642) -------
q(A, B) :-
	equal([A], [C]),
	(
	    C = b,
	    B = 1
	->
	    then
	;
	    else
	).

INDEXES for (nondet) disjunction [3]
1. Quality 1.5
    [] - [2]
    [var] - [1, 2]
    [integer] - [2]
    [integer, 1] - [1, 2]
2. Quality 1.5
    [] - [2]
    [atom] - [2]
    [atom, b] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [3]
    Branch 1: try
    Branch 2: trust
q / 2:
label(1):
	get_variable             2     a(2)     y(1) 
	move                     a(1)     a(3) 
	put_list                 a(1) 
	push_value               a(3) 
	push_nil             
	put_list                 a(2) 
	push_variable            y(2) 
	push_nil             
	callf                    equal / 2     Y[1,2] 
	savecut                  a(1) 
	integer_switch           y(1) 
		1: 	ref(3)
		default: 	ref(7)

label(3):
	atom_switch              y(2) 
		b: 	ref(4)
		default: 	ref(7)

label(4):
	try_me_else              0     1     ref(6) 
label(5):
	move                     y(2)     a(2) 
	get_atom                 a(2)     b 
	move                     y(1)     a(2) 
	get_integer              a(2)     1 
	cut                      a(1)     0 
	chain                    (then) / 0 
label(6):
	trust_me_inline          0     Y[] 
label(7):
	chain                    (else) / 0 

------ Test bugzilla(727) -------
p1 :-
	A = f(B),
	t,
	writeln(B).
p2 :-
	A = f(B),
	writeln(B).

p1 / 0:
label(1):
	allocate                 1 
	put_global_variable      y(1) 
	callf                    t / 0     Y[1] 
	put_module               a(2)     eclipse 
	move_chain               y(1)     a(1)     sepia_kernel : writeln_body / 2 
p2 / 0:
label(1):
	put_variable             a(1) 
	put_module               a(2)     eclipse 
	jmp                      sepia_kernel : writeln_body / 2 

------ Test bugzilla(774) -------
p1 :-
	(
	    A = A
	;
	    true
	),
	writeln(A).

p1 / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 1 
	put_global_variable      y(1) 
label(5):
	put_module               a(2)     eclipse 
	move_chain               y(1)     a(1)     sepia_kernel : writeln_body / 2 
label(3):
	trust_me                 0 
label(4):
	allocate                 1 
	gc_test                  1 
	put_global_variable      y(1) 
	branch                   ref(5) 

------ Test at1 -------
at1 :-
	var(f(A)),
	A == a,
	q(A, f(A)).

at1 / 0:
label(1):
	put_structure            a(3)     f / 1 
	push_variable            a(1) 
	bi_var                   a(3) 
	in_get_atom              a(1)     a 
	put_structure            a(2)     f / 1 
	push_value               a(1) 
	jmp                      q / 2 

------ Test at2 -------
at2 :-
	f(A) == f(B),
	A == B,
	q(A, B).

at2 / 0:
label(1):
	put_structure            a(3)     f / 1 
	push_variable            a(1) 
	put_structure            a(4)     f / 1 
	push_variable            a(2) 
	get_matched_value        a(3)     a(4) 
	get_matched_value        a(1)     a(2) 
	jmp                      q / 2 

------ Test at3 -------
at3 :-
	f(A) == f(B),
	A == B,
	q(f(A), f(B)).

at3 / 0:
label(1):
	put_structure            a(3)     f / 1 
	push_variable            a(4) 
	put_structure            a(5)     f / 1 
	push_variable            a(6) 
	get_matched_value        a(3)     a(5) 
	get_matched_value        a(4)     a(6) 
	put_structure            a(1)     f / 1 
	push_value               a(4) 
	put_structure            a(2)     f / 1 
	push_value               a(6) 
	jmp                      q / 2 

------ Test at4 -------
at4 :-
	q,
	f(A) == f(B),
	A == B,
	q(A, B).

at4 / 0:
label(1):
	allocate                 0 
	callf                    q / 0     Y[] 
	put_structure            a(3)     f / 1 
	push_variable            a(1) 
	put_structure            a(4)     f / 1 
	push_variable            a(2) 
	get_matched_value        a(3)     a(4) 
	get_matched_value        a(1)     a(2) 
	chain                    q / 2 

------ Test ag1 -------
ag1 :-
	*(f(A), f(A), f(A)).

ag1 / 0:
label(1):
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	put_structure            a(3)     f / 1 
	push_value               a(2) 
	bi_mul                   a(1)     a(3)     a(1)     16 
	get_structure            a(1)     f / 1     ref(2) 
	write_value              a(2) 
	ret                  
label(2):
	read_value               a(2) 
	ret                  

------ Test ag2 -------
ag2 :-
	*(A, A, f(A)).

ag2 / 0:
label(1):
	put_variable             a(1) 
	bi_mul                   a(1)     a(1)     a(2)     16 
	get_structure            a(2)     f / 1     ref(2) 
	write_value              a(1) 
	ret                  
label(2):
	read_value               a(1) 
	ret                  

------ Test ag3 -------
ag3 :-
	A == f(A),
	q(A).

ag3 / 0:
label(1):
	put_variable             a(1) 
	put_structure            a(2)     f / 1 
	push_value               a(1) 
	get_matched_value        a(1)     a(2) 
	jmp                      q / 1 

------ Test ag5 -------
ag5 :-
	p(f(A), f(A), f(A)).

ag5 / 0:
label(1):
	put_structure            a(1)     f / 1 
	push_variable            a(4) 
	put_structure            a(2)     f / 1 
	push_value               a(4) 
	put_structure            a(3)     f / 1 
	push_value               a(4) 
	jmp                      p / 3 

------ Test ag6 -------
ag6 :-
	p(A, A, f(A)),
	p(f(B), f(B)),
	p(C, f(C)),
	p(f(D), D).

ag6 / 0:
label(1):
	put_structure            a(3)     f / 1 
	push_variable            a(1) 
	allocate                 0 
	move                     a(1)     a(2) 
	callf                    p / 3     Y[] 
	put_structure            a(1)     f / 1 
	push_variable            a(3) 
	put_structure            a(2)     f / 1 
	push_value               a(3) 
	callf                    p / 2     Y[] 
	put_structure            a(2)     f / 1 
	push_variable            a(1) 
	callf                    p / 2     Y[] 
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	chain                    p / 2 

------ Test ag8 -------
ag8 :-
	A =.. [f, B, B],
	q(A).

ag8 / 0:
label(1):
	put_structure            a(1)     f / 2 
	push_variable            a(2) 
	push_value               a(2) 
	jmp                      q / 1 

------ Test am1 -------
am1 :-
	f(A) == A.

am1 / 0:
label(1):
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	get_matched_value        a(1)     a(2) 
	ret                  

------ Test am2 -------
am2 :-
	f(A) == A,
	q(A).

am2 / 0:
label(1):
	put_structure            a(2)     f / 1 
	push_variable            a(1) 
	get_matched_value        a(2)     a(1) 
	jmp                      q / 1 

------ Test am3 -------
am3 :-
	f(A) == A,
	q(A),
	r.

am3 / 0:
label(1):
	put_structure            a(2)     f / 1 
	push_variable            a(1) 
	get_matched_value        a(2)     a(1) 
	allocate                 0 
	callf                    q / 1     Y[] 
	chain                    r / 0 

------ Test am4 -------
am4 :-
	*(f(A), A, f(A)).

am4 / 0:
label(1):
	put_structure            a(1)     f / 1 
	push_variable            a(2) 
	bi_mul                   a(1)     a(2)     a(1)     16 
	get_structure            a(1)     f / 1     ref(2) 
	write_value              a(2) 
	ret                  
label(2):
	read_value               a(2) 
	ret                  

------ Test am5 -------
am5 :-
	p(A),
	*(f(A), A, f(A)),
	q(A).

am5 / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
	put_structure            a(2)     f / 1 
	push_value               y(1) 
	move                     y(1)     a(1) 
	bi_mul                   a(2)     a(1)     a(2)     16 
	get_structure            a(2)     f / 1     ref(2) 
	write_value              a(1) 
	chain                    q / 1 
label(2):
	read_value               a(1) 
	chain                    q / 1 

------ Test am6 -------
am6 :-
	var(A),
	*(A, f(A), A),
	q(A).

am6 / 0:
label(1):
	put_variable             a(1) 
	bi_var                   a(1) 
	put_structure            a(2)     f / 1 
	push_value               a(1) 
	bi_mul                   a(1)     a(2)     a(2)     16 
	get_value                a(2)     a(1) 
	jmp                      q / 1 

------ Test am7 -------
am7 :-
	p(A),
	*(f(A), A, f(A)),
	q(A).

am7 / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
	put_structure            a(2)     f / 1 
	push_value               y(1) 
	move                     y(1)     a(1) 
	bi_mul                   a(2)     a(1)     a(2)     16 
	get_structure            a(2)     f / 1     ref(2) 
	write_value              a(1) 
	chain                    q / 1 
label(2):
	read_value               a(1) 
	chain                    q / 1 

------ Test am8 -------
am8 :-
	p(A),
	*(A, f(A), A),
	q(A).

am8 / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
	put_structure            a(2)     f / 1 
	push_value               y(1) 
	move                     y(1)     a(1) 
	bi_mul                   a(1)     a(2)     a(2)     16 
	get_value                a(2)     a(1) 
	chain                    q / 1 

------ Test am9 -------
am9 :-
	var(A),
	f(A) == A,
	q(A).

am9 / 0:
label(1):
	put_variable             a(1) 
	bi_var                   a(1) 
	put_structure            a(2)     f / 1 
	push_value               a(1) 
	get_matched_value        a(2)     a(1) 
	jmp                      q / 1 

------ Test am10 -------
am10 :-
	p(A),
	var(A),
	f(A) == A,
	q(A).

am10 / 0:
label(1):
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     p / 1     Y[1] 
	move                     y(1)     a(1) 
	bi_var                   a(1) 
	put_structure            a(2)     f / 1 
	push_value               a(1) 
	get_matched_value        a(2)     a(1) 
	chain                    q / 1 

------ Test am11 -------
am11 :-
	var(A),
	f(A) == A.

am11 / 0:
label(1):
	put_variable             a(1) 
	bi_var                   a(1) 
	put_structure            a(2)     f / 1 
	push_value               a(1) 
	get_matched_value        a(2)     a(1) 
	ret                  

------ Test am12 -------
am12 :-
	var(A),
	A == f(A).

am12 / 0:
label(1):
	put_variable             a(1) 
	bi_var                   a(1) 
	put_structure            a(2)     f / 1 
	push_value               a(1) 
	get_matched_value        a(1)     a(2) 
	ret                  

------ Test am13 -------
am13 :-
	A == f(A).

am13 / 0:
label(1):
	put_variable             a(1) 
	put_structure            a(2)     f / 1 
	push_value               a(1) 
	get_matched_value        a(1)     a(2) 
	ret                  

------ Test am14 -------
am14 :-
	eq(A, B),
	f(A) == A.

am14 / 0:
label(1):
	put_variable             a(2) 
	allocate                 1 
	put_global_variable_callf     a(1)     y(1)     eq / 2     Y[1] 
	put_structure            a(1)     f / 1 
	push_value               y(1) 
	move                     y(1)     a(2) 
	get_matched_value        a(1)     a(2) 
	exit                 

------ Test disj1 -------
p :-
	(
	    var(A)
	->
	    b
	;
	    c
	).

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	jmp                      b / 0 
label(3):
	trust_me                 0 
label(4):
	jmp                      c / 0 

------ Test disj2 -------
p :-
	(
	    var(A)
	->
	    b
	;
	    (
		var(A)
	    ->
		c
	    ;
		d
	    )
	).

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	jmp                      b / 0 
label(3):
	retry_me_else            0     ref(5) 
label(4):
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	jmp                      c / 0 
label(5):
	trust_me                 0 
label(6):
	jmp                      d / 0 

------ Test disj3 -------
p :-
	(
	    var(A)
	->
	    var(B)
	;
	    var(C)
	).

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	put_variable             a(1) 
	bi_var                   a(1) 
	ret                  
label(3):
	trust_me                 0 
label(4):
	put_variable             a(1) 
	bi_var                   a(1) 
	ret                  

------ Test disj4 -------
p :-
	(
	    var(A)
	->
	    b
	;
	    c
	),
	e,
	f.

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	allocate                 0 
	callf                    b / 0     Y[] 
	callf                    e / 0     Y[] 
	chain                    f / 0 
label(3):
	trust_me                 0 
label(4):
	allocate                 0 
	callf                    c / 0     Y[] 
	callf                    e / 0     Y[] 
	chain                    f / 0 

------ Test disj5 -------
p :-
	(
	    var(A)
	->
	    b
	;
	    (
		var(A)
	    ->
		c
	    ;
		d
	    )
	),
	e,
	f.

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	allocate                 0 
	callf                    b / 0     Y[] 
	callf                    e / 0     Y[] 
	chain                    f / 0 
label(3):
	retry_me_else            0     ref(5) 
label(4):
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	allocate                 0 
	callf                    c / 0     Y[] 
	callf                    e / 0     Y[] 
	chain                    f / 0 
label(5):
	trust_me                 0 
label(6):
	allocate                 0 
	callf                    d / 0     Y[] 
	callf                    e / 0     Y[] 
	chain                    f / 0 

------ Test disj6 -------
p :-
	(
	    var(A)
	->
	    var(B)
	;
	    var(C)
	),
	e,
	f.

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	put_variable             a(1) 
	bi_var                   a(1) 
	allocate                 0 
	callf                    e / 0     Y[] 
	chain                    f / 0 
label(3):
	trust_me                 0 
label(4):
	put_variable             a(1) 
	bi_var                   a(1) 
	allocate                 0 
	callf                    e / 0     Y[] 
	chain                    f / 0 

------ Test disj7 -------
p :-
	(
	    var(A)
	;
	    var(B)
	),
	c,
	d.

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	put_variable             a(1) 
	bi_var                   a(1) 
	allocate                 0 
	callf                    c / 0     Y[] 
	chain                    d / 0 
label(3):
	trust_me                 0 
label(4):
	put_variable             a(1) 
	bi_var                   a(1) 
	allocate                 0 
	callf                    c / 0     Y[] 
	chain                    d / 0 

------ Test disj8 -------
p :-
	(
	    once t
	->
	    fail
	;
	    true
	).

p / 0:
label(1):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	savecut                  y(2) 
	callf                    t / 0     Y[1,2] 
	cut                      y(2)     1 
	cut                      y(1)     0 
	failure              
label(3):
	trust_me_inline          0     Y[] 
label(4):
	exit                 

------ Test disj8a -------
p :-
	(
	    once true
	->
	    fail
	;
	    true
	).

p / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	callf                    true / 0     Y[1,2] 
	cut                      y(2)     1 
	cut                      y(1)     0 
	failure              
label(3):
	trust_me                 0 
label(4):
	ret                  

------ Test disj9 -------
p :-
	q,
	once var(A),
	p.

p / 0:
label(1):
	allocate                 0 
	callf                    q / 0     Y[] 
	savecut                  a(1) 
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1)     0 
	chain                    ref(1) 

------ Test disj10 -------
p :-
	q,
	once var(A).

p / 0:
label(1):
	allocate                 0 
	callf                    q / 0     Y[] 
	savecut                  a(1) 
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1)     0 
	exit                 

------ Test disj11 -------
p :-
	(
	    (
		a,
		b
	    ->
		c
	    )
	->
	    q
	).

p / 0:
label(1):
	allocate                 2 
	savecut                  y(1) 
	savecut                  y(2) 
	callf                    a / 0     Y[1,2] 
	callf                    b / 0     Y[1,2] 
	cut                      y(2)     1 
	callf                    c / 0     Y[1] 
	cut                      y(1)     0 
	chain                    q / 0 

------ Test disj12 -------
p :-
	(
	    q,
	    var(A)
	->
	    true
	).

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	callf                    q / 0     Y[1] 
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     0 
	exit                 

------ Test disj13 -------
p :-
	q,
	var(A),
	!,
	p(A).

p / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	callf                    q / 0     Y[1] 
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     0 
	chain                    p / 1 

------ Test disj14 -------
p :-
	(
	    a
	;
	    (
		var(A)
	    ->
		var(A)
	    )
	),
	b.

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	allocate                 0 
	callf                    a / 0     Y[] 
	chain                    b / 0 
label(3):
	trust_me                 0 
label(4):
	savecut                  a(1) 
	put_variable             a(2) 
	bi_var                   a(2) 
	cut                      a(1) 
	bi_var                   a(2) 
	jmp                      b / 0 

------ Test disj15 -------
p :-
	(
	    var(A)
	->
	    var(A),
	    !
	;
	    (
		p,
		var(A),
		!
	    ;
		var(A),
		!
	    )
	).

p / 0:
label(1):
	savecut                  a(1) 
	savecut                  a(2) 
	try_me_else              0     2     ref(3) 
label(2):
	put_variable             a(3) 
	bi_var                   a(3) 
	cut                      a(2) 
	bi_var                   a(3) 
	cut                      a(1) 
	ret                  
label(3):
	retry_me_else            0     ref(5) 
label(4):
	get_variable             1     a(1)     y(1) 
	callf                    ref(1)     Y[1] 
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     0 
	exit                 
label(5):
	trust_me                 0 
label(6):
	put_variable             a(1) 
	bi_var                   a(1) 
	ret                  

------ Test disj16 -------
p :-
	not (p, !, once (a, !, b)).

p / 0:
label(1):
	allocate                 3 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	savecut                  y(3) 
	callf                    ref(1)     Y[1,3] 
	cut                      y(3)     2 
	savecut                  y(2) 
	callf                    a / 0     Y[1,2] 
	cut                      y(2)     2 
	callf                    b / 0     Y[1,2] 
	cut                      y(2)     1 
	cut                      y(1)     0 
	failure              
label(3):
	trust_me_inline          0     Y[] 
label(4):
	exit                 

------ Test disj17 -------
p :-
	(
	    q(A)
	;
	    r(B)
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	put_variable             a(1) 
	jmp                      q / 1 
label(3):
	trust_me                 0 
label(4):
	put_variable             a(1) 
	jmp                      r / 1 

------ Test disj18 -------
p1(A, B, f(C)) :-
	A = B,
	A = C,
	a = b,
	q,
	argc(D),
	D = a.

p1 / 3:
label(1):
	get_structure            a(3)     f / 1     ref(2) 
	write_variable           a(3) 
	branch                   ref(3) 
label(2):
	read_variable            a(3) 
label(3):
	get_value                a(1)     a(2) 
	get_value                a(1)     a(3) 
	failure              

------ Test disj19 -------
t :-
	not not (!, fail).

t / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(6) 
label(2):
	savecut                  a(1) 
	try_me_else              0     1     ref(4) 
label(3):
	failure              
label(4):
	trust_me_inline          0     Y[1] 
label(5):
	cut                      y(1)     0 
	failure              
label(6):
	trust_me_inline          0     Y[] 
label(7):
	exit                 

------ Test disj20 -------
t :-
	(
	    tt
	->
	    not (tt -> fail)
	).

t / 0:
label(1):
	allocate                 3 
	savecut                  y(3) 
	callf                    tt / 0     Y[3] 
	cut                      y(3)     2 
	savecut                  y(1) 
	try_me_else              0     0     ref(3) 
label(2):
	savecut                  y(2) 
	callf                    tt / 0     Y[1,2] 
	cut                      y(2)     1 
	failure              
label(3):
	trust_me_inline          0     Y[] 
label(4):
	exit                 

------ Test disj20a -------
t :-
	(
	    true
	->
	    not (true -> fail)
	).

t / 0:
label(1):
	allocate                 3 
	savecut                  y(3) 
	callf                    true / 0     Y[3] 
	cut                      y(3)     2 
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	savecut                  y(2) 
	move                     a(1)     y(1) 
	callf                    true / 0     Y[1,2] 
	cut                      y(2)     1 
	failure              
label(3):
	trust_me_inline          0     Y[] 
label(4):
	exit                 

------ Test disj21 -------
t :-
	(
	    q,
	    var(A)
	->
	    p(A)
	).

t / 0:
label(1):
	allocate                 1 
	savecut                  y(1) 
	callf                    q / 0     Y[1] 
	put_variable             a(1) 
	bi_var                   a(1) 
	cut                      y(1)     0 
	chain                    p / 1 

------ Test disj22 -------
q(A) :-
	(
	    p(a)
	->
	    r(A)
	).

q / 1:
label(1):
	allocate                 2 
	savecut                  y(2) 
	move                     a(1)     y(1) 
	put_atom                 a(1)     a 
	callf                    p / 1     Y[1,2] 
	cut                      y(2)     1 
	move_chain               y(1)     a(1)     r / 1 

------ Test disj23 -------
g(A, B, C) :-
	copy_term(B, d(A, C, D)),
	once D.

g / 3:
label(1):
	shift                    a(4)     a(1)     a(2) 
	put_structure            a(2)     d / 3 
	push_value               a(4) 
	push_value               a(3) 
	allocate                 2 
	push_variable            y(2) 
	callf                    copy_term / 2     Y[2] 
	savecut                  y(1) 
	put_module               a(2)     eclipse 
	move_callf               y(2)     a(1)     sepia_kernel : call_ / 2     Y[1] 
	cut                      y(1)     0 
	exit                 

------ Test disj24 -------
p2([A|B], C, D) :-
	l(C, D, E / F),
	q(B, C, D).

p2 / 3:
label(1):
	allocate                 3 
	get_list                 a(1)     ref(2) 
	write_void           
	write_variable           y(3) 
	branch                   ref(3) 
label(2):
	read_void            
	read_variable            y(3) 
label(3):
	move                     2     a(2)     y(1) 
	put_structure            a(3)     (/) / 2 
	push_void                2 
	move                     a(2)     a(1) 
	move_callf               y(2)     a(2)     l / 3     Y[1,2,3] 
	move                     y(3)     a(1) 
	move                     2     y(1)     a(2) 
	chain                    q / 3 

------ Test disj25 -------
p(A) :-
	(
	    (
		A = 1,
		!
	    ;
		A = 2
	    ),
	    fail
	;
	    A = 4
	).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [var] - [1, 2]
    [integer] - []
    [integer, 4] - [2]
    [integer, 1] - [1]
    [integer, 2] - [1]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
INDEXES for (semidet) disjunction [2, 1, 2]
1. Quality 1.0
    [] - []
    [var] - [1]
    [integer] - []
    [integer, 1] - [1]
    [integer, 2] - [2]
Branch determinisms for disjunction [2, 1, 2]
    Branch 1: det
    Branch 2: det
p / 1:
label(1):
	allocate                 1 
	savecut                  y(1) 
	integer_switch           a(1) 
		4: 	ref(13)
		1: 	ref(4)
		2: 	ref(4)
		default: 	ref(fail)

label(3):
	try_me_else              0     1     ref(10) 
label(4):
	integer_switch           a(1) 
		1: 	ref(14)
		2: 	ref(15)
		default: 	ref(fail)

label(6):
	get_integer              a(1)     1 
label(14):
	cut                      y(1)     0 
	failure              
label(8):
	get_integer              a(1)     2 
label(15):
	failure              
label(10):
	trust_me_inline          0     Y[] 
label(11):
	get_integer              a(1)     4 
label(13):
	exit                 

------ Test disj26 -------
p(A, B) :-
	(
	    var(C),
	    q(C)
	->
	    r(C)
	;
	    s(A, B)
	).

p / 2:
label(1):
	allocate                 2 
	savecut                  y(1) 
	try_me_else              0     2     ref(3) 
label(2):
	put_global_variable      a(1)     y(2) 
	bi_var                   a(1) 
	callf                    q / 1     Y[1,2] 
	cut                      y(1)     2 
	move_chain               y(2)     a(1)     r / 1 
label(3):
	trust_me_inline          0     Y[] 
label(4):
	chain                    s / 2 

------ Test disj27 -------
p3(A, B, C) :-
	(
	    A = ''
	->
	    D = "",
	    E = F
	;
	    D = "a",
	    E = [A, F]
	).

INDEXES for (semidet) disjunction [2]
1. Quality 1.0
    [] - [2]
    [atom] - [2]
    [atom, ] - [1]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
p3 / 3:
label(1):
	atom_switch              a(1) 
		'': 	ref(6)
		default: 	ref(5)

label(3):
	get_atom                 a(1)     '' 
label(6):
label(5):
	ret                  

------ Test disj28 -------
s :-
	(
	    A == open
	->
	    true
	;
	    (
		A == def
	    ->
		(
		    transformed(B)
		->
		    true
		;
		    true
		)
	    )
	).

s / 0:
label(1):
	savecut                  a(1) 
	try_me_else              0     1     ref(3) 
label(2):
	put_variable             a(2) 
	in_get_atom              a(2)     open 
	cut                      a(1) 
	ret                  
label(3):
	trust_me                 0 
label(4):
	savecut                  a(1) 
	put_variable             a(2) 
	in_get_atom              a(2)     def 
	cut                      a(1) 
	allocate                 1 
	savecut                  y(1) 
	try_me_else              0     0     ref(6) 
label(5):
	put_variable             a(1) 
	callf                    transformed / 1     Y[1] 
	cut                      y(1)     0 
	exit                 
label(6):
	trust_me_inline          0     Y[] 
label(7):
	exit                 

------ Test disj29 -------
test A :-
	!,
	writeln(clause1),
	(
	    A = 1
	->
	    writeln(ok)
	;
	    writeln(wrong)
	).

INDEXES for (semidet) disjunction [3]
1. Quality 1.0
    [] - [2]
    [var] - [1]
    [integer] - [2]
    [integer, 1] - [1]
Branch determinisms for disjunction [3]
    Branch 1: det
    Branch 2: det
test / 1:
label(1):
	savecut                  a(3) 
	get_variable             1     a(1)     y(1) 
	put_atom                 a(1)     clause1 
	put_module               a(2)     eclipse 
	callf                    sepia_kernel : writeln_body / 2     Y[1] 
	integer_switch           y(1) 
		1: 	ref(4)
		default: 	ref(6)

label(4):
	move                     y(1)     a(3) 
	get_integer              a(3)     1 
	put_atom                 a(1)     ok 
	put_module               a(2)     eclipse 
	chain                    sepia_kernel : writeln_body / 2 
label(6):
	put_atom                 a(1)     wrong 
	put_module               a(2)     eclipse 
	chain                    sepia_kernel : writeln_body / 2 

------ Test disj30 -------
test :-
	getcond(A, B),
	(
	    A
	->
	    (
		B
	    ->
		true
	    )
	).

test / 0:
label(1):
	allocate                 4 
	put_global_variable2     a(1)     y(4)     a(2)     y(3) 
	callf                    getcond / 2     Y[3,4] 
	savecut                  y(2) 
	put_module               a(2)     eclipse 
	move_callf               y(4)     a(1)     sepia_kernel : call_ / 2     Y[2,3] 
	cut                      y(2)     3 
	savecut                  y(1) 
	put_module               a(2)     eclipse 
	move_callf               y(3)     a(1)     sepia_kernel : call_ / 2     Y[1] 
	cut                      y(1)     0 
	exit                 

------ Test disj31 -------
go(A) :-
	A = [B, C, D],
	findall(E, member(E, A), F),
	F = [1, 2, 3],
	nl,
	write('L = '),
	write(A).

go / 1:
label(1):
	get_list                 a(1)     ref(4) 
	write_void           
	write_list           
label(2):
	write_void           
	write_list           
label(3):
	write_void           
	write_nil            
	branch                   ref(5) 
label(4):
	read_void            
	read_last_list           ref(2) 
	read_void            
	read_last_list           ref(3) 
	read_void            
	read_nil             
label(5):
	get_variable             2     a(1)     y(1) 
	put_structure            a(2)     member / 2 
	push_variable            a(1) 
	push_value               y(1) 
	put_global_variable      a(3)     y(2) 
	put_module               a(4)     eclipse 
	callf                    sepia_kernel : findall_body / 4     Y[1,2] 
	move                     y(2)     a(1) 
	get_list                 a(1)     ref(8) 
	write_integer            1 
	write_list           
label(6):
	write_integer            2 
	write_list           
label(7):
	write_integer            3 
	write_nil            
	branch                   ref(9) 
label(8):
	read_integer             1 
	read_last_list           ref(6) 
	read_integer             2 
	read_last_list           ref(7) 
	read_integer             3 
	read_nil             
label(9):
	callf                    nl / 0     Y[1] 
	put_atom                 a(1)     'L = ' 
	put_module               a(2)     eclipse 
	callf                    sepia_kernel : write_ / 2     Y[1] 
	put_module               a(2)     eclipse 
	move_chain               y(1)     a(1)     sepia_kernel : write_ / 2 

------ Test disj33 -------
c(A, B) :-
	(
	    A = B
	->
	    a
	;
	    b
	),
	c.

c / 2:
label(1):
	savecut                  a(3) 
	try_me_else              0     3     ref(3) 
label(2):
	get_value                a(1)     a(2) 
	cut                      a(3) 
	allocate                 0 
	callf                    a / 0     Y[] 
	chain                    c / 0 
label(3):
	trust_me                 0 
label(4):
	allocate                 0 
	callf                    b / 0     Y[] 
	chain                    c / 0 

------ Test disj34 -------
producer(A) :-
	random(B),
	(
	    B > 0
	->
	    A = [B|C]
	;
	    A = [zero|C]
	),
	producer(C).

INDEXES for (nondet) disjunction [3]
1. Quality 1.5
    [] - [1]
    [list] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [3]
    Branch 1: try
    Branch 2: trust
producer / 1:
label(1):
	get_variable             3     a(1)     y(2) 
	put_global_variable_callf     a(1)     y(3)     random / 1     Y[2,3] 
	savecut                  a(1) 
	list_switch              y(2)     ref(2)     ref(3)     ref(3) 
label(2):
	try_me_else              0     1     ref(5) 
label(3):
	put_integer              a(2)     0 
	move                     y(3)     a(3) 
	bi_gt                    a(3)     a(2)     eclipse     48 
	cut                      a(1)     3 
	move                     y(2)     a(1) 
	get_list                 a(1)     ref(4) 
	write_value              a(3) 
	write_variable           y(1) 
	move_chain               y(1)     a(1)     ref(1) 
label(4):
	read_value               a(3) 
	read_variable            y(1) 
	move_chain               y(1)     a(1)     ref(1) 
label(5):
	trust_me_inline          0     Y[2] 
label(6):
	move                     y(2)     a(1) 
	get_list                 a(1)     ref(7) 
	write_atom               zero 
	write_variable           y(1) 
	move_chain               y(1)     a(1)     ref(1) 
label(7):
	read_atom                zero 
	read_variable            y(1) 
	move_chain               y(1)     a(1)     ref(1) 

------ Test disj35 -------
nm(A, [A|B]) :-
	true,
	!,
	fail.
nm(A, [B|C]) :-
	!,
	nm(A, C).
nm(A, []).

INDEXES for (nondet) disjunction [2]
1. Quality 1.5
    [] - []
    [[]] - [3]
    [list] - [1, 2]
    [var] - [1, 2]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
    Branch 3: det
nm / 2:
label(1):
	savecut                  a(3) 
	list_switch              a(2)     ref(13)     ref(14)     ref(fail) 
label(13):
	try                      0     3     ref(3) 
	trust                    0     ref(7) 
label(3):
	get_list                 a(2)     ref(4) 
	write_value              a(1) 
	write_void           
	branch                   ref(5) 
label(4):
	read_value               a(1) 
label(5):
	get_variable             1     a(3)     y(1) 
	callf                    true / 0     Y[1] 
	cut                      y(1)     0 
	failure              
label(7):
	get_list                 a(2)     ref(8) 
	write_void           
	write_variable           a(2) 
	jmp                      ref(1) 
label(8):
	read_void            
	read_variable            a(2) 
	jmp                      ref(1) 
label(11):
	get_nil                  a(2) 
label(14):
	ret                  

------ Test disj36 -------
nm(A, [A|B]) :-
	!,
	fail.
nm(A, [B|C]) :-
	!,
	nm(A, C).
nm(A, []).

INDEXES for (nondet) disjunction [2]
1. Quality 1.3
    [] - []
    [[]] - [3]
    [list] - [1, 2]
    [var] - [1]
Branch determinisms for disjunction [2]
    Branch 1: try
    Branch 2: trust
    Branch 3: det
nm / 2:
label(1):
	savecut                  a(3) 
	list_switch              a(2)     ref(13)     ref(14)     ref(fail) 
label(3):
	get_list                 a(2)     ref(4) 
	write_value              a(1) 
	write_void           
	cut                      a(3) 
	failure              
label(4):
	read_value               a(1) 
	cut                      a(3) 
	failure              
label(7):
	get_list                 a(2)     ref(8) 
	write_void           
	write_variable           a(2) 
	jmp                      ref(1) 
label(8):
	read_void            
	read_variable            a(2) 
	jmp                      ref(1) 
label(11):
	get_nil                  a(2) 
label(14):
	ret                  
label(13):
	try                      0     3     ref(3) 
	trust                    0     ref(7) 

------ Test alloc(1) -------
p(A) :-
	A = foo(2, 3, 4, 5).

p / 1:
label(1):
	get_structure            a(1)     foo / 4     ref(2) 
	write_integer2           2     3 
	write_integer2           4     5 
	ret                  
label(2):
	read_integer             2 
	read_integer             3 
	read_integer             4 
	read_integer             5 
	ret                  

------ Test alloc(2) -------
p :-
	A = foo(2, 3, 4, 5),
	q(A).

p / 0:
label(1):
	put_structure            a(1)     foo / 4 
	write_integer2           2     3 
	write_integer2           4     5 
	jmp                      q / 1 

------ Test alloc(3) -------
p :-
	A = foo(2, 3),
	q(A).
p :-
	A = foo(2, 3, 4, 5),
	r(A).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	put_structure            a(1)     foo / 2 
	write_integer2           2     3 
	jmp                      q / 1 
label(3):
	trust_me                 0 
label(4):
	put_structure            a(1)     foo / 4 
	write_integer2           2     3 
	write_integer2           4     5 
	jmp                      r / 1 

------ Test alloc(4) -------
p :-
	A = foo(2, 3, 4, 5),
	r(A).
p :-
	A = foo(2, 3),
	q(A).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	put_structure            a(1)     foo / 4 
	write_integer2           2     3 
	write_integer2           4     5 
	jmp                      r / 1 
label(3):
	trust_me                 0 
label(4):
	put_structure            a(1)     foo / 2 
	write_integer2           2     3 
	jmp                      q / 1 

------ Test alloc(5) -------
p :-
	(
	    A = foo(2, 3, 4, 5),
	    r(A)
	;
	    A = foo(2, 3),
	    q(A)
	).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	put_structure            a(1)     foo / 4 
	write_integer2           2     3 
	write_integer2           4     5 
	jmp                      r / 1 
label(3):
	trust_me                 0 
label(4):
	put_structure            a(1)     foo / 2 
	write_integer2           2     3 
	jmp                      q / 1 

------ Test alloc(6) -------
p(A) :-
	A = bar(2),
	(
	    B = foo(2, 3, 4, 5, 6),
	    r(B)
	;
	    B = foo(2, 3),
	    q(B)
	).

p / 1:
label(1):
	get_structure            a(1)     bar / 1     ref(2) 
	write_integer            2 
	branch                   ref(3) 
label(2):
	read_integer             2 
label(3):
	try_me_else              0     0     ref(5) 
label(4):
	put_structure            a(1)     foo / 5 
	write_integer2           2     3 
	write_integer2           4     5 
	push_integer             6 
	jmp                      r / 1 
label(5):
	trust_me                 0 
label(6):
	put_structure            a(1)     foo / 2 
	write_integer2           2     3 
	jmp                      q / 1 

------ Test alloc(7) -------
p(A) :-
	(
	    A == a,
	    B = foo(2, 3, 4, 5, 6),
	    r(B)
	;
	    (
		A == b,
		B = foo(2, 3),
		q(B)
	    ;
		A == c,
		B == foo(2, 3, 4, 5),
		s(B)
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 0.8
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
    [atom, c] - [3]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	atom_switch              a(1) 
		a: 	ref(10)
		b: 	ref(11)
		c: 	ref(12)
		default: 	ref(fail)

	branch                   ref(fail) 
label(4):
	in_get_atom              a(1)     a 
label(10):
	put_structure            a(1)     foo / 5 
	write_integer2           2     3 
	write_integer2           4     5 
	push_integer             6 
	jmp                      r / 1 
label(6):
	in_get_atom              a(1)     b 
label(11):
	put_structure            a(1)     foo / 2 
	write_integer2           2     3 
	jmp                      q / 1 
label(8):
	in_get_atom              a(1)     c 
label(12):
	put_variable             a(1) 
	put_structure            a(2)     foo / 4 
	write_integer2           2     3 
	write_integer2           4     5 
	get_matched_value        a(1)     a(2) 
	jmp                      s / 1 

------ Test alloc(8) -------
p(A) :-
	(
	    A == a,
	    B = foo(2, 6),
	    r(B)
	;
	    (
		A == b,
		B = foo(2, 3),
		q(B)
	    ;
		A == c,
		B == foo(2, 3, 4, 5),
		s(B)
	    )
	).

INDEXES for (semidet) disjunction [2]
1. Quality 0.8
    [] - []
    [atom] - []
    [atom, a] - [1]
    [atom, b] - [2]
    [atom, c] - [3]
Branch determinisms for disjunction [2]
    Branch 1: det
    Branch 2: det
    Branch 3: det
p / 1:
label(1):
	atom_switch              a(1) 
		a: 	ref(10)
		b: 	ref(11)
		c: 	ref(12)
		default: 	ref(fail)

	branch                   ref(fail) 
label(4):
	in_get_atom              a(1)     a 
label(10):
	put_structure            a(1)     foo / 2 
	write_integer2           2     6 
	jmp                      r / 1 
label(6):
	in_get_atom              a(1)     b 
label(11):
	put_structure            a(1)     foo / 2 
	write_integer2           2     3 
	jmp                      q / 1 
label(8):
	in_get_atom              a(1)     c 
label(12):
	put_variable             a(1) 
	put_structure            a(2)     foo / 4 
	write_integer2           2     3 
	write_integer2           4     5 
	get_matched_value        a(1)     a(2) 
	jmp                      s / 1 

------ Test alloc(10) -------
p :-
	(
	    A = foo(2, 3, 4, 5),
	    r(A, B)
	;
	    A = foo(2, 3),
	    q(A)
	),
	s(B).

p / 0:
label(1):
	try_me_else              0     0     ref(3) 
label(2):
	put_structure            a(1)     foo / 4 
	write_integer2           2     3 
	write_integer2           4     5 
	allocate                 1 
	put_global_variable_callf     a(2)     y(1)     r / 2     Y[1] 
	move_chain               y(1)     a(1)     s / 1 
label(3):
	trust_me                 0 
label(4):
	put_structure            a(1)     foo / 2 
	write_integer2           2     3 
	allocate                 1 
	callf                    q / 1     Y[] 
	gc_test                  1 
	put_global_variable      y(1) 
	move_chain               y(1)     a(1)     s / 1 

------ Test alloc(11) -------
p(A, A, foo(2, 3, 4, 5)).

p / 3:
label(1):
	get_value                a(2)     a(1) 
	get_structure            a(3)     foo / 4     ref(2) 
	write_integer2           2     3 
	write_integer2           4     5 
	ret                  
label(2):
	read_integer             2 
	read_integer             3 
	read_integer             4 
	read_integer             5 
	ret                  

------ Test alloc(12) -------
p(bar(A, A), foo(2, 3, 4, 5)).

p / 2:
label(1):
	get_structure            a(1)     bar / 2     ref(2) 
	write_variable           a(1) 
	write_value              a(1) 
	branch                   ref(3) 
label(2):
	read_variable            a(1) 
	read_value               a(1) 
label(3):
	get_structure            a(2)     foo / 4     ref(4) 
	write_integer2           2     3 
	write_integer2           4     5 
	ret                  
label(4):
	read_integer             2 
	read_integer             3 
	read_integer             4 
	read_integer             5 
	ret                  
