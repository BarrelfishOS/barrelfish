/*
 * Copyright (c) 2017 ETH Zurich. All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, CAB F.78, Universitaetstrasse 6, CH-8092 Zurich,
 * Attn: Systems Group.
 */

/*
 * NOTE: This file has been automatically generated based on the XML files
 * provided by ARM.
 *
 * Download from:
 * https://developer.arm.com/products/architecture/a-profile/exploration-tools
 *
 * Based on version: SysReg_v82A_xml-00bet3.1.tar.gz
 */

device armv8 msbfirst () "ARMv8 architecture definitions" {

space armv8_sysreg(name) registerwise "System registers";
space cache_ctrl(name) registerwise "Cache control register";

constants MAIR_Mem width(2) "Shareability" {
    MAIR_MEM_Write_Through_Transient = 0b00;
    MAIR_MEM_NonCache = 0b01;
    MAIR_MEM_Write_Through_Non_Transient = 0b10;
    MAIR_MEM_Write_Back_Non_Transient = 0b11;
};

constants MAIR_Dev width(2) "Shareability" {
    MAIR_DEV_nGnRnE = 0b00;
    MAIR_DEV_nGnRE  = 0b01;
    MAIR_DEV_nGRE   = 0b10;
    MAIR_DEV_GRE    = 0b11;
};

constants shareability width(2) "Shareability" {
    non_shareable   = 0b00 "Non-shareable";
    outer_shareable = 0b10 "Outer Shareable";
    inner_shareable = 0b11 "Inner Shareable";
};

constants cacheability width(2) "Cacheability" {
    non_cacheable   = 0b00 "Normal memory, Outer Non-cacheable";
    WbRaWa_cache    = 0b01 "Normal memory, Outer Write-Back Read-Allocate Write-Allocate Cacheable";
    WtRanWa_cache   = 0b10 "Normal memory, Outer Write-Through Read-Allocate No Write-Allocate Cacheable";
    WbRanWa_cache   = 0b11 "Normal memory, Outer Write-Back Read-Allocate No Write-Allocate Cacheable";
};

constants ASID_size width(1) "ASID size" {
    bit_8   = 0b0 "8 bit ASID size";
    bit_16  = 0b1 "16 bit ASID size";
};

constants granule width(2) "Granule size" {
    KB_4    = 0b00;
    KB_64   = 0b01;
    KB_16   = 0b10;
};

constants endianness width(1) "Endianness configuration" {
    little  = 0b0 "Little endian";
    big     = 0b1 "Big endian";
};

constants fpen width(2) "Endianness configuration" {
    fpen_trap_any  = 0b00 "Trap any FP and SIMD instructions in EL0 or EL1";
    fpen_trap_el0  = 0b01 "Trap any FP and SIMD in EL0 to EL21";
    fpen_trap_el1  = 0b10 "Trap any FP and SIMD instructions in EL0 or EL1";
    fpen_trap_none = 0b11 "Does not cause any instruction to be trapped.";
};

constants ID_FEATURE width(4) "Feature implemented" {
    ID_FEATURE_IMPLEMENTED = 0b0000;
    ID_FEATURE_NOT_IMPLEMENTED = 0b1111;
};

constants EL_IMPLEMENTED width(4) "Feature implemented" {
    ID_EL_NOT_IMPLEMENTED = 0b0000;
    ID_EL_AARCH64_ONLY = 0b0001;
    ID_EL_AARCH32_OR_64 = 0b0010;
};


register MAIR_EL1 rw armv8_sysreg(MAIR_EL1) "Memory Attribute Indirection Register (EL1)" {
    attr7_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr7_mem_rw    2 "Read/Write allocate policy";
    attr7_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr6_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr6_mem_rw    2 "Read/Write allocate policy";
    attr6_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr5_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr5_mem_rw    2 "Read/Write allocate policy";
    attr5_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr4_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr4_mem_rw    2 "Read/Write allocate policy";
    attr4_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr3_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr3_mem_rw    2 "Read/Write allocate policy";
    attr3_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;        
    attr2_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr2_mem_rw    2 "Read/Write allocate policy";
    attr2_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr1_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr1_mem_rw    2 "Read/Write allocate policy";
    attr1_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;      
    attr0_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr0_mem_rw    2 "Read/Write allocate policy";
    attr0_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;      
};

register MAIR_EL2 rw armv8_sysreg(MAIR_EL2) "Memory Attribute Indirection Register (EL2)" {
    attr7_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr7_mem_rw    2 "Read/Write allocate policy";
    attr7_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr6_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr6_mem_rw    2 "Read/Write allocate policy";
    attr6_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr5_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr5_mem_rw    2 "Read/Write allocate policy";
    attr5_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr4_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr4_mem_rw    2 "Read/Write allocate policy";
    attr4_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr3_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr3_mem_rw    2 "Read/Write allocate policy";
    attr3_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;        
    attr2_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr2_mem_rw    2 "Read/Write allocate policy";
    attr2_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr1_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr1_mem_rw    2 "Read/Write allocate policy";
    attr1_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;      
    attr0_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr0_mem_rw    2 "Read/Write allocate policy";
    attr0_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;      
};

register MAIR_EL3 rw armv8_sysreg(MAIR_EL3) "Memory Attribute Indirection Register (EL3)" {
    attr7_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr7_mem_rw    2 "Read/Write allocate policy";
    attr7_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr6_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr6_mem_rw    2 "Read/Write allocate policy";
    attr6_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr5_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr5_mem_rw    2 "Read/Write allocate policy";
    attr5_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr4_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr4_mem_rw    2 "Read/Write allocate policy";
    attr4_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr3_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr3_mem_rw    2 "Read/Write allocate policy";
    attr3_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;        
    attr2_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr2_mem_rw    2 "Read/Write allocate policy";
    attr2_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;
    attr1_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr1_mem_rw    2 "Read/Write allocate policy";
    attr1_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;      
    attr0_mem       2 type(MAIR_Mem) "Memory / Write Back";
    attr0_mem_rw    2 "Read/Write allocate policy";
    attr0_dev 2 type(MAIR_Dev) "Device memory type";  
    _         2 mbz;      
};
    
/* Source: AArch64-osdlr_el1.xml */
register OSDLR_EL1 rw armv8_sysreg(OSDLR_EL1) "OS Double Lock Register" {
	_	31  mbz "Reserved, RES0.";
	DLK	1   "OS Double Lock control bit. Possible values are:";
};

/* Source: AArch64-contextidr_el1.xml */
register CONTEXTIDR_EL1 rw armv8_sysreg(CONTEXTIDR_EL1) "Context ID Register (EL1)" {
	PROCID	32   "Process Identifier. This field must be programmed with a unique value that identifies the current process.";
};

/* Source: AArch64-tpidr_el0.xml */
register TPIDR_EL0 rw armv8_sysreg(TPIDR_EL0) "EL0 Read/Write Software Thread ID Register" type(uint64);

/* Source: AArch64-cntvoff_el2.xml */
register CNTVOFF_EL2 rw armv8_sysreg(CNTVOFF_EL2) "Counter-timer Virtual Offset register" type(uint64);

/* Source: AArch64-rmr_el1.xml */
register RMR_EL1 rw armv8_sysreg(RMR_EL1) "Reset Management Register (EL1)" {
	_	30  mbz "Reserved, RES0.";
	RR	1   "Reset Request. Setting this bit to 1 requests a Warm reset.";
	AA64	1   "When EL1 can use AArch32, determines which Execution state the PE boots into after a Warm reset:";
};

/* Source: AArch64-ifsr32_el2.xml */
register IFSR32_EL2 rw armv8_sysreg(IFSR32_EL2) "Instruction Fault Status Register (EL2)" {
	_	15  mbz "Reserved, RES0.";
	FnV	1   "FAR not Valid, for a Synchronous external abort other than a Synchronous external abort on a translation table walk.";
	_	3  mbz "Reserved, RES0.";
	ExT	1   "External abort type. This bit can be used to provide an IMPLEMENTATION DEFINED classification of external aborts.";
	_	1  mbz "Reserved, RES0.";
	FS_hi	1   "See FS[3:0], bits [3:0] for description of the FS field.";
	LPAE	1   "On taking a Data Abort exception, this bit is set as follows:";
	_	5  mbz "Reserved, RES0.";
	FS_lo	4   "Fault status bits. Interpreted with bit [10]. Possible values of FS[4:0] are:";
};

/* Source: AArch64-far_el2.xml */
register FAR_EL2 rw armv8_sysreg(FAR_EL2) "Fault Address Register (EL2)" type(uint64);

/* Source: AArch64-cnthp_tval_el2.xml */
register CNTHP_TVAL_EL2 rw armv8_sysreg(CNTHP_TVAL_EL2) "Counter-timer Hypervisor Physical Timer TimerValue register" {
	TimerValue	32   "The TimerValue view of the EL2 physical timer.";
};

/* Source: AArch64-hstr_el2.xml */
register HSTR_EL2 rw armv8_sysreg(HSTR_EL2) "Hypervisor System Trap Register" {
	_	16  mbz "Reserved, RES0.";
	T	16   "Fields T14 and T4 are RES0.";
};

/* Source: AArch64-icc_ctlr_el1.xml */
register ICC_CTLR_EL1 rw armv8_sysreg(ICC_CTLR_EL1) "Interrupt Controller Control Register (EL1)" {
	_	16  mbz "Reserved, RES0.";
	A3V	1   "Affinity 3 Valid. Read-only and writes are ignored. Possible values are:";
	SEIS	1   "SEI Support. Read-only and writes are ignored. Indicates whether the CPU interface supports local generation of SEIs:";
	IDbits	3   "Identifier bits. Read-only and writes are ignored. The number of physical interrupt identifier bits supported:";
	PRIbits	3   "Priority bits. Read-only and writes are ignored. The number of priority bits implemented, minus one.";
	_	1  mbz "Reserved, RES0.";
	PMHE	1   "Priority Mask Hint Enable. Controls whether the priority mask register is used as a hint for interrupt distribution:";
	_	4  mbz "Reserved, RES0.";
	EOImode	1   "EOI mode for the current Security state. Controls whether a write to an End of Interrupt register also deactivates the interrupt:";
	CBPR	1   "Common Binary Point Register. Controls whether the same register is used for interrupt preemption of both Group 0 and Group 1 interrupts:";
};

/* Source: AArch64-ich_ap0rn_el2.xml */
regtype ICH_AP0R_EL2_type "Interrupt Controller Hyp Active Priorities Group 0 Registers" {
	P	32   "Provides the access to the virtual active priorities for Group 0 interrupts. Possible values of each bit are:";
};
register ICH_AP0R0_EL2 rw armv8_sysreg(ICH_AP0R0_EL2) "Interrupt Controller Hyp Active Priorities Group 0 Registers" type(ICH_AP0R_EL2_type);
register ICH_AP0R1_EL2 rw armv8_sysreg(ICH_AP0R1_EL2) "Interrupt Controller Hyp Active Priorities Group 0 Registers" type(ICH_AP0R_EL2_type);
register ICH_AP0R2_EL2 rw armv8_sysreg(ICH_AP0R2_EL2) "Interrupt Controller Hyp Active Priorities Group 0 Registers" type(ICH_AP0R_EL2_type);

/* Source: AArch64-cptr_el2.xml */
register CPTR_EL2 rw armv8_sysreg(CPTR_EL2) "Architectural Feature Trap Register (EL2)" {
	TCPAC	1   "Traps Non-secure EL1 accesses to CPACR_EL1 or CPACR to EL2, from both Execution states.";
	_	10  mbz "Reserved, RES0.";
	TTA	1   "Traps Non-secure System register accesses to all implemented trace registers to EL2, from both Execution states.";
	_	6  mbz "Reserved, RES0.";
	_	2  mb1 "Reserved, RES1.";
	_	1  mbz "Reserved, RES0.";
	TFP	1   "Traps Non-secure accesses to SVE, Advanced SIMD and floating-point functionality to EL2, from both Execution states.";
	_	1  mb1 "Reserved, RES1.";
	TZ	1   "Present only if  is implemented.";
	_	8  mb1 "Reserved, RES1.";
};

/* Source: AArch64-dbgdtr_el0.xml */
register DBGDTR_EL0 rw armv8_sysreg(DBGDTR_EL0) "Debug Data Transfer Register, half-duplex" {
	HighWord	32   "Writes to this register set DTRRX to the value in this field and do not change RXfull.";
	LowWord	32   "Writes to this register set DTRTX to the value in this field and set TXfull to 1.";
};

/* Source: AArch64-mdrar_el1.xml */
register MDRAR_EL1 ro armv8_sysreg(MDRAR_EL1) "Monitor Debug ROM Address Register" {
	_	12  mbz "Reserved, RES0.";
	ROMADDR_hi	4   "Extension to ROMADDR[47:12]. See ROMADDR[47:12] for more details.";
	ROMADDR_lo	36   "Bits[47:12] of the ROM table physical address.";
	_	10  mbz "Reserved, RES0.";
	Valid	2   "This field indicates whether the ROM Table address is valid. The permitted values of this field are:";
};

/* Source: AArch64-afsr0_el3.xml */
register AFSR0_EL3 rw armv8_sysreg(AFSR0_EL3) "Auxiliary Fault Status Register 0 (EL3)" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-far_el1.xml */
register FAR_EL1 rw armv8_sysreg(FAR_EL1) "Fault Address Register (EL1)" type(uint64);

/* Source: AArch64-id_isar4_el1.xml */
register ID_ISAR4_EL1 ro armv8_sysreg(ID_ISAR4_EL1) "AArch32 Instruction Set Attribute Register 4" {
	SWP_frac	4   "Indicates support for the memory system locking the bus for SWP or SWPB instructions. Defined values are:";
	PSR_M	4   "Indicates the implemented M profile instructions to modify the PSRs. Defined values are:";
	SynchPrim_frac	4   "Used in conjunction with ID_ISAR3.SynchPrim to indicate the implemented Synchronization Primitive instructions. Possible values are:";
	Barrier	4   "Indicates the implemented Barrier instructions in the A32 and T32 instruction sets. Defined values are:";
	SMC	4   "Indicates the implemented SMC instructions. Defined values are:";
	Writeback	4   "Indicates the support for Writeback addressing modes. Defined values are:";
	WithShifts	4   "Indicates the support for instructions with shifts. Defined values are:";
	Unpriv	4   "Indicates the implemented unprivileged instructions. Defined values are:";
};

/* Source: AArch64-dacr32_el2.xml */
register DACR32_EL2 rw armv8_sysreg(DACR32_EL2) "Domain Access Control Register" {
	D	32   "Domain n access permission, where n = 0 to 15. Permitted values are:";
};

/* Source: AArch64-rvbar_el2.xml */
register RVBAR_EL2 ro armv8_sysreg(RVBAR_EL2) "Reset Vector Base Address Register (if EL3 not implemented)" type(uint64);

/* Source: AArch64-dbgclaimclr_el1.xml */
register DBGCLAIMCLR_EL1 rw armv8_sysreg(DBGCLAIMCLR_EL1) "Debug Claim Tag Clear register" {
	_	24  mbz "Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes.";
	CLAIM	8   "Read or clear CLAIM tag bits. Reading this field returns the current value of the CLAIM tag bits.";
};

/* Source: AArch64-lorc_el1.xml */
register LORC_EL1 rw armv8_sysreg(LORC_EL1) "LORegion Control (EL1)" {
	_	54  mbz "Reserved, RES0.";
	DS	8   "Descriptor Select. Selects the current LORegion descriptor accessed by LORSA_EL1, LOREA_EL1, and LORN_EL1.";
	_	1  mbz "Reserved, RES0.";
	EN	1   "Enable. Indicates whether LORegions are enabled:";
};

/* Source: AArch64-sctlr_el1.xml */
register SCTLR_EL1 rw armv8_sysreg(SCTLR_EL1) "System Control Register (EL1)" {
	_	2  mbz "Reserved, RES0.";
	LSMAOE	1   "Load Multiple and Store Multiple Atomicity and Ordering Enable. When the OPTIONAL feature  is implemented, defined values are:";
	nTLSMD	1   "No Trap Load Multiple and Store Multiple to Device-nGRE/Device-nGnRE/Device-nGnRnE memory. When the OPTIONAL feature  is implemented, defined values are:";
	_	1  mbz "Reserved, RES0.";
	UCI	1   "Traps EL0 execution of cache maintenance instructions to EL1, from AArch64 state only.";
	EE	1 type(endianness)  "Endianness of data accesses at EL1, and stage 1 translation table walks in the EL1&0 translation regime.";
	E0E	1 type(endianness)  "Endianness of data accesses at EL0.";
	SPAN	1   "Set Privileged Access Never, on taking an exception to EL1.";
	_	1  mb1 "Reserved, RES1.";
	IESB	1   "Implicit Error Synchronizaition Barrier enable. Permitted values are:";
	_	1  mb1 "Reserved, RES1.";
	WXN	1   "Write permission implies XN (Execute-never). For the EL1&0 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:";
	nTWE	1   "Traps EL0 execution of WFE instructions to EL1, from both Execution states.";
	_	1  mbz "Reserved, RES0.";
	nTWI	1   "Traps EL0 execution of WFI instructions to EL1, from both Execution states.";
	UCT	1   "Traps EL0 accesses to the CTR_EL0 to EL1, from AArch64 state only.";
	DZE	1   "Traps EL0 execution of DC ZVA instructions to EL1, from AArch64 state only.";
	_	1  mbz "Reserved, RES0.";
	I	1   "Instruction access Cacheability control, for accesses at EL0 and EL1:";
	_	1  mb1 "Reserved, RES1.";
	_	1  mbz "Reserved, RES0.";
	UMA	1   "User Mask Access. Traps EL0 execution of MSR and MRS instructions that access the PSTATE.{D, A, I, F} masks to EL1, from AArch64 state only.";
	SED	1   "SETEND instruction disable. Disables SETEND instructions at EL0 using AArch32.";
	ITD	1   "IT Disable. Disables some uses of IT instructions at EL0 using AArch32.";
	_	1  mbz "Reserved, RES0.";
	CP15BEN	1   "System instruction memory barrier enable. Enables accesses to the DMB, DSB, and ISB System instructions in the (coproc==1111) encoding space from EL0:";
	SA0	1   "SP Alignment check enable for EL0. When set to 1, if a load or store instruction executed at EL0 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see .";
	SA	1   "SP Alignment check enable. When set to 1, if a load or store instruction executed at EL1 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see .";
	C	1   "Cacheability control, for data accesses.";
	A	1   "Alignment check enable. This is the enable bit for Alignment fault checking at EL1 and EL0:";
	M	1   "MMU enable for EL1 and EL0 stage 1 address translation. Possible values of this bit are:";
};

/* Source: AArch64-cntpct_el0.xml */
register CNTPCT_EL0 ro armv8_sysreg(CNTPCT_EL0) "Counter-timer Physical Count register" type(uint64);

/* Source: AArch64-mdcr_el2.xml */
register MDCR_EL2 rw armv8_sysreg(MDCR_EL2) "Monitor Debug Configuration Register (EL2)" {
	_	14  mbz "Reserved, RES0.";
	HPMD	1   "Guest Performance Monitors Disable. This control prohibits event counting at EL2. Permitted values are:";
	_	2  mbz "Reserved, RES0.";
	TPMS	1   "Trap Performance Monitor Sampling. When the Statistical Profiling Extension is implemented this field controls access to Statistical Profiling control registers from Non-secure EL1 and EL0. The possible values of this bit are:";
	E2PB	2   "EL2 Profiling Buffer. When the Statistical Profiling Extension is implemented this field controls the owning translation regime and access to Profiling Buffer control registers from Non-secure EL1. The possible values of this field are:";
	TDRA	1   "Trap Debug ROM Address register access. Traps Non-secure System register accesses to the Debug ROM registers to EL2. This trap is from:";
	TDOSA	1   "Trap debug OS-related register access. Traps Non-secure EL1 System register accesses to the powerdown debug registers to EL2, from both Execution states:";
	TDA	1   "Trap Debug Access. Traps Non-secure EL0 and EL1 System register accesses to those debug System registers that are not trapped by either of the following:";
	TDE	1   "Trap Debug exceptions. The possible values of this field are:";
	HPME	1   "Hypervisor Performance Monitors Counters Enable. The possible values of this bit are:";
	TPM	1   "Trap Performance Monitors accesses. Traps Non-secure EL0 and EL1 accesses to all Performance Monitors registers to EL2, from both Execution states:";
	TPMCR	1   "Trap PMCR_EL0 or PMCR accesses. Traps Non-secure EL0 and EL1 accesses to the PMCR_EL0 or PMCR to EL2.";
	HPMN	5   "Defines the number of Performance Monitors counters that are accessible from Non-secure EL0 and EL1 modes.";
};

/* Source: AArch64-oseccr_el1.xml */
register OSECCR_EL1 rw armv8_sysreg(OSECCR_EL1) "OS Lock Exception Catch Control Register" {
	EDECCR	32   "Used for save/restore to EDECCR over powerdown.";
};

/* Source: AArch64-spsr_und.xml */
register SPSR_und rw armv8_sysreg(SPSR_und) "Saved Program Status Register (Undefined mode)" {
	N	1   "Set to the value of CPSR.N on taking an exception to Undefined mode, and copied to CPSR.N on executing an exception return operation in Undefined mode.";
	Z	1   "Set to the value of CPSR.Z on taking an exception to Undefined mode, and copied to CPSR.Z on executing an exception return operation in Undefined mode.";
	C	1   "Set to the value of CPSR.C on taking an exception to Undefined mode, and copied to CPSR.C on executing an exception return operation in Undefined mode.";
	V	1   "Set to the value of CPSR.V on taking an exception to Undefined mode, and copied to CPSR.V on executing an exception return operation in Undefined mode.";
	Q	1   "Cumulative saturation bit. Set to 1 to indicate that overflow or saturation occurred in some instructions.";
	IT_lo	2   "IT block state bits for the T32 IT (If-Then) instruction. See IT[7:2] for explanation of this field.";
	J	1   "RES0.";
	_	1  mbz "Reserved, RES0.";
	PAN	1   "When  is implemented, set  to the value of CPSR.PAN on taking an exception to Undefined mode, and copied to CPSR.PAN on executing an exception return operation in Undefined mode.";
	_	1  mbz "Reserved, RES0.";
	IL	1   "Illegal Execution state bit. Shows the value of PSTATE.IL immediately before the exception was taken.";
	GE	4   "Greater than or Equal flags, for parallel addition and subtraction.";
	IT_hi	6   "IT block state bits for the T32 IT (If-Then) instruction. This field must be interpreted in two parts.";
	E	1   "Endianness state bit. Controls the load and store endianness for data accesses:";
	A	1   "SError interrupt mask bit. The possible values of this bit are:";
	I	1   "IRQ mask bit. The possible values of this bit are:";
	F	1   "FIQ mask bit. The possible values of this bit are:";
	T	1   "T32 Instruction set state bit. Determines the AArch32 instruction set state that the exception was taken from. Possible values of this bit are:";
	M_hi	1   "Execution state that the exception was taken from. Possible values of this bit are:";
	M_lo	4   "AArch32 mode that an exception was taken from. The possible values are:";
};

/* Source: AArch64-id_isar3_el1.xml */
register ID_ISAR3_EL1 ro armv8_sysreg(ID_ISAR3_EL1) "AArch32 Instruction Set Attribute Register 3" {
	T32EE	4   "Indicates the implemented T32EE instructions. Defined values are:";
	TrueNOP	4   "Indicates the implemented true NOP instructions. Defined values are:";
	T32Copy	4   "Indicates the support for T32 non flag-setting MOV instructions. Defined values are:";
	TabBranch	4   "Indicates the implemented Table Branch instructions in the T32 instruction set. Defined values are:";
	SynchPrim	4   "Used in conjunction with ID_ISAR4.SynchPrim_frac to indicate the implemented Synchronization Primitive instructions. Defined values are:";
	SVC	4   "Indicates the implemented SVC instructions. Defined values are:";
	SIMD	4   "Indicates the implemented SIMD instructions. Defined values are:";
	Saturate	4   "Indicates the implemented Saturate instructions. Defined values are:";
};

/* Source: AArch64-icc_ctlr_el3.xml */
register ICC_CTLR_EL3 rw armv8_sysreg(ICC_CTLR_EL3) "Interrupt Controller Control Register (EL3)" {
	_	14  mbz "Reserved, RES0.";
	nDS	1   "Disable Security not supported. Read-only and writes are ignored. Possible values are:";
	_	1  mbz "Reserved, RES0.";
	A3V	1   "Affinity 3 Valid. Read-only and writes are ignored. Possible values are:";
	SEIS	1   "SEI Support. Read-only and writes are ignored. Indicates whether the CPU interface supports generation of SEIs:";
	IDbits	3   "Identifier bits. Read-only and writes are ignored. The number of physical interrupt identifier bits supported:";
	PRIbits	3   "Priority bits. Read-only and writes are ignored. The number of priority bits implemented, minus one.";
	_	1  mbz "Reserved, RES0.";
	PMHE	1   "Priority Mask Hint Enable.";
	RM	1   "Routing Modifier. For legacy operation of EL1 software with GICC_CTLR.FIQen set to 1, this bit indicates whether interrupts can be acknowledged or observed as the Highest Priority Pending Interrupt, or whether a special INTID value is returned.";
	EOImode_EL1NS	1   "EOI mode for interrupts handled at Non-secure EL1 and EL2. Controls whether a write to an End of Interrupt register also deactivates the interrupt:";
	EOImode_EL1S	1   "EOI mode for interrupts handled at Secure EL1. Controls whether a write to an End of Interrupt register also deactivates the interrupt:";
	EOImode_EL3	1   "EOI mode for interrupts handled at EL3. Controls whether a write to an End of Interrupt register also deactivates the interrupt:";
	CBPR_EL1NS	1   "Common Binary Point Register, EL1 Non-secure. Controls whether the same register is used for interrupt preemption of both Group 0 and Group 1 Non-secure interrupts at EL1 and EL2:";
	CBPR_EL1S	1   "Common Binary Point Register, EL1 Secure. Controls whether the same register is used for interrupt preemption of both Group 0 and Group 1 Secure interrupts at EL1:";
};

/* Source: AArch64-icc_sgi1r_el1.xml */
register ICC_SGI1R_EL1 wo armv8_sysreg(ICC_SGI1R_EL1) "Interrupt Controller Software Generated Interrupt Group 1 Register" {
	_	8  mbz "Reserved, RES0.";
	Aff3	8   "The affinity 3 value of the affinity path of the cluster for which SGI interrupts will be generated.";
	_	7  mbz "Reserved, RES0.";
	IRM	1   "Interrupt Routing Mode. Determines how the generated interrupts are distributed to PEs. Possible values are:";
	Aff2	8   "The affinity 2 value of the affinity path of the cluster for which SGI interrupts will be generated.";
	_	4  mbz "Reserved, RES0.";
	INTID	4   "The INTID of the SGI.";
	Aff1	8   "The affinity 1 value of the affinity path of the cluster for which SGI interrupts will be generated.";
	TargetList	16   "Target List. The set of PEs for which SGI interrupts will be generated. Each bit corresponds to the PE within a cluster with an Affinity 0 value equal to the bit number.";
};

/* Source: AArch64-contextidr_el2.xml */
register CONTEXTIDR_EL2 rw armv8_sysreg(CONTEXTIDR_EL2) "Context ID Register (EL2)" {
	PROCID	32   "Process Identifier. This field must be programmed with a unique value that identifies the current process.";
};

/* Source: AArch64-id_aa64mmfr1_el1.xml */
register ID_AA64MMFR1_EL1 ro armv8_sysreg(ID_AA64MMFR1_EL1) "AArch64 Memory Model Feature Register 1" {
	_	32  mbz "Reserved, RES0.";
	XNX	4   "Indicates support for Execute Never control distinction at stage 2 bit. Defined values are:";
	SpecSEI	4   "Describes whether the PE can generate SError interrupt exceptions from speculative reads of memory, including speculative instruction fetches. The defined values of this field are:";
	PAN	4   "Privileged Access Never. Indicates support for the PAN bit in PSTATE, SPSR_EL1, SPSR_EL2, SPSR_EL3, and DSPSR_EL0. Defined values are:";
	LO	4   "LORegions. Indicates support for LORegions. Defined values are:";
	HPDS	4   "Hierarchical permission disables bits in translation tables. Defined values are:";
	VH	4   "Virtualization Host Extensions. Defined values are:";
	VMIDBits	4   "Number of VMID bits. Defined values are:";
	HAFDBS	4   "Hardware updates to Access flag and Dirty state in translation tables. Defined values are:";
};

/* Source: AArch64-pmintenclr_el1.xml */
register PMINTENCLR_EL1 rw armv8_sysreg(PMINTENCLR_EL1) "Performance Monitors Interrupt Enable Clear register" {
	C	1   "PMCCNTR_EL0 overflow interrupt request disable bit. Possible values are:";
	P	31   "Event counter overflow interrupt request disable bit for PMEVCNTR<n>_EL0.";
};

/* Source: AArch64-tcr_el1.xml */
register TCR_EL1 rw armv8_sysreg(TCR_EL1) "Translation Control Register (EL1)" {
	_	9  mbz "Reserved, RES0.";
	NFD1	1   "Present only if  is implemented.";
	NFD0	1   "Present only if  is implemented.";
	_	2  mbz "Reserved, RES0.";
	HWU162	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[62] of the stage 1 translation table block or level 3 entry for pages pointed to by TTBR1_EL1 if the TCR_EL1.HPD1 value is 1.";
	HWU161	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[61] of the stage 1 translation table block or level 3 entry for pages pointed to by TTBR1_EL1 if the TCR_EL1.HPD1 value is 1.";
	HWU160	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[60] of the stage 1 translation table block or level 3 entry for pages pointed to by TTBR1_EL1 if the TCR_EL1.HPD1 value is 1.";
	HWU159	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[59] of the stage 1 translation table block or level 3 entry for pages pointed to by TTBR1_EL1 if the TCR_EL1.HPD1 value is 1.";
	HWU062	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[62] of the stage 1 translation table block or level 3 entry for pages pointed to by TTBR0_EL1 if the TCR_EL1.HPD0 value is 1.";
	HWU061	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[61] of the stage 1 translation table block or level 3 entry for pages pointed to by TTBR0_EL1 if the TCR_EL1.HPD0 value is 1.";
	HWU060	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[60] of the stage 1 translation table block or level 3 entry for pages pointed to by TTBR0_EL1 if the TCR_EL1.HPD0 value is 1.";
	HWU059	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[59] of the stage 1 translation table block or level 3 entry for pages pointed to by TTBR0_EL1 if the TCR_EL1.HPD0 value is 1.";
	HPD1	1   "Hierarchical Permission Disables. This affects the hierarchical control bits, APTable, PXNTable, and UXNTable, except NSTable, in the translation tables pointed to by TTBR1_EL1.";
	HPD0	1   "Hierarchical Permission Disables. This affects the hierarchical control bits, APTable, PXNTable, and UXNTable, except NSTable, in the translation tables pointed to by TTBR0_EL1.";
	HD	1   "Hardware management of dirty state in stage 1 translations from EL0 and EL1.";
	HA	1   "Hardware Access flag update in stage 1 translations from EL0 and EL1.";
	TBI1	1   "Top Byte ignored - indicates whether the top byte of an address is used for address match for the TTBR1_EL1 region, or ignored and used for tagged addresses. Defined values are:";
	TBI0	1   "Top Byte ignored - indicates whether the top byte of an address is used for address match for the TTBR0_EL1 region, or ignored and used for tagged addresses. Defined values are:";
	AS	1 type(ASID_size)  "ASID Size. Defined values are:";
	_	1  mbz "Reserved, RES0.";
	IPS	3   "Intermediate Physical Address Size.";
	TG1	2 type(granule)  "Granule size for the TTBR1_EL1.";
	SH1	2 type(shareability)  "Shareability attribute for memory associated with translation table walks using TTBR1_EL1. Defined values are:";
	ORGN1	2 type(cacheability)  "Outer cacheability attribute for memory associated with translation table walks using TTBR1_EL1.";
	IRGN1	2 type(cacheability)  "Inner cacheability attribute for memory associated with translation table walks using TTBR1_EL1.";
	EPD1	1   "Translation table walk disable for translations using TTBR1_EL1. This bit controls whether a translation table walk is performed on a TLB miss, for an address that is translated using TTBR1_EL1. The encoding of this bit is:";
	A1	1   "Selects whether TTBR0_EL1 or TTBR1_EL1 defines the ASID. The encoding of this bit is:";
	T1SZ	6   "The size offset of the memory region addressed by TTBR1_EL1. The region size is 2(64-T1SZ) bytes.";
	TG0	2 type(granule)  "Granule size for the TTBR0_EL1.";
	SH0	2 type(shareability)  "Shareability attribute for memory associated with translation table walks using TTBR0_EL1.";
	ORGN0	2 type(cacheability)  "Outer cacheability attribute for memory associated with translation table walks using TTBR0_EL1.";
	IRGN0	2 type(cacheability)  "Inner cacheability attribute for memory associated with translation table walks using TTBR0_EL1.";
	EPD0	1   "Translation table walk disable for translations using TTBR0_EL1. This bit controls whether a translation table walk is performed on a TLB miss, for an address that is translated using TTBR0_EL1. The encoding of this bit is:";
	_	1  mbz "Reserved, RES0.";
	T0SZ	6   "The size offset of the memory region addressed by TTBR0_EL1. The region size is 2(64-T0SZ) bytes.";
};

/* Source: AArch64-tcr_el3.xml */
register TCR_EL3 rw armv8_sysreg(TCR_EL3) "Translation Control Register (EL3)" {
	_	1  mb1 "Reserved, RES1.";
	_	2  mbz "Reserved, RES0.";
	HWU62	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[62] of the stage 1 translation table block or level 3 entry if the TCR_EL3.HPD value is 1.";
	HWU61	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[61] of the stage 1 translation table block or level 3 entry if the TCR_EL3.HPD value is 1.";
	HWU60	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[60] of the stage 1 translation table block or level 3 entry if the TCR_EL3.HPD value is 1.";
	HWU59	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[59] of the stage 1 translation table block or level 3 entry if the TCR_EL3.HPD value is 1.";
	HPD	1   "Hierarchical Permission Disables. This affects the hierarchical control bits, APTable, PXNTable, and UXNTable, except NSTable, in the translation tables pointed to by TTBR0_EL3.";
	_	1  mb1 "Reserved, RES1.";
	HD	1   "Hardware management of dirty state in stage 1 translations from EL3.";
	HA	1   "Hardware Access flag update in stage 1 translations from EL3.";
	TBI	1   "Top Byte ignored - indicates whether the top byte of an address is used for address match for the TTBR0_EL3 region, or ignored and used for tagged addresses.";
	_	1  mbz "Reserved, RES0.";
	PS	3   "Physical Address Size.";
	TG0	2   "Granule size for the TTBR0_EL3.";
	SH0	2   "Shareability attribute for memory associated with translation table walks using TTBR0_EL3.";
	ORGN0	2   "Outer cacheability attribute for memory associated with translation table walks using TTBR0_EL3.";
	IRGN0	2   "Inner cacheability attribute for memory associated with translation table walks using TTBR0_EL3.";
	_	2  mbz "Reserved, RES0.";
	T0SZ	6   "The size offset of the memory region addressed by TTBR0_EL3. The region size is 2(64-T0SZ) bytes.";
};

/* Source: AArch64-icc_iar0_el1.xml */
register ICC_IAR0_EL1 ro armv8_sysreg(ICC_IAR0_EL1) "Interrupt Controller Interrupt Acknowledge Register 0" {
	_	8  mbz "Reserved, RES0.";
	INTID	24   "The INTID of the signaled interrupt.";
};

/* Source: AArch64-actlr_el3.xml */
register ACTLR_EL3 rw armv8_sysreg(ACTLR_EL3) "Auxiliary Control Register (EL3)" {
	IMPLEMENTATION_DEFINED	64   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-id_mmfr4_el1.xml */
register ID_MMFR4_EL1 ro armv8_sysreg(ID_MMFR4_EL1) "AArch32 Memory Model Feature Register 4" {
	_	8  mbz "Reserved, RAZ.";
	LSM	4   "Indicates support for LSMAOE and nTLSMD bits in HSCTLR and SCTLR. Defined values are:";
	HPDS	4   "Hierarchical permission disables bits in translation tables. Defined values are:";
	CnP	4   "Common not Private translations. Defined values are:";
	XNX	4   "Support for execute never control distinction at stage 2 bit. Defined values are:";
	AC2	4   "Indicates the extension of the ACTLR and HACTLR registers using ACTLR2 and HACTLR2. Defined values are:";
	SpecSEI	4   "Describes whether the PE can generate SError interrupt exceptions from speculative reads of memory, including speculative instruction fetches. The defined values of this field are:";
};

/* Source: AArch64-daif.xml */
register DAIF rw armv8_sysreg(DAIF) "Interrupt Mask Bits" {
	_	22  mbz "Reserved, RES0.";
	D	1   "Process state D mask. The possible values of this bit are:";
	A	1   "SError interrupt mask bit. The possible values of this bit are:";
	I	1   "IRQ mask bit. The possible values of this bit are:";
	F	1   "FIQ mask bit. The possible values of this bit are:";
	_	6  mbz "Reserved, RES0.";
};

/* Source: AArch64-elr_el3.xml */
register ELR_EL3 rw armv8_sysreg(ELR_EL3) "Exception Link Register (EL3)" type(uint64);

/* Source: AArch64-dbgprcr_el1.xml */
register DBGPRCR_EL1 rw armv8_sysreg(DBGPRCR_EL1) "Debug Power Control Register" {
	_	31  mbz "Reserved, RES0.";
	CORENPDRQ	1   "Core no powerdown request. Requests emulation of powerdown. Possible values of this bit are:";
};

/* Source: AArch64-pmuserenr_el0.xml */
register PMUSERENR_EL0 rw armv8_sysreg(PMUSERENR_EL0) "Performance Monitors User Enable Register" {
	_	28  mbz "Reserved, RES0.";
	ER	1   "Event counter read trap control:";
	CR	1   "Cycle counter read trap control:";
	SW	1   "Software Increment write trap control:";
	EN	1   "Traps EL0 accesses to the Performance Monitors registers to EL1, from both Execution states:";
};

/* Source: AArch64-cntps_tval_el1.xml */
register CNTPS_TVAL_EL1 rw armv8_sysreg(CNTPS_TVAL_EL1) "Counter-timer Physical Secure Timer TimerValue register" {
	TimerValue	32   "The TimerValue view of the secure physical timer.";
};

/* Source: AArch64-pmselr_el0.xml */
register PMSELR_EL0 rw armv8_sysreg(PMSELR_EL0) "Performance Monitors Event Counter Selection Register" {
	_	27  mbz "Reserved, RES0.";
	SEL	5   "Selects event counter, PMEVCNTR<n>, where n is the value held in this field. This value identifies which event counter is accessed when a subsequent access to PMXEVTYPER_EL0 or PMXEVCNTR_EL0 occurs.";
};

/* Source: AArch64-rmr_el2.xml */
register RMR_EL2 rw armv8_sysreg(RMR_EL2) "Reset Management Register (EL2)" {
	_	30  mbz "Reserved, RES0.";
	RR	1   "Reset Request. Setting this bit to 1 requests a Warm reset.";
	AA64	1   "When EL2 can use AArch32, determines which Execution state the PE boots into after a Warm reset:";
};

/* Source: AArch64-spsr_el1.xml */
register SPSR_EL1 rw armv8_sysreg(SPSR_EL1) "Saved Program Status Register (EL1)" {
	N	1   "Set to the value of the N condition flag on taking an exception to EL1, and copied to the N condition flag on executing an exception return operation in EL1.";
	Z	1   "Set to the value of the Z condition flag on taking an exception to EL1, and copied to the Z condition flag on executing an exception return operation in EL1.";
	C	1   "Set to the value of the C condition flag on taking an exception to EL1, and copied to the C condition flag on executing an exception return operation in EL1.";
	V	1   "Set to the value of the V condition flag on taking an exception to EL1, and copied to the V condition flag on executing an exception return operation in EL1.";
	_	4  mbz "Reserved, RES0.";
	UAO	1   "When  is implemented, set  to the value of PSTATE.UAO on taking an exception to EL1, and copied to PSTATE.UAO on executing an exception return operation in EL1.";
	PAN	1   "When  is implemented, set  to the value of PSTATE.PAN on taking an exception to EL1, and copied to PSTATE.PAN on executing an exception return operation in EL1.";
	SS	1   "Software step. Shows the value of PSTATE.SS immediately before the exception was taken.";
	IL	1   "Illegal Execution state bit. Shows the value of PSTATE.IL immediately before the exception was taken.";
	_	10  mbz "Reserved, RES0.";
	D	1   "Process state D mask. The possible values of this bit are:";
	A	1   "SError interrupt mask bit. The possible values of this bit are:";
	I	1   "IRQ mask bit. The possible values of this bit are:";
	F	1   "FIQ mask bit. The possible values of this bit are:";
	_	1  mbz "Reserved, RES0.";
	M_hi	1   "Execution state that the exception was taken from. Possible values of this bit are:";
	M_lo	4   "AArch64  state (Exception level and selected SP) that an exception was taken from. The possible values are:";
};

/* Source: AArch64-pmswinc_el0.xml */
register PMSWINC_EL0 wo armv8_sysreg(PMSWINC_EL0) "Performance Monitors Software Increment register" {
	_	1  mbz "Reserved, RES0.";
	P	31   "Event counter software increment bit for PMEVCNTR<n>_EL0.";
};

/* Source: AArch64-osdtrtx_el1.xml */
register OSDTRTX_EL1 rw armv8_sysreg(OSDTRTX_EL1) "OS Lock Data Transfer Register, Transmit" type(uint32);

/* Source: AArch64-lorn_el1.xml */
register LORN_EL1 rw armv8_sysreg(LORN_EL1) "LORegion Number (EL1)" {
	_	56  mbz "Reserved, RES0.";
	Num	8   "Number of the LORegion described in the current LORegion descriptor selected by LORC_EL1.DS.";
};

/* Source: AArch64-dbgvcr32_el2.xml */
register DBGVCR32_EL2 rw armv8_sysreg(DBGVCR32_EL2) "Debug Vector Catch Register" {
	NSF	1   "FIQ vector catch enable in Non-secure state.";
	NSI	1   "IRQ vector catch enable in Non-secure state.";
	_	1  mbz "Reserved, RES0.";
	NSD	1   "Data Abort vector catch enable in Non-secure state.";
	NSP	1   "Prefetch Abort vector catch enable in Non-secure state.";
	NSS	1   "Supervisor Call (SVC) vector catch enable in Non-secure state.";
	NSU	1   "Undefined Instruction vector catch enable in Non-secure state.";
	_	17  mbz "Reserved, RES0.";
	SF	1   "FIQ vector catch enable in Secure state.";
	SI	1   "IRQ vector catch enable in Secure state.";
	_	1  mbz "Reserved, RES0.";
	SD	1   "Data Abort vector catch enable in Secure state.";
	SP	1   "Prefetch Abort vector catch enable in Secure state.";
	SS	1   "Supervisor Call (SVC) vector catch enable in Secure state.";
	SU	1   "Undefined Instruction vector catch enable in Secure state.";
	_	1  mbz "Reserved, RES0.";
};

/* Source: AArch64-uao.xml */
register UAO rw armv8_sysreg(UAO) "User Access Override" {
	_	8  mbz "Reserved, RES0.";
	UAO	1   "User Access Override. Defined values are:";
	_	23  mbz "Reserved, RES0.";
};

/* Source: AArch64-spsr_el3.xml */
register SPSR_EL3 rw armv8_sysreg(SPSR_EL3) "Saved Program Status Register (EL3)" {
	N	1   "Set to the value of the N condition flag on taking an exception to EL3, and copied to the N condition flag on executing an exception return operation in EL3.";
	Z	1   "Set to the value of the Z condition flag on taking an exception to EL3, and copied to the Z condition flag on executing an exception return operation in EL3.";
	C	1   "Set to the value of the C condition flag on taking an exception to EL3, and copied to the C condition flag on executing an exception return operation in EL3.";
	V	1   "Set to the value of the V condition flag on taking an exception to EL3, and copied to the V condition flag on executing an exception return operation in EL3.";
	_	4  mbz "Reserved, RES0.";
	UAO	1   "When  is implemented, set  to the value of PSTATE.UAO on taking an exception to EL3, and copied to PSTATE.UAO on executing an exception return operation in EL3.";
	PAN	1   "When  is implemented, set  to the value of PSTATE.PAN on taking an exception to EL3, and copied to PSTATE.PAN on executing an exception return operation in EL3.";
	SS	1   "Software step. Shows the value of PSTATE.SS immediately before the exception was taken.";
	IL	1   "Illegal Execution state bit. Shows the value of PSTATE.IL immediately before the exception was taken.";
	_	10  mbz "Reserved, RES0.";
	D	1   "Process state D mask. The possible values of this bit are:";
	A	1   "SError interrupt mask bit. The possible values of this bit are:";
	I	1   "IRQ mask bit. The possible values of this bit are:";
	F	1   "FIQ mask bit. The possible values of this bit are:";
	_	1  mbz "Reserved, RES0.";
	M_hi	1   "Execution state that the exception was taken from. Possible values of this bit are:";
	M_lo	4   "AArch64  state (Exception level and selected SP) that an exception was taken from. The possible values are:";
};

/* Source: AArch64-cntkctl_el1.xml */
register CNTKCTL_EL1 rw armv8_sysreg(CNTKCTL_EL1) "Counter-timer Kernel Control register" {
	_	22  mbz "Reserved, RES0.";
	EL0PTEN	1   "When  is not implemented, or when HCR_EL2.{E2H, TGE} is not {1, 1}, traps EL0 accesses to the physical timer registers to EL1.";
	EL0VTEN	1   "When  is not implemented, or when HCR_EL2.{E2H, TGE} is not {1, 1}, traps EL0 accesses to the virtual timer registers to EL1.";
	EVNTI	4   "Selects which bit (0 to 15) of the counter register CNTVCT_EL0 is the trigger for the event stream generated from that counter, when that stream is enabled.";
	EVNTDIR	1   "Controls which transition of the counter register CNTVCT_EL0 trigger bit, defined by EVNTI, generates an event when the event stream is enabled:";
	EVNTEN	1   "When  is not implemented, or when HCR_EL2.{E2H, TGE} is not {1, 1}, enables the generation of an event stream from the counter register CNTVCT_EL0:";
	EL0VCTEN	1   "When  is not implemented, or when HCR_EL2.{E2H, TGE} is not {1, 1}, traps EL0 accesses to the frequency register and virtual counter register to EL1.";
	EL0PCTEN	1   "When  is not implemented, or when HCR_EL2.{E2H, TGE} is not {1, 1}, traps EL0 accesses to the frequency register and physical counter register to EL1.";
};

/* Source: AArch64-ctr_el0.xml */
register CTR_EL0 ro armv8_sysreg(CTR_EL0) "Cache Type Register" {
	_	1  mb1 "Reserved, RES1.";
	_	3  mbz "Reserved, RES0.";
	CWG	4   "Cache writeback granule. Log2 of the number of words of the maximum size of memory that can be overwritten as a result of the eviction of a cache entry that has had a memory location in it modified.";
	ERG	4   "Exclusives reservation granule. Log2 of the number of words of the maximum size of the reservation granule that has been implemented for the Load-Exclusive and Store-Exclusive instructions.";
	DminLine	4   "Log2 of the number of words in the smallest cache line of all the data caches and unified caches that are controlled by the PE.";
	L1Ip	2   "Level 1 instruction cache policy. Indicates the indexing and tagging policy for the L1 instruction cache. Possible values of this field are:";
	_	10  mbz "Reserved, RES0.";
	IminLine	4   "Log2 of the number of words in the smallest cache line of all the instruction caches that are controlled by the PE.";
};

/* Source: AArch64-id_aa64mmfr0_el1.xml */
register ID_AA64MMFR0_EL1 ro armv8_sysreg(ID_AA64MMFR0_EL1) "AArch64 Memory Model Feature Register 0" {
	_	32  mbz "Reserved, RES0.";
	TGran4	4   "Support for 4KB memory translation granule size. Defined values are:";
	TGran64	4   "Support for 64KB memory translation granule size. Defined values are:";
	TGran16	4   "Support for 16KB memory translation granule size. Defined values are:";
	BigEndEL0	4   "Mixed-endian support at EL0 only. Defined values are:";
	SNSMem	4   "Secure versus Non-secure Memory distinction. Defined values are:";
	BigEnd	4   "Mixed-endian configuration support. Defined values are:";
	ASIDBits	4   "Number of ASID bits. Defined values are:";
	PARange	4   "Physical Address range supported. Defined values are:";
};

/* Source: AArch64-tpidrro_el0.xml */
register TPIDRRO_EL0 rw armv8_sysreg(TPIDRRO_EL0) "EL0 Read-Only Software Thread ID Register" type(uint64);

/* Source: AArch64-pmevcntrn_el0.xml */
register PMEVCNTR0_EL0 rw armv8_sysreg(PMEVCNTR0_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR1_EL0 rw armv8_sysreg(PMEVCNTR1_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR2_EL0 rw armv8_sysreg(PMEVCNTR2_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR3_EL0 rw armv8_sysreg(PMEVCNTR3_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR4_EL0 rw armv8_sysreg(PMEVCNTR4_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR5_EL0 rw armv8_sysreg(PMEVCNTR5_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR6_EL0 rw armv8_sysreg(PMEVCNTR6_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR7_EL0 rw armv8_sysreg(PMEVCNTR7_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR8_EL0 rw armv8_sysreg(PMEVCNTR8_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR9_EL0 rw armv8_sysreg(PMEVCNTR9_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR10_EL0 rw armv8_sysreg(PMEVCNTR10_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR11_EL0 rw armv8_sysreg(PMEVCNTR11_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR12_EL0 rw armv8_sysreg(PMEVCNTR12_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR13_EL0 rw armv8_sysreg(PMEVCNTR13_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR14_EL0 rw armv8_sysreg(PMEVCNTR14_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR15_EL0 rw armv8_sysreg(PMEVCNTR15_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR16_EL0 rw armv8_sysreg(PMEVCNTR16_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR17_EL0 rw armv8_sysreg(PMEVCNTR17_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR18_EL0 rw armv8_sysreg(PMEVCNTR18_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR19_EL0 rw armv8_sysreg(PMEVCNTR19_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR20_EL0 rw armv8_sysreg(PMEVCNTR20_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR21_EL0 rw armv8_sysreg(PMEVCNTR21_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR22_EL0 rw armv8_sysreg(PMEVCNTR22_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR23_EL0 rw armv8_sysreg(PMEVCNTR23_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR24_EL0 rw armv8_sysreg(PMEVCNTR24_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR25_EL0 rw armv8_sysreg(PMEVCNTR25_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR26_EL0 rw armv8_sysreg(PMEVCNTR26_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR27_EL0 rw armv8_sysreg(PMEVCNTR27_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR28_EL0 rw armv8_sysreg(PMEVCNTR28_EL0) "Performance Monitors Event Count Registers" type(uint32);
register PMEVCNTR29_EL0 rw armv8_sysreg(PMEVCNTR29_EL0) "Performance Monitors Event Count Registers" type(uint32);

/* Source: AArch64-ich_hcr_el2.xml */
register ICH_HCR_EL2 rw armv8_sysreg(ICH_HCR_EL2) "Interrupt Controller Hyp Control Register" {
	EOIcount	5   "This field is incremented whenever a successful write to a virtual EOIR or DIR register would have resulted in a virtual interrupt deactivation.  That is either:";
	_	12  mbz "Reserved, RES0.";
	TDIR	1   "Trap Non-secure EL1 writes to ICC_DIR_EL1 and ICV_DIR_EL1.";
	TSEI	1   "Trap all locally generated SEIs. This bit allows the hypervisor to intercept locally generated SEIs that would otherwise be taken at Non-secure EL1.";
	TALL1	1   "Trap all Non-secure EL1 accesses to ICC_* and ICV_* System registers for Group 1 interrupts to EL2.";
	TALL0	1   "Trap all Non-secure EL1 accesses to ICC_* and ICV_* System registers for Group 0 interrupts to EL2.";
	TC	1   "Trap all Non-secure EL1 accesses to System registers that are common to Group 0 and Group 1 to EL2.";
	_	2  mbz "Reserved, RES0.";
	VGrp1DIE	1   "VM Group 1 Disabled Interrupt Enable. Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected vPE is disabled:";
	VGrp1EIE	1   "VM Group 1 Enabled Interrupt Enable. Enables the signaling of a maintenance interrupt while signaling of Group 1 interrupts from the virtual CPU interface to the connected vPE is enabled:";
	VGrp0DIE	1   "VM Group 0 Disabled Interrupt Enable. Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected vPE is disabled:";
	VGrp0EIE	1   "VM Group 0 Enabled Interrupt Enable. Enables the signaling of a maintenance interrupt while signaling of Group 0 interrupts from the virtual CPU interface to the connected vPE is enabled:";
	NPIE	1   "No Pending Interrupt Enable. Enables the signaling of a maintenance interrupt while no pending interrupts are present in the List registers:";
	LRENPIE	1   "List Register Entry Not Present Interrupt Enable. Enables the signaling of a maintenance interrupt while the virtual CPU interface does not have a corresponding valid List register entry for an EOI request:";
	UIE	1   "Underflow Interrupt Enable. Enables the signaling of a maintenance interrupt when the List registers are empty, or hold only one valid entry:";
	En	1   "Enable. Global enable bit for the virtual CPU interface:";
};

/* Source: AArch64-icc_igrpen1_el3.xml */
register ICC_IGRPEN1_EL3 rw armv8_sysreg(ICC_IGRPEN1_EL3) "Interrupt Controller Interrupt Group 1 Enable register (EL3)" {
	_	30  mbz "Reserved, RES0.";
	EnableGrp1S	1   "Enables Group 1 interrupts for the Secure state.";
	EnableGrp1NS	1   "Enables Group 1 interrupts for the Non-secure state.";
};

/* Source: AArch64-mdcr_el3.xml */
register MDCR_EL3 rw armv8_sysreg(MDCR_EL3) "Monitor Debug Configuration Register (EL3)" {
	_	10  mbz "Reserved, RES0.";
	EPMAD	1   "External debug interface Performance Monitors registers disable. This disables access to these registers by an external debugger:";
	EDAD	1   "External debug interface breakpoint and watchpoint register access disable. This disables access to these registers by an external debugger:";
	_	2  mbz "Reserved, RES0.";
	SPME	1   "Secure Performance Monitors enable. This allows event counting in Secure state:";
	SDD	1   "AArch64 Secure self-hosted invasive debug disable. Disables Software debug exceptions in Secure state, other than Breakpoint Instruction exceptions.";
	SPD32	2   "AArch32 Secure self-hosted privileged invasive debug control. Enables or disables debug exceptions from Secure EL1 using AArch32, other than Breakpoint Instruction exceptions. Valid values for this field are:";
	NSPB	2   "Non-secure Profiling Buffer. When the Statistical Profiling Extension is implemented, this field controls the owning translation regime and accesses to Statistical Profiling and Profiling Buffer control registers. The possible values of this field are:";
	_	1  mbz "Reserved, RES0.";
	TDOSA	1   "Trap debug OS-related register access. Traps EL2 and EL1 System register accesses to the powerdown debug registers to EL3:";
	TDA	1   "Trap Debug Access. Traps EL2, EL1, and EL0 System register accesses to those debug System registers that cannot be trapped using the MDCR_EL3.TDOSA field. When MDCR_EL3.TDA is:";
	_	2  mbz "Reserved, RES0.";
	TPM	1   "Trap Performance Monitors accesses. Traps EL2, EL1, and EL0 accesses to all Performance Monitors registers to EL3, from both Security states and both Execution states.";
	_	6  mbz "Reserved, RES0.";
};

/* Source: AArch64-tpidr_el2.xml */
register TPIDR_EL2 rw armv8_sysreg(TPIDR_EL2) "EL2 Software Thread ID Register" type(uint64);

/* Source: AArch64-spsr_irq.xml */
register SPSR_irq rw armv8_sysreg(SPSR_irq) "Saved Program Status Register (IRQ mode)" {
	N	1   "Set to the value of CPSR.N on taking an exception to IRQ mode, and copied to CPSR.N on executing an exception return operation in IRQ mode.";
	Z	1   "Set to the value of CPSR.Z on taking an exception to IRQ mode, and copied to CPSR.Z on executing an exception return operation in IRQ mode.";
	C	1   "Set to the value of CPSR.C on taking an exception to IRQ mode, and copied to CPSR.C on executing an exception return operation in IRQ mode.";
	V	1   "Set to the value of CPSR.V on taking an exception to IRQ mode, and copied to CPSR.V on executing an exception return operation in IRQ mode.";
	Q	1   "Cumulative saturation bit. Set to 1 to indicate that overflow or saturation occurred in some instructions.";
	IT_lo	2   "IT block state bits for the T32 IT (If-Then) instruction. See IT[7:2] for explanation of this field.";
	J	1   "RES0.";
	_	1  mbz "Reserved, RES0.";
	PAN	1   "When  is implemented, set  to the value of CPSR.PAN on taking an exception to IRQ mode, and copied to CPSR.PAN on executing an exception return operation in IRQ mode.";
	_	1  mbz "Reserved, RES0.";
	IL	1   "Illegal Execution state bit. Shows the value of PSTATE.IL immediately before the exception was taken.";
	GE	4   "Greater than or Equal flags, for parallel addition and subtraction.";
	IT_hi	6   "IT block state bits for the T32 IT (If-Then) instruction. This field must be interpreted in two parts.";
	E	1   "Endianness state bit. Controls the load and store endianness for data accesses:";
	A	1   "SError interrupt mask bit. The possible values of this bit are:";
	I	1   "IRQ mask bit. The possible values of this bit are:";
	F	1   "FIQ mask bit. The possible values of this bit are:";
	T	1   "T32 Instruction set state bit. Determines the AArch32 instruction set state that the exception was taken from. Possible values of this bit are:";
	M_hi	1   "Execution state that the exception was taken from. Possible values of this bit are:";
	M_lo	4   "AArch32 mode that an exception was taken from. The possible values are:";
};

/* Source: AArch64-icc_hppir0_el1.xml */
register ICC_HPPIR0_EL1 ro armv8_sysreg(ICC_HPPIR0_EL1) "Interrupt Controller Highest Priority Pending Interrupt Register 0" {
	_	8  mbz "Reserved, RES0.";
	INTID	24   "The INTID of the highest priority pending interrupt, if that interrupt is observable at the current Security state and Exception level.";
};

/* Source: AArch64-pmceid0_el0.xml */
register PMCEID0_EL0 ro armv8_sysreg(PMCEID0_EL0) "Performance Monitors Common Event Identification register 0" {
	ID_hi	32   "PMCEID0_EL0[63:32] maps to common events 0x4000 to 0x401F. For a list of event numbers and descriptions, see .";
	ID_lo	32   "PMCEID0_EL0[31:0] maps to common events 0x0000 to 0x001F. For a list of event numbers and descriptions, see .";
};

/* Source: AArch64-fpsr.xml */
register FPSR rw armv8_sysreg(FPSR) "Floating-point Status Register" {
	N	1   "Negative condition flag for AArch32 floating-point comparison operations. AArch64 floating-point comparisons set the PSTATE.N flag instead.";
	Z	1   "Zero condition flag for AArch32 floating-point comparison operations. AArch64 floating-point comparisons set the PSTATE.Z flag instead.";
	C	1   "Carry condition flag for AArch32 floating-point comparison operations. AArch64 floating-point comparisons set the PSTATE.C flag instead.";
	V	1   "Overflow condition flag for AArch32 floating-point comparison operations. AArch64 floating-point comparisons set the PSTATE.V flag instead.";
	QC	1   "Cumulative saturation bit, Advanced SIMD only. This bit is set to 1 to indicate that an Advanced SIMD integer operation has saturated since 0 was last written to this bit.";
	_	19  mbz "Reserved, RES0.";
	IDC	1   "Input Denormal cumulative floating-point exception bit. This bit is set to 1 to indicate that the Input Denormal floating-point exception has occurred since 0 was last written to this bit.";
	_	2  mbz "Reserved, RES0.";
	IXC	1   "Inexact cumulative floating-point exception bit. This bit is set to 1 to indicate that the Inexact exception floating-point has occurred since 0 was last written to this bit.";
	UFC	1   "Underflow cumulative floating-point exception bit. This bit is set to 1 to indicate that the Underflow floating-point exception has occurred since 0 was last written to this bit.";
	OFC	1   "Overflow cumulative floating-point exception bit. This bit is set to 1 to indicate that the Overflow floating-point exception has occurred since 0 was last written to this bit.";
	DZC	1   "Divide by Zero cumulative floating-point exception bit. This bit is set to 1 to indicate that the Divide by Zero floating-point exception has occurred since 0 was last written to this bit.";
	IOC	1   "Invalid Operation cumulative floating-point exception bit. This bit is set to 1 to indicate that the Invalid Operation floating-point exception has occurred since 0 was last written to this bit.";
};

/* Source: AArch64-ich_vmcr_el2.xml */
register ICH_VMCR_EL2 rw armv8_sysreg(ICH_VMCR_EL2) "Interrupt Controller Virtual Machine Control Register" {
	VPMR	8   "Virtual Priority Mask. The priority mask level for the virtual CPU interface. If the priority of a pending virtual interrupt is higher than the value indicated by this field, the interface signals the virtual interrupt to the PE.";
	VBPR0	3   "Virtual Binary Point Register, Group 0. Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines Group 0 interrupt preemption, and also determines Group 1 interrupt preemption if ICH_VMCR_EL2.VCBPR == 1.";
	VBPR1	3   "Virtual Binary Point Register, Group 1. Defines the point at which the priority value fields split into two parts, the group priority field and the subpriority field. The group priority field determines Group 1 interrupt preemption if ICH_VMCR_EL2.VCBPR == 0.";
	_	8  mbz "Reserved, RES0.";
	VEOIM	1   "Virtual EOI mode. Controls whether a write to an End of Interrupt register also deactivates the virtual interrupt:";
	_	4  mbz "Reserved, RES0.";
	VCBPR	1   "Virtual Common Binary Point Register. Possible values of this bit are:";
	VFIQEn	1   "Virtual FIQ enable. Possible values of this bit are:";
	VAckCtl	1   "Virtual AckCtl. Possible values of this bit are:";
	VENG1	1   "Virtual Group 1 interrupt enable. Possible values of this bit are:";
	VENG0	1   "Virtual Group 0 interrupt enable. Possible values of this bit are:";
};

/* Source: AArch64-dlr_el0.xml */
register DLR_EL0 rw armv8_sysreg(DLR_EL0) "Debug Link Register" type(uint64);

/* Source: AArch64-spsr_abt.xml */
register SPSR_abt rw armv8_sysreg(SPSR_abt) "Saved Program Status Register (Abort mode)" {
	N	1   "Set to the value of CPSR.N on taking an exception to Abort mode, and copied to CPSR.N on executing an exception return operation in Abort mode.";
	Z	1   "Set to the value of CPSR.Z on taking an exception to Abort mode, and copied to CPSR.Z on executing an exception return operation in Abort mode.";
	C	1   "Set to the value of CPSR.C on taking an exception to Abort mode, and copied to CPSR.C on executing an exception return operation in Abort mode.";
	V	1   "Set to the value of CPSR.V on taking an exception to Abort mode, and copied to CPSR.V on executing an exception return operation in Abort mode.";
	Q	1   "Cumulative saturation bit. Set to 1 to indicate that overflow or saturation occurred in some instructions.";
	IT_lo	2   "IT block state bits for the T32 IT (If-Then) instruction. See IT[7:2] for explanation of this field.";
	J	1   "RES0.";
	_	1  mbz "Reserved, RES0.";
	PAN	1   "When  is implemented, set  to the value of CPSR.PAN on taking an exception to Abort mode, and copied to CPSR.PAN on executing an exception return operation in Abort mode.";
	_	1  mbz "Reserved, RES0.";
	IL	1   "Illegal Execution state bit. Shows the value of PSTATE.IL immediately before the exception was taken.";
	GE	4   "Greater than or Equal flags, for parallel addition and subtraction.";
	IT_hi	6   "IT block state bits for the T32 IT (If-Then) instruction. This field must be interpreted in two parts.";
	E	1   "Endianness state bit. Controls the load and store endianness for data accesses:";
	A	1   "SError interrupt mask bit. The possible values of this bit are:";
	I	1   "IRQ mask bit. The possible values of this bit are:";
	F	1   "FIQ mask bit. The possible values of this bit are:";
	T	1   "T32 Instruction set state bit. Determines the AArch32 instruction set state that the exception was taken from. Possible values of this bit are:";
	M_hi	1   "Execution state that the exception was taken from. Possible values of this bit are:";
	M_lo	4   "AArch32 mode that an exception was taken from. The possible values are:";
};

/* Source: AArch64-mvfr0_el1.xml */
register MVFR0_EL1 ro armv8_sysreg(MVFR0_EL1) "AArch32 Media and VFP Feature Register 0" {
	FPRound	4   "Floating-Point Rounding modes. Indicates whether the floating-point implementation provides support for rounding modes. Defined values are:";
	FPShVec	4   "Short Vectors. Indicates whether the floating-point implementation provides support for the use of short vectors. Defined values are:";
	FPSqrt	4   "Square Root. Indicates whether the floating-point implementation provides support for the ARMv6 VFP square root operations. Defined values are:";
	FPDivide	4   "Indicates whether the floating-point implementation provides support for VFP divide operations. Defined values are:";
	FPTrap	4   "Floating Point Exception Trapping. Indicates whether the floating-point implementation provides support for exception trapping. Defined values are:";
	FPDP	4   "Double Precision. Indicates whether the floating-point implementation provides support for double-precision operations. Defined values are:";
	FPSP	4   "Single Precision. Indicates whether the floating-point implementation provides support for single-precision operations. Defined values are:";
	SIMDReg	4   "Advanced SIMD registers. Indicates whether the Advanced SIMD and floating-point implementation provides support for the Advanced SIMD and floating-point register bank. Defined values are:";
};

/* Source: AArch64-hpfar_el2.xml */
register HPFAR_EL2 rw armv8_sysreg(HPFAR_EL2) "Hypervisor IPA Fault Address Register" {
	_	20  mbz "Reserved, RES0.";
	FIPA_hi	4   "Extension to FIPA[47:12]. See FIPA[47:12] for more details.";
	FIPA_lo	36   "Bits [47:12] of the faulting intermediate physical address. When  is implemented, and 52-bit addresses and a 64KB translation granule are in use, FIPA[51:48] form the upper part of the address value. Otherwise, for implementations with fewer than 52 physical address bits, FIPA[51:48] are RES0.";
	_	4  mbz "Reserved, RES0.";
};

/* Source: AArch64-id_isar5_el1.xml */
register ID_ISAR5_EL1 ro armv8_sysreg(ID_ISAR5_EL1) "AArch32 Instruction Set Attribute Register 5" {
	_	4  mbz "Reserved, RES0.";
	RDM	4   "Indicates whether the VQRDMLAH and VQRDMLSH instructions are implemented in AArch32 state. Defined values are:";
	_	4  mbz "Reserved, RES0.";
	CRC32	4   "Indicates whether the CRC32 instructions are implemented in AArch32 state.";
	SHA2	4   "Indicates whether the SHA2 instructions are implemented in AArch32 state.";
	SHA1	4   "Indicates whether the SHA1 instructions are implemented in AArch32 state.";
	AES	4   "Indicates whether the AES instructions are implemented in AArch32 state.";
	SEVL	4   "Indicates whether the SEVL instruction is implemented in AArch32 state.";
};

/* Source: AArch64-cntps_cval_el1.xml */
register CNTPS_CVAL_EL1 rw armv8_sysreg(CNTPS_CVAL_EL1) "Counter-timer Physical Secure Timer CompareValue register" {
	CompareValue	64   "Holds the secure physical timer CompareValue.";
};

/* Source: AArch64-esr_el1.xml */
register ESR_EL1 rw armv8_sysreg(ESR_EL1) "Exception Syndrome Register (EL1)" {
	EC	6   "Exception Class. Indicates the reason for the exception that this register holds information about. Possible values of this field are:";
	IL	1   "Instruction Length for synchronous exceptions. Possible values of this bit are:";
	ISS	25   "Instruction Specific Syndrome. Architecturally, this field can be defined independently for each defined Exception class. However, in practice, some ISS encodings are used for more than one Exception class.";
};

/* Source: AArch64-vpidr_el2.xml */
register VPIDR_EL2 rw armv8_sysreg(VPIDR_EL2) "Virtualization Processor ID Register" {
	Implementer	8   "The Implementer code. This field must hold an implementer code that has been assigned by ARM. Assigned codes include the following:";
	Variant	4   "An IMPLEMENTATION DEFINED variant number. Typically, this field is used to distinguish between different product variants, or major revisions of a product.";
	Architecture	4   "The permitted values of this field are:";
	PartNum	12   "An IMPLEMENTATION DEFINED primary part number for the device.";
	Revision	4   "An IMPLEMENTATION DEFINED revision number for the device.";
};

/* Source: AArch64-mvfr1_el1.xml */
register MVFR1_EL1 ro armv8_sysreg(MVFR1_EL1) "AArch32 Media and VFP Feature Register 1" {
	SIMDFMAC	4   "Advanced SIMD Fused Multiply-Accumulate. Indicates whether the Advanced SIMD implementation provides fused multiply accumulate instructions. Defined values are:";
	FPHP	4   "Floating Point Half Precision. Indicates the level of half-precision floating-point support. Defined values are:";
	SIMDHP	4   "Advanced SIMD Half Precision. Indicates the level of half-precision floating-point support. Defined values are:";
	SIMDSP	4   "Advanced SIMD Single Precision. Indicates whether the Advanced SIMD and floating-point implementation provides single-precision floating-point instructions. Defined values are:";
	SIMDInt	4   "Advanced SIMD Integer. Indicates whether the Advanced SIMD and floating-point implementation provides integer instructions. Defined values are:";
	SIMDLS	4   "Advanced SIMD Load/Store. Indicates whether the Advanced SIMD and floating-point implementation provides load/store instructions. Defined values are:";
	FPDNaN	4   "Default NaN mode. Indicates whether the floating-point implementation provides support only for the Default NaN mode. Defined values are:";
	FPFtZ	4   "Flush to Zero mode. Indicates whether the floating-point implementation provides support only for the Flush-to-Zero mode of operation. Defined values are:";
};

/* Source: AArch64-sp_el2.xml */
register SP_EL2 rw armv8_sysreg(SP_EL2) "Stack Pointer (EL2)" type(uint64);

/* Source: AArch64-ich_vtr_el2.xml */
register ICH_VTR_EL2 ro armv8_sysreg(ICH_VTR_EL2) "Interrupt Controller VGIC Type Register" {
	PRIbits	3   "Priority bits. The number of virtual priority bits implemented, minus one.";
	PREbits	3   "The number of virtual preemption bits implemented, minus one.";
	IDbits	3   "The number of virtual interrupt identifier bits supported:";
	SEIS	1   "SEI Support. Indicates whether the virtual CPU interface supports generation of SEIs:";
	A3V	1   "Affinity 3 Valid. Possible values are:";
	nV4	1   "Direct injection of virtual interrupts not supported. Possible values are:";
	TDS	1   "Separate trapping of Non-secure EL1 writes to ICV_DIR_EL1 supported.";
	_	14  mbz "Reserved, RES0.";
	ListRegs	5   "The number of implemented List registers, minus one. For example, a value of 0b01111 indicates that the maximum of 16 List registers are implemented.";
};

/* Source: AArch64-vtcr_el2.xml */
register VTCR_EL2 rw armv8_sysreg(VTCR_EL2) "Virtualization Translation Control Register" {
	_	1  mb1 "Reserved, RES1.";
	_	2  mbz "Reserved, RES0.";
	HWU62	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[62] of the stage 2 translation table block or level 3 entry.";
	HWU61	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[61] of the stage 2 translation table block or level 3 entry.";
	HWU60	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[60] of the stage 2 translation table block or level 3 entry.";
	HWU59	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[59] of the stage 2 translation table block or level 3 entry.";
	_	2  mbz "Reserved, RES0.";
	HD	1   "Hardware management of dirty state in stage 2 translations from Non-secure EL0 and EL1.";
	HA	1   "Hardware Access flag update in stage 2 translations from Non-secure EL0 and EL1.";
	_	1  mbz "Reserved, RES0.";
	VS	1   "VMID Size.";
	PS	3   "Physical Address Size.";
	TG0	2   "Granule size for the VTTBR_EL2.";
	SH0	2   "Shareability attribute for memory associated with translation table walks using VTTBR_EL2.";
	ORGN0	2   "Outer cacheability attribute for memory associated with translation table walks using VTTBR_EL2.";
	IRGN0	2   "Inner cacheability attribute for memory associated with translation table walks using VTTBR_EL2.";
	SL0	2   "Starting level of the VTCR_EL2 addressed region. The meaning of this field depends on the value of VTCR_EL2.TG0 (the granule size).";
	T0SZ	6   "The size offset of the memory region addressed by VTTBR_EL2. The region size is 2(64-T0SZ) bytes.";
};

/* Source: AArch64-vttbr_el2.xml */
register VTTBR_EL2 rw armv8_sysreg(VTTBR_EL2) "Virtualization Translation Table Base Register" {
	VMID_hi	8   "Extension to VMID[7:0]. See VMID[7:0] for more details.";
	VMID_lo	8   "The VMID for the translation table.";
	BADDR	47   "Translation table base address, A[47:x] or A[51:x], bits[47:1].";
	CnP	1   "Common not Private. In an implementation that includes , indicates whether each entry that is pointed to by VTTBR_EL2 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of VTTBR_EL2.CnP is 1.";
};

/* Source: AArch64-pmxevcntr_el0.xml */
register PMXEVCNTR_EL0 rw armv8_sysreg(PMXEVCNTR_EL0) "Performance Monitors Selected Event Count Register" {
	PMEVCNTR	32   "Value of the selected event counter, PMEVCNTR<n>_EL0, where n is the value stored in PMSELR_EL0.SEL.";
};

/* Source: AArch64-fpcr.xml */
register FPCR rw armv8_sysreg(FPCR) "Floating-point Control Register" {
	_	5  mbz "Reserved, RES0.";
	AHP	1   "Alternative half-precision control bit:";
	DN	1   "Default NaN mode control bit:";
	FZ	1   "Flush-to-zero mode control bit:";
	RMode	2   "Rounding Mode control field. The encoding of this field is:";
	Stride	2   "This field has no function in AArch64 state, and non-zero values are ignored during execution in AArch64  state. It is included only for context saving and restoration of the AArch32 FPSCR.Stride field.";
	FZ16	1   "When  is implemented, flush-to-zero mode control bit on half-precision data-processing instructions:";
	Len	3   "This field has no function in AArch64 state, and non-zero values are ignored during execution in AArch64  state. It is included only for context saving and restoration of the AArch32 FPSCR.Len field.";
	IDE	1   "Input Denormal floating-point exception trap enable. Possible values are:";
	_	2  mbz "Reserved, RES0.";
	IXE	1   "Inexact floating-point exception trap enable. Possible values are:";
	UFE	1   "Underflow floating-point exception trap enable. Possible values are:";
	OFE	1   "Overflow floating-point exception trap enable. Possible values are:";
	DZE	1   "Divide by Zero floating-point exception trap enable. Possible values are:";
	IOE	1   "Invalid Operation floating-point exception trap enable. Possible values are:";
	_	8  mbz "Reserved, RES0.";
};

/* Source: AArch64-aidr_el1.xml */
register AIDR_EL1 ro armv8_sysreg(AIDR_EL1) "Auxiliary ID Register" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-cnthv_tval_el2.xml */
register CNTHV_TVAL_EL2 rw armv8_sysreg(CNTHV_TVAL_EL2) "Counter-timer Virtual Timer TimerValue register (EL2)" {
	TimerValue	32   "The TimerValue view of the EL2 virtual timer.";
};

/* Source: AArch64-icc_dir_el1.xml */
register ICC_DIR_EL1 wo armv8_sysreg(ICC_DIR_EL1) "Interrupt Controller Deactivate Interrupt Register" {
	_	8  mbz "Reserved, RES0.";
	INTID	24   "The INTID of the interrupt to be deactivated.";
};

/* Source: AArch64-tcr_el2.xml */
register TCR_EL2 rw armv8_sysreg(TCR_EL2) "Translation Control Register (EL2)" {
	_	32  mbz "Reserved, RES0.";
	_	1  mb1 "Reserved, RES1.";
	_	2  mbz "Reserved, RES0.";
	HWU62	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[62] of the stage 1 translation table block or level 3 entry if the TCR_EL2.HPD value is 1.";
	HWU61	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[61] of the stage 1 translation table block or level 3 entry if the TCR_EL2.HPD value is 1.";
	HWU60	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[60] of the stage 1 translation table block or level 3 entry if the TCR_EL2.HPD value is 1.";
	HWU59	1   "Hardware Use. Indicates IMPLEMENTATION DEFINED hardware use of bit[59] of the stage 1 translation table block or level 3 entry if the TCR_EL2.HPD value is 1.";
	HPD	1   "Hierarchical Permission Disables. This affects the hierarchical control bits, APTable, PXNTable, and UXNTable, except NSTable, in the translation tables pointed to by TTBR0_EL2.";
	_	1  mb1 "Reserved, RES1.";
	HD	1   "Hardware management of dirty state in stage 1 translations from EL2.";
	HA	1   "Hardware Access flag update in stage 1 translations from EL2.";
	TBI	1   "Additionally, this affects changes to the program counter, when TBI is 1, caused by:";
	_	1  mbz "Reserved, RES0.";
	PS	3   "Physical Address Size.";
	TG0	2 type(granule)  "Granule size for the TTBR0_EL2.";
	SH0	2 type(shareability)  "Shareability attribute for memory associated with translation table walks using TTBR0_EL2.";
	ORGN0	2 type(cacheability)  "Outer cacheability attribute for memory associated with translation table walks using TTBR0_EL2.";
	IRGN0	2 type(cacheability)  "Inner cacheability attribute for memory associated with translation table walks using TTBR0_EL2.";
	_	2  mbz "Reserved, RES0.";
	T0SZ	6   "The size offset of the memory region addressed by TTBR0_EL2. The region size is 2(64-T0SZ) bytes.";
};

/* Source: AArch64-oslsr_el1.xml */
register OSLSR_EL1 ro armv8_sysreg(OSLSR_EL1) "OS Lock Status Register" {
	_	28  mbz "Reserved, RES0.";
	OSLM_hi	1   "See below for description of the OSLM field.";
	nTT	1   "Not 32-bit access. This bit is always RAZ. It indicates that a 32-bit access is needed to write the key to the OS Lock Access Register.";
	OSLK	1   "OS Lock Status. The possible values are:";
	OSLM_lo	1   "OS lock model implemented. Identifies the form of OS save and restore mechanism implemented. In ARMv8 these bits are as follows:";
};

/* Source: AArch64-revidr_el1.xml */
register REVIDR_EL1 ro armv8_sysreg(REVIDR_EL1) "Revision ID Register" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-icc_eoir1_el1.xml */
register ICC_EOIR1_EL1 wo armv8_sysreg(ICC_EOIR1_EL1) "Interrupt Controller End Of Interrupt Register 1" {
	_	8  mbz "Reserved, RES0.";
	INTID	24   "The INTID from the corresponding ICC_IAR1_EL1 access.";
};

/* Source: AArch64-spsel.xml */
register SPSel rw armv8_sysreg(SPSel) "Stack Pointer Select" {
	_	31  mbz "Reserved, RES0.";
	SP	1   "Stack pointer to use. Possible values of this bit are:";
};

/* Source: AArch64-id_mmfr0_el1.xml */
register ID_MMFR0_EL1 ro armv8_sysreg(ID_MMFR0_EL1) "AArch32 Memory Model Feature Register 0" {
	InnerShr	4   "Innermost Shareability. Indicates the innermost shareability domain implemented. Defined values are:";
	FCSE	4   "Indicates whether the implementation includes the FCSE. Defined values are:";
	AuxReg	4   "Auxiliary Registers. Indicates support for Auxiliary registers. Defined values are:";
	TCM	4   "Indicates support for TCMs and associated DMAs. Defined values are:";
	ShareLvl	4   "Shareability Levels. Indicates the number of shareability levels implemented. Defined values are:";
	OuterShr	4   "Outermost Shareability. Indicates the outermost shareability domain implemented. Defined values are:";
	PMSA	4   "Indicates support for a PMSA. Defined values are:";
	VMSA	4   "Indicates support for a VMSA. Defined values are:";
};

/* Source: AArch64-icc_ap0rn_el1.xml */
regtype ICC_AP0R_EL1_type "Interrupt Controller Active Priorities Group 0 Registers" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};
register ICC_AP0R0_EL1 rw armv8_sysreg(ICC_AP0R0_EL1) "Interrupt Controller Active Priorities Group 0 Registers" type(ICC_AP0R_EL1_type);
register ICC_AP0R1_EL1 rw armv8_sysreg(ICC_AP0R1_EL1) "Interrupt Controller Active Priorities Group 0 Registers" type(ICC_AP0R_EL1_type);
register ICC_AP0R2_EL1 rw armv8_sysreg(ICC_AP0R2_EL1) "Interrupt Controller Active Priorities Group 0 Registers" type(ICC_AP0R_EL1_type);

/* Source: AArch64-id_mmfr2_el1.xml */
register ID_MMFR2_EL1 ro armv8_sysreg(ID_MMFR2_EL1) "AArch32 Memory Model Feature Register 2" {
	HWAccFlg	4   "Hardware Access Flag. In earlier versions of the ARM Architecture, this field indicates support for a Hardware Access flag, as part of the VMSAv7 implementation. Defined values are:";
	WFIStall	4   "Wait For Interrupt Stall. Indicates the support for Wait For Interrupt (WFI) stalling. Defined values are:";
	MemBarr	4   "Memory Barrier. Indicates the supported memory barrier System instructions in the (coproc==1111) encoding space:";
	UniTLB	4   "Unified TLB. Indicates the supported TLB maintenance operations, for a unified TLB implementation. Defined values are:";
	HvdTLB	4   "If the Unified TLB field (UniTLB, bits [19:16]) is not 0000, then the meaning of this field is IMPLEMENTATION DEFINED. ARM deprecates the use of this field by software.";
	L1HvdRng	4   "Level 1 Harvard cache Range. Indicates the supported Level 1 cache maintenance range operations, for a Harvard cache implementation. Defined values are:";
	L1HvdBG	4   "Level 1 Harvard cache Background fetch. Indicates the supported Level 1 cache background fetch operations, for a Harvard cache implementation. When supported, background fetch operations are non-blocking operations. Defined values are:";
	L1HvdFG	4   "Level 1 Harvard cache Foreground fetch. Indicates the supported Level 1 cache foreground fetch operations, for a Harvard cache implementation. When supported, foreground fetch operations are blocking operations. Defined values are:";
};

/* Source: AArch64-pmintenset_el1.xml */
register PMINTENSET_EL1 rw armv8_sysreg(PMINTENSET_EL1) "Performance Monitors Interrupt Enable Set register" {
	C	1   "PMCCNTR_EL0 overflow interrupt request enable bit. Possible values are:";
	P	31   "Event counter overflow interrupt request enable bit for PMEVCNTR<n>_EL0.";
};

/* Source: AArch64-id_isar0_el1.xml */
register ID_ISAR0_EL1 ro armv8_sysreg(ID_ISAR0_EL1) "AArch32 Instruction Set Attribute Register 0" {
	_	4  mbz "Reserved, RES0.";
	Divide	4   "Indicates the implemented Divide instructions. Defined values are:";
	Debug	4   "Indicates the implemented Debug instructions. Defined values are:";
	Coproc	4   "Indicates the implemented System register access instructions. Defined values are:";
	CmpBranch	4   "Indicates the implemented combined Compare and Branch instructions in the T32 instruction set. Defined values are:";
	BitField	4   "Indicates the implemented BitField instructions. Defined values are:";
	BitCount	4   "Indicates the implemented Bit Counting instructions. Defined values are:";
	Swap	4   "Indicates the implemented Swap instructions in the A32 instruction set. Defined values are:";
};

/* Source: AArch64-currentel.xml */
register CurrentEL ro armv8_sysreg(CurrentEL) "Current Exception Level" {
	_	28  mbz "Reserved, RES0.";
	EL	2   "Current Exception level. Possible values of this field are:";
	_	2  mbz "Reserved, RES0.";
};

/* Source: AArch64-actlr_el2.xml */
register ACTLR_EL2 rw armv8_sysreg(ACTLR_EL2) "Auxiliary Control Register (EL2)" {
	IMPLEMENTATION_DEFINED	64   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-ttbr0_el3.xml */
register TTBR0_EL3 rw armv8_sysreg(TTBR0_EL3) "Translation Table Base Register 0 (EL3)" {
	_	16  mbz "Reserved, RES0.";
	BADDR	47   "Translation table base address, A[47:x] or A[51:x].";
	CnP	1   "Common not Private. In an implementation that includes , indicates whether each entry that is pointed to by TTBR0_EL3 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of TTBR0_EL3.CnP is 1.";
};

/* Source: AArch64-icc_rpr_el1.xml */
register ICC_RPR_EL1 ro armv8_sysreg(ICC_RPR_EL1) "Interrupt Controller Running Priority Register" {
	_	24  mbz "Reserved, RES0.";
	Priority	8   "The current running priority on the CPU interface. This is the group priority of the current active interrupt.";
};

/* Source: AArch64-icc_sre_el2.xml */
register ICC_SRE_EL2 rw armv8_sysreg(ICC_SRE_EL2) "Interrupt Controller System Register Enable register (EL2)" {
	_	28  mbz "Reserved, RES0.";
	Enable	1   "Enable. Enables lower Exception level access to ICC_SRE_EL1.";
	DIB	1   "Disable IRQ bypass.";
	DFB	1   "Disable FIQ bypass.";
	SRE	1   "System Register Enable.";
};

/* Source: AArch64-elr_el1.xml */
register ELR_EL1 rw armv8_sysreg(ELR_EL1) "Exception Link Register (EL1)" type(uint64);

/* Source: AArch64-cnthp_ctl_el2.xml */
register CNTHP_CTL_EL2 rw armv8_sysreg(CNTHP_CTL_EL2) "Counter-timer Hypervisor Physical Timer Control register" {
	_	29  mbz "Reserved, RES0.";
	ISTATUS	1   "The status of the timer. This bit indicates whether the timer condition is met:";
	IMASK	1   "Timer interrupt mask bit. Permitted values are:";
	ENABLE	1   "Enables the timer. Permitted values are:";
};

/* Source: AArch64-cntps_ctl_el1.xml */
register CNTPS_CTL_EL1 rw armv8_sysreg(CNTPS_CTL_EL1) "Counter-timer Physical Secure Timer Control register" {
	_	29  mbz "Reserved, RES0.";
	ISTATUS	1   "The status of the timer. This bit indicates whether the timer condition is met:";
	IMASK	1   "Timer interrupt mask bit. Permitted values are:";
	ENABLE	1   "Enables the timer. Permitted values are:";
};

/* Source: AArch64-dbgauthstatus_el1.xml */
register DBGAUTHSTATUS_EL1 ro armv8_sysreg(DBGAUTHSTATUS_EL1) "Debug Authentication Status register" {
	_	24  mbz "Reserved, RES0.";
	SNID	2   "Secure non-invasive debug. Possible values of this field are:";
	SID	2   "Secure invasive debug. Possible values of this field are:";
	NSNID	2   "Non-secure non-invasive debug. Possible values of this field are:";
	NSID	2   "Non-secure invasive debug. Possible values of this field are:";
};

/* Source: AArch64-afsr0_el2.xml */
register AFSR0_EL2 rw armv8_sysreg(AFSR0_EL2) "Auxiliary Fault Status Register 0 (EL2)" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-pmxevtyper_el0.xml */
register PMXEVTYPER_EL0 rw armv8_sysreg(PMXEVTYPER_EL0) "Performance Monitors Selected Event Type Register" type(uint32);

/* Source: AArch64-rmr_el3.xml */
register RMR_EL3 rw armv8_sysreg(RMR_EL3) "Reset Management Register (EL3)" {
	_	30  mbz "Reserved, RES0.";
	RR	1   "Reset Request. Setting this bit to 1 requests a Warm reset.";
	AA64	1   "When EL3 can use AArch32, determines which Execution state the PE boots into after a Warm reset:";
};

/* Source: AArch64-ich_lrn_el2.xml */
regtype ICH_LR_EL2_type "Interrupt Controller List Registers" {
	State	2   "The state of the interrupt:";
	HW	1   "Indicates whether this virtual interrupt maps directly to a hardware interrupt, meaning that it corresponds to a physical interrupt. Deactivation of the virtual interrupt also causes the deactivation of the physical interrupt with the ID that the pINTID field indicates.";
	Group	1   "Indicates the group for this virtual interrupt.";
	_	4  mbz "Reserved, RES0.";
	Priority	8   "The priority of this interrupt.";
	_	6  mbz "Reserved, RES0.";
	pINTID	10   "Physical INTID, for hardware interrupts.";
	vINTID	32   "Virtual INTID of the interrupt.";
};
register ICH_LR0_EL2 rw armv8_sysreg(ICH_LR0_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR1_EL2 rw armv8_sysreg(ICH_LR1_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR2_EL2 rw armv8_sysreg(ICH_LR2_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR3_EL2 rw armv8_sysreg(ICH_LR3_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR4_EL2 rw armv8_sysreg(ICH_LR4_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR5_EL2 rw armv8_sysreg(ICH_LR5_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR6_EL2 rw armv8_sysreg(ICH_LR6_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR7_EL2 rw armv8_sysreg(ICH_LR7_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR8_EL2 rw armv8_sysreg(ICH_LR8_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR9_EL2 rw armv8_sysreg(ICH_LR9_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR10_EL2 rw armv8_sysreg(ICH_LR10_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR11_EL2 rw armv8_sysreg(ICH_LR11_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR12_EL2 rw armv8_sysreg(ICH_LR12_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR13_EL2 rw armv8_sysreg(ICH_LR13_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);
register ICH_LR14_EL2 rw armv8_sysreg(ICH_LR14_EL2) "Interrupt Controller List Registers" type(ICH_LR_EL2_type);

/* Source: AArch64-dbgdtrrx_el0.xml */
register DBGDTRRX_EL0 ro armv8_sysreg(DBGDTRRX_EL0) "Debug Data Transfer Register, Receive" type(uint32);

/* Source: AArch64-icc_eoir0_el1.xml */
register ICC_EOIR0_EL1 wo armv8_sysreg(ICC_EOIR0_EL1) "Interrupt Controller End Of Interrupt Register 0" {
	_	8  mbz "Reserved, RES0.";
	INTID	24   "The INTID from the corresponding ICC_IAR0_EL1 access.";
};

/* Source: AArch64-ttbr0_el2.xml */
register TTBR0_EL2 rw armv8_sysreg(TTBR0_EL2) "Translation Table Base Register 0 (EL2)" {
	ASID	16   "When HCR_EL2.E2H is 0, this field is RES0.";
	BADDR	47   "Translation table base address, A[47:x] or A[51:x], bits[47:1].";
	CnP	1   "Common not Private. In an implementation that includes , indicates whether each entry that is pointed to by TTBR0_EL2 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of TTBR0_EL2.CnP is 1.";
};

/* Source: AArch64-cnthv_cval_el2.xml */
register CNTHV_CVAL_EL2 rw armv8_sysreg(CNTHV_CVAL_EL2) "Counter-timer Virtual Timer CompareValue register (EL2)" {
	CompareValue	64   "Holds the EL2 virtual timer CompareValue.";
};

/* Source: AArch64-icc_igrpen0_el1.xml */
register ICC_IGRPEN0_EL1 rw armv8_sysreg(ICC_IGRPEN0_EL1) "Interrupt Controller Interrupt Group 0 Enable register" {
	_	31  mbz "Reserved, RES0.";
	Enable	1   "Enables Group 0 interrupts.";
};

/* Source: AArch64-tpidr_el3.xml */
register TPIDR_EL3 rw armv8_sysreg(TPIDR_EL3) "EL3 Software Thread ID Register" type(uint64);

/* Source: AArch64-pan.xml */
register PAN rw armv8_sysreg(PAN) "Privileged Access Never" {
	_	9  mbz "Reserved, RES0.";
	PAN	1   "Privileged Access Never. Defined values are:";
	_	22  mbz "Reserved, RES0.";
};

/* Source: AArch64-id_isar2_el1.xml */
register ID_ISAR2_EL1 ro armv8_sysreg(ID_ISAR2_EL1) "AArch32 Instruction Set Attribute Register 2" {
	Reversal	4   "Indicates the implemented Reversal instructions. Defined values are:";
	PSR_AR	4   "Indicates the implemented A and R profile instructions to manipulate the PSR. Defined values are:";
	MultU	4   "Indicates the implemented advanced unsigned Multiply instructions. Defined values are:";
	MultS	4   "Indicates the implemented advanced signed Multiply instructions. Defined values are:";
	Mult	4   "Indicates the implemented additional Multiply instructions. Defined values are:";
	MultiAccessInt	4   "Indicates the support for interruptible multi-access instructions. Defined values are:";
	MemHint	4   "Indicates the implemented Memory Hint instructions. Defined values are:";
	LoadStore	4   "Indicates the implemented additional load/store instructions. Defined values are:";
};

/* Source: AArch64-par_el1.xml */
register PAR_EL1 rw armv8_sysreg(PAR_EL1) "Physical Address Register" {
	ATTR	8   "Memory attributes for the returned output address. This field uses the same encoding as the Attr<n> fields in MAIR_EL1, MAIR_EL2, and MAIR_EL3.";
	_	4  mbz "Reserved, RES0.";
	PA_hi	4   "Extension to PA[47:12]. See PA[47:12] for more details.";
	PA_lo	36   "Output address. The output address (OA) corresponding to the supplied input address. This field returns address bits[47:12].";
	_	1  mb1 "Reserved, RES1.";
	IMP_DEF	1   "IMPLEMENTATION DEFINED.";
	NS	1   "Non-secure. The NS attribute for a translation table entry from a Secure translation regime.";
	SH	2   "Shareability attribute, for the returned output address. Permitted values are:";
	_	6  mbz "Reserved, RES0.";
	F	1   "Indicates whether the instruction performed a successful address translation.";
};

/* Source: AArch64-id_pfr0_el1.xml */
register ID_PFR0_EL1 ro armv8_sysreg(ID_PFR0_EL1) "AArch32 Processor Feature Register 0" {
	RAS	4   "RAS Extension version. The defined values of this field are:";
	_	12  mbz "Reserved, RES0.";
	State3	4   "T32EE instruction set support. Defined values are:";
	State2	4   "Jazelle extension support. Defined values are:";
	State1	4   "T32 instruction set support. Defined values are:";
	State0	4   "A32 instruction set support. Defined values are:";
};

/* Source: AArch64-sder32_el3.xml */
register SDER32_EL3 rw armv8_sysreg(SDER_EL3) "AArch32 Secure Debug Enable Register" {
	_	30  mbz "Reserved, RES0.";
	SUNIDEN	1   "Secure User Non-Invasive Debug Enable:";
	SUIDEN	1   "Secure User Invasive Debug Enable:";
};

/* Source: AArch64-icc_iar1_el1.xml */
register ICC_IAR1_EL1 ro armv8_sysreg(ICC_IAR1_EL1) "Interrupt Controller Interrupt Acknowledge Register 1" {
	_	8  mbz "Reserved, RES0.";
	INTID	24   "The INTID of the signaled interrupt.";
};

/* Source: AArch64-ttbr1_el2.xml */
register TTBR1_EL2 rw armv8_sysreg(TTBR1_EL2) "Translation Table Base Register 1 (EL2)" {
	ASID	16   "An ASID for the translation table base address. The TCR_EL2.A1 field selects either TTBR0_EL2.ASID or TTBR1_EL2.ASID.";
	BADDR	47   "Translation table base address, A[47:x] or A[51:x], bits[47:1].";
	CnP	1   "Common not Private. In an implementation that includes , indicates whether each entry that is pointed to by TBR1_EL2 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of TTBR1_EL2.CnP is 1.";
};

/* Source: AArch64-vbar_el1.xml */
register VBAR_EL1 rw armv8_sysreg(VBAR_EL1) "Vector Base Address Register (EL1)" {
	None	53   "Vector Base Address. Base address of the exception vectors for exceptions taken to EL1.";
	_	11  mbz "Reserved, RES0.";
};

/* Source: AArch64-dbgdtrtx_el0.xml */
register DBGDTRTX_EL0 wo armv8_sysreg(DBGDTRTX_EL0) "Debug Data Transfer Register, Transmit" type(uint32);

/* Source: AArch64-esr_el3.xml */
register ESR_EL3 rw armv8_sysreg(ESR_EL3) "Exception Syndrome Register (EL3)" {
	EC	6   "Exception Class. Indicates the reason for the exception that this register holds information about. Possible values of this field are:";
	IL	1   "Instruction Length for synchronous exceptions. Possible values of this bit are:";
	ISS	25   "Instruction Specific Syndrome. Architecturally, this field can be defined independently for each defined Exception class. However, in practice, some ISS encodings are used for more than one Exception class.";
};

/* Source: AArch64-vbar_el3.xml */
register VBAR_EL3 rw armv8_sysreg(VBAR_EL3) "Vector Base Address Register (EL3)" {
	None	53   "Vector Base Address. Base address of the exception vectors for exceptions taken to EL3.";
	_	11  mbz "Reserved, RES0.";
};

/* Source: AArch64-cntv_ctl_el0.xml */
register CNTV_CTL_EL0 rw armv8_sysreg(CNTV_CTL_EL02) "Counter-timer Virtual Timer Control register" {
	_	29  mbz "Reserved, RES0.";
	ISTATUS	1   "The status of the timer. This bit indicates whether the timer condition is met:";
	IMASK	1   "Timer interrupt mask bit. Permitted values are:";
	ENABLE	1   "Enables the timer. Permitted values are:";
};

/* Source: AArch64-far_el3.xml */
register FAR_EL3 rw armv8_sysreg(FAR_EL3) "Fault Address Register (EL3)" type(uint64);

/* Source: AArch64-scr_el3.xml */
register SCR_EL3 rw armv8_sysreg(SCR_EL3) "Secure Configuration Register" {
	_	16  mbz "Reserved, RES0.";
	TERR	1   "Trap Error record accesses. If the RAS Extension is implemented, the possible values of this bit are:";
	TLOR	1   "Trap LOR registers. Traps accesses to the LORSA_EL1, LOREA_EL1, LORN_EL1, LORC_EL1, and LORID_EL1 registers from EL1 and EL2 to EL3, unless the access has been trapped to EL2.";
	TWE	1   "Traps EL2, EL1, and EL0 execution of WFE instructions to EL3, from both Security states and both Execution states.";
	TWI	1   "Traps EL2, EL1, and EL0 execution of WFI instructions to EL3, from both Security states and both Execution states.";
	ST	1   "Traps Secure EL1 accesses to the Counter-timer Physical Secure timer registers to EL3, from AArch64 state only.";
	RW	1   "Execution state control for lower Exception levels.";
	SIF	1   "Secure instruction fetch. When the PE is in Secure state, this bit disables instruction fetch from Non-secure memory. The possible values for this bit are:";
	HCE	1   "Hypervisor Call instruction enable. Enables HVC instructions at EL3, EL2, and Non-secure EL1, in both Execution states.";
	SMD	1   "Secure Monitor Call disable. Disables SMC instructions at EL1 and above, from both Security states and both Execution states.";
	_	1  mbz "Reserved, RES0.";
	_	2  mb1 "Reserved, RES1.";
	EA	1   "External Abort and SError Interrupt Routing.";
	FIQ	1   "Physical FIQ Routing.";
	IRQ	1   "Physical IRQ Routing.";
	NS	1   "Non-secure bit.";
};

/* Source: AArch64-actlr_el1.xml */
register ACTLR_EL1 rw armv8_sysreg(ACTLR_EL1) "Auxiliary Control Register (EL1)" {
	IMPLEMENTATION_DEFINED	64   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-lorid_el1.xml */
register LORID_EL1 rw armv8_sysreg(LORID_EL1) "LORegionID (EL1)" {
	_	40  mbz "Reserved, RES0.";
	LD	8   "Number of LORegion descriptors supported by the PE. This is an 8-bit binary number.";
	_	8  mbz "Reserved, RES0.";
	LR	8   "Number of LORegions supported by the PE. This is an 8-bit binary number.";
};

/* Source: AArch64-id_afr0_el1.xml */
register ID_AFR0_EL1 ro armv8_sysreg(ID_AFR0_EL1) "AArch32 Auxiliary Feature Register 0" {
	_	16  mbz "Reserved, RES0.";
	IMPLEMENTATION_DEFINED_4	4   "IMPLEMENTATION DEFINED.";
	IMPLEMENTATION_DEFINED_3	4   "IMPLEMENTATION DEFINED.";
	IMPLEMENTATION_DEFINED_2	4   "IMPLEMENTATION DEFINED.";
	IMPLEMENTATION_DEFINED_1	4   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-afsr1_el2.xml */
register AFSR1_EL2 rw armv8_sysreg(AFSR1_EL2) "Auxiliary Fault Status Register 1 (EL2)" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-sctlr_el3.xml */
register SCTLR_EL3 rw armv8_sysreg(SCTLR_EL3) "System Control Register (EL3)" {
	_	2  mbz "Reserved, RES0.";
	_	2  mb1 "Reserved, RES1.";
	_	2  mbz "Reserved, RES0.";
	EE	1   "Endianness of data accesses at EL3, and stage 1 translation table walks in the EL3 translation regime.";
	_	1  mbz "Reserved, RES0.";
	_	2  mb1 "Reserved, RES1.";
	IESB	1   "Implicit Error Synchronizaition Barrier enable. Permitted values are:";
	_	1  mbz "Reserved, RES0.";
	WXN	1   "Write permission implies XN (Execute-never). For the EL3 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:";
	_	1  mb1 "Reserved, RES1.";
	_	1  mbz "Reserved, RES0.";
	_	1  mb1 "Reserved, RES1.";
	_	3  mbz "Reserved, RES0.";
	I	1   "Instruction access Cacheability control, for accesses at EL3:";
	_	1  mb1 "Reserved, RES1.";
	_	5  mbz "Reserved, RES0.";
	_	2  mb1 "Reserved, RES1.";
	SA	1   "SP Alignment check enable. When set to 1, if a load or store instruction executed at EL3 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see .";
	C	1   "Cacheability control, for data accesses.";
	A	1   "Alignment check enable. This is the enable bit for Alignment fault checking at EL3:";
	M	1   "MMU enable for EL3 stage 1 address translation. Possible values of this bit are:";
};

/* Source: AArch64-icc_sgi0r_el1.xml */
register ICC_SGI0R_EL1 wo armv8_sysreg(ICC_SGI0R_EL1) "Interrupt Controller Software Generated Interrupt Group 0 Register" {
	_	8  mbz "Reserved, RES0.";
	Aff3	8   "The affinity 3 value of the affinity path of the cluster for which SGI interrupts will be generated.";
	_	7  mbz "Reserved, RES0.";
	IRM	1   "Interrupt Routing Mode. Determines how the generated interrupts are distributed to PEs. Possible values are:";
	Aff2	8   "The affinity 2 value of the affinity path of the cluster for which SGI interrupts will be generated.";
	_	4  mbz "Reserved, RES0.";
	INTID	4   "The INTID of the SGI.";
	Aff1	8   "The affinity 1 value of the affinity path of the cluster for which SGI interrupts will be generated.";
	TargetList	16   "Target List. The set of PEs for which SGI interrupts will be generated. Each bit corresponds to the PE within a cluster with an Affinity 0 value equal to the bit number.";
};

/* Source: AArch64-icc_bpr0_el1.xml */
register ICC_BPR0_EL1 rw armv8_sysreg(ICC_BPR0_EL1) "Interrupt Controller Binary Point Register 0" {
	_	29  mbz "Reserved, RES0.";
	BinaryPoint	3   "The value of this field controls how the 8-bit interrupt priority field is split into a group priority field, that determines interrupt preemption, and a subpriority field. This is done as follows:";
};

/* Source: AArch64-pmevtypern_el0.xml */
regtype PMEVTYPER_EL0_type "Performance Monitors Event Type Registers" {
	P	1   "Privileged filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:";
	U	1   "User filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:";
	NSK	1   "Non-secure EL1 (kernel) modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.";
	NSU	1   "Non-secure EL0 (Unprivileged) filtering. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.";
	NSH	1   "Non-secure EL2 (Hypervisor) filtering. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.";
	M	1   "Secure EL3 filtering bit. If EL3 is not implemented, this bit is RES0.";
	MT	1   "Multithreading. When the implementation is multi-threaded, the valid values for this bit are:";
	_	9  mbz "Reserved, RES0.";
	evtCount_hi	6   "Extension to evtCount[9:0]. See evtCount[9:0] for more details.";
	evtCount_lo	10   "Event to count. The event number of the event that is counted by event counter PMEVCNTR<n>_EL0.";
};
register PMEVTYPER0_EL0 rw armv8_sysreg(PMEVTYPER0_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER1_EL0 rw armv8_sysreg(PMEVTYPER1_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER2_EL0 rw armv8_sysreg(PMEVTYPER2_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER3_EL0 rw armv8_sysreg(PMEVTYPER3_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER4_EL0 rw armv8_sysreg(PMEVTYPER4_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER5_EL0 rw armv8_sysreg(PMEVTYPER5_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER6_EL0 rw armv8_sysreg(PMEVTYPER6_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER7_EL0 rw armv8_sysreg(PMEVTYPER7_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER8_EL0 rw armv8_sysreg(PMEVTYPER8_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER9_EL0 rw armv8_sysreg(PMEVTYPER9_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER10_EL0 rw armv8_sysreg(PMEVTYPER10_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER11_EL0 rw armv8_sysreg(PMEVTYPER11_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER12_EL0 rw armv8_sysreg(PMEVTYPER12_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER13_EL0 rw armv8_sysreg(PMEVTYPER13_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER14_EL0 rw armv8_sysreg(PMEVTYPER14_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER15_EL0 rw armv8_sysreg(PMEVTYPER15_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER16_EL0 rw armv8_sysreg(PMEVTYPER16_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER17_EL0 rw armv8_sysreg(PMEVTYPER17_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER18_EL0 rw armv8_sysreg(PMEVTYPER18_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER19_EL0 rw armv8_sysreg(PMEVTYPER19_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER20_EL0 rw armv8_sysreg(PMEVTYPER20_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER21_EL0 rw armv8_sysreg(PMEVTYPER21_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER22_EL0 rw armv8_sysreg(PMEVTYPER22_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER23_EL0 rw armv8_sysreg(PMEVTYPER23_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER24_EL0 rw armv8_sysreg(PMEVTYPER24_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER25_EL0 rw armv8_sysreg(PMEVTYPER25_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER26_EL0 rw armv8_sysreg(PMEVTYPER26_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER27_EL0 rw armv8_sysreg(PMEVTYPER27_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER28_EL0 rw armv8_sysreg(PMEVTYPER28_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);
register PMEVTYPER29_EL0 rw armv8_sysreg(PMEVTYPER29_EL0) "Performance Monitors Event Type Registers" type(PMEVTYPER_EL0_type);

/* Source: AArch64-icc_igrpen1_el1.xml */
register ICC_IGRPEN1_EL1 rw armv8_sysreg(ICC_IGRPEN1_EL1) "Interrupt Controller Interrupt Group 1 Enable register" {
	_	31  mbz "Reserved, RES0.";
	Enable	1   "Enables Group 1 interrupts for the current Security state.";
};

/* Source: AArch64-spsr_fiq.xml */
register SPSR_fiq rw armv8_sysreg(SPSR_fiq) "Saved Program Status Register (FIQ mode)" {
	N	1   "Set to the value of CPSR.N on taking an exception to FIQ mode, and copied to CPSR.N on executing an exception return operation in FIQ mode.";
	Z	1   "Set to the value of CPSR.Z on taking an exception to FIQ mode, and copied to CPSR.Z on executing an exception return operation in FIQ mode.";
	C	1   "Set to the value of CPSR.C on taking an exception to FIQ mode, and copied to CPSR.C on executing an exception return operation in FIQ mode.";
	V	1   "Set to the value of CPSR.V on taking an exception to FIQ mode, and copied to CPSR.V on executing an exception return operation in FIQ mode.";
	Q	1   "Cumulative saturation bit. Set to 1 to indicate that overflow or saturation occurred in some instructions.";
	IT_lo	2   "IT block state bits for the T32 IT (If-Then) instruction. See IT[7:2] for explanation of this field.";
	J	1   "RES0.";
	_	1  mbz "Reserved, RES0.";
	PAN	1   "When  is implemented, set  to the value of CPSR.PAN on taking an exception to FIQ mode, and copied to CPSR.PAN on executing an exception return operation in FIQ mode.";
	_	1  mbz "Reserved, RES0.";
	IL	1   "Illegal Execution state bit. Shows the value of PSTATE.IL immediately before the exception was taken.";
	GE	4   "Greater than or Equal flags, for parallel addition and subtraction.";
	IT_hi	6   "IT block state bits for the T32 IT (If-Then) instruction. This field must be interpreted in two parts.";
	E	1   "Endianness state bit. Controls the load and store endianness for data accesses:";
	A	1   "SError interrupt mask bit. The possible values of this bit are:";
	I	1   "IRQ mask bit. The possible values of this bit are:";
	F	1   "FIQ mask bit. The possible values of this bit are:";
	T	1   "T32 Instruction set state bit. Determines the AArch32 instruction set state that the exception was taken from. Possible values of this bit are:";
	M_hi	1   "Execution state that the exception was taken from. Possible values of this bit are:";
	M_lo	4   "AArch32 mode that an exception was taken from. The possible values are:";
};

/* Source: AArch64-id_isar1_el1.xml */
register ID_ISAR1_EL1 ro armv8_sysreg(ID_ISAR1_EL1) "AArch32 Instruction Set Attribute Register 1" {
	Jazelle	4   "Indicates the implemented Jazelle extension instructions. Defined values are:";
	Interwork	4   "Indicates the implemented Interworking instructions. Defined values are:";
	Immediate	4   "Indicates the implemented data-processing instructions with long immediates. Defined values are:";
	IfThen	4   "Indicates the implemented If-Then instructions in the T32 instruction set. Defined values are:";
	Extend	4   "Indicates the implemented Extend instructions. Defined values are:";
	Except_AR	4   "Indicates the implemented A and R profile exception-handling instructions. Defined values are:";
	Except	4   "Indicates the implemented exception-handling instructions in the ARM instruction set. Defined values are:";
	Endian	4   "Indicates the implemented Endian instructions. Defined values are:";
};

/* Source: AArch64-dspsr_el0.xml */
register DSPSR_EL0 rw armv8_sysreg(DSPSR_EL0) "Debug Saved Program Status Register" {
	N	1   "Set to the value of the N condition flag on entering Debug state, and copied to the N condition flag on exiting Debug state.";
	Z	1   "Set to the value of the Z condition flag on entering Debug state, and copied to the Z condition flag on exiting Debug state.";
	C	1   "Set to the value of the C condition flag on entering Debug state, and copied to the C condition flag on exiting Debug state.";
	V	1   "Set to the value of the V condition flag on entering Debug state, and copied to the V condition flag on exiting Debug state.";
	_	4  mbz "Reserved, RES0.";
	UAO	1   "When  is implemented, set  to the value of PSTATE.UAO on entering Debug state, and copied to PSTATE.UAO on exiting Debug state.";
	PAN	1   "When  is implemented, set  to the value of PSTATE.PAN on entering Debug state, and copied to PSTATE.PAN on exiting Debug state.";
	SS	1   "Software step. Shows the value of PSTATE.SS immediately before Debug state was entered.";
	IL	1   "Illegal Execution state bit. Shows the value of PSTATE.IL immediately before Debug state was entered.";
	_	10  mbz "Reserved, RES0.";
	D	1   "Process state D mask. The possible values of this bit are:";
	A	1   "SError interrupt mask bit. The possible values of this bit are:";
	I	1   "IRQ mask bit. The possible values of this bit are:";
	F	1   "FIQ mask bit. The possible values of this bit are:";
	_	1  mbz "Reserved, RES0.";
	M_hi	1   "Execution state that Debug state was entered from. Possible values of this bit are:";
	M_lo	4   "AArch64  state (Exception level and selected SP) that Debug state was entered from. The possible values are:";
};

/* Source: AArch64-id_aa64isar0_el1.xml */
register ID_AA64ISAR0_EL1 ro armv8_sysreg(ID_AA64ISAR0_EL1) "AArch64 Instruction Set Attribute Register 0" {
	_	32  mbz "Reserved, RES0.";
	RDM	4   "SQRDMLAH and SQRDMLSH instructions implemented in AArch64 state. Defined values are:";
	_	4  mbz "Reserved, RES0.";
	Atomic	4   "Atomic instructions implemented in AArch64 state. Defined values are:";
	CRC32	4   "CRC32 instructions implemented in AArch64 state. Defined values are:";
	SHA2	4   "SHA2 instructions implemented in AArch64 state. Defined values are:";
	SHA1	4   "SHA1 instructions implemented in AArch64 state. Defined values are:";
	AES	4   "AES instructions implemented in AArch64 state. Defined values are:";
	_	4  mbz "Reserved, RES0.";
};

/* Source: AArch64-id_aa64pfr0_el1.xml */
register ID_AA64PFR0_EL1 ro armv8_sysreg(ID_AA64PFR0_EL1) "AArch64 Processor Feature Register 0" {
	_	28  mbz "Reserved, RES0.";
	SVE	4   "Scalable Vector Extension. Defined values are:";
	RAS	4   "RAS Extension version. The defined values of this field are:";
	GIC	4   "System register GIC interface support. Defined values are:";
	AdvSIMD	4 type(ID_FEATURE)  "Advanced SIMD. Defined values are:";
	FP	4 type(ID_FEATURE)  "Floating-point. Defined values are:";
	EL3	4 type(EL_IMPLEMENTED)  "EL3 Exception level handling. Defined values are:";
	EL2	4 type(EL_IMPLEMENTED)  "EL2 Exception level handling. Defined values are:";
	EL1	4 type(EL_IMPLEMENTED)  "EL1 Exception level handling. Defined values are:";
	EL0	4 type(EL_IMPLEMENTED)  "EL0 Exception level handling. Defined values are:";
};

/* Source: AArch64-rvbar_el1.xml */
register RVBAR_EL1 ro armv8_sysreg(RVBAR_EL1) "Reset Vector Base Address Register (if EL2 and EL3 not implemented)" type(uint64);

/* Source: AArch64-dczid_el0.xml */
register DCZID_EL0 ro armv8_sysreg(DCZID_EL0) "Data Cache Zero ID register" {
	_	27  mbz "Reserved, RES0.";
	DZP	1   "Data Zero prohibited. Permitted values are:";
	BS	4   "Log2 of the block size in words. The maximum size supported is 2KB (value == 9).";
};

/* Source: AArch64-id_dfr0_el1.xml */
register ID_DFR0_EL1 ro armv8_sysreg(ID_DFR0_EL1) "AArch32 Debug Feature Register 0" {
	_	4  mbz "Reserved, RES0.";
	PerfMon	4   "Performance Monitors. Support for System registers-based ARM Performance Monitors Extension, using registers in the coproc == 1111 encoding space, for A and R profile processors. Defined values are:";
	MProfDbg	4   "M Profile Debug. Support for memory-mapped debug model for M profile processors. Defined values are:";
	MMapTrc	4   "Memory Mapped Trace. Support for memory-mapped trace model. Defined values are:";
	CopTrc	4   "Support for System registers-based trace model, using registers in the coproc == 1110 encoding space. Defined values are:";
	MMapDbg	4   "Memory Mapped Debug. Support for v7 memory-mapped debug model, for A and R profile processors.";
	CopSDbg	4   "Support for  a System registers-based Secure debug model, using registers in the coproc = 1110 encoding space, for an A profile processor that includes EL3.";
	CopDbg	4   "Support for System registers-based debug model, using registers in the coproc == 1110 encoding space, for A and R profile processors. Defined values are:";
};

/* Source: AArch64-spsr_el2.xml */
register SPSR_EL2 rw armv8_sysreg(SPSR_EL2) "Saved Program Status Register (EL2)" {
	N	1   "Set to the value of the N condition flag on taking an exception to EL2, and copied to the N condition flag on executing an exception return operation in EL2.";
	Z	1   "Set to the value of the Z condition flag on taking an exception to EL2, and copied to the Z condition flag on executing an exception return operation in EL2.";
	C	1   "Set to the value of the C condition flag on taking an exception to EL2, and copied to the C condition flag on executing an exception return operation in EL2.";
	V	1   "Set to the value of the V condition flag on taking an exception to EL2, and copied to the V condition flag on executing an exception return operation in EL2.";
	_	4  mbz "Reserved, RES0.";
	UAO	1   "When  is implemented, set  to the value of PSTATE.UAO on taking an exception to EL2, and copied to PSTATE.UAO on executing an exception return operation in EL2.";
	PAN	1   "When  is implemented, set  to the value of PSTATE.PAN on taking an exception to EL2, and copied to PSTATE.PAN on executing an exception return operation in EL2.";
	SS	1   "Software step. Shows the value of PSTATE.SS immediately before the exception was taken.";
	IL	1   "Illegal Execution state bit. Shows the value of PSTATE.IL immediately before the exception was taken.";
	_	10  mbz "Reserved, RES0.";
	D	1   "Process state D mask. The possible values of this bit are:";
	A	1   "SError interrupt mask bit. The possible values of this bit are:";
	I	1   "IRQ mask bit. The possible values of this bit are:";
	F	1   "FIQ mask bit. The possible values of this bit are:";
	_	1  mbz "Reserved, RES0.";
	M_hi	1   "Execution state that the exception was taken from. Possible values of this bit are:";
	M_lo	4   "AArch64  state (Exception level and selected SP) that an exception was taken from. The possible values are:";
};

/* Source: AArch64-mdccsr_el0.xml */
register MDCCSR_EL0 ro armv8_sysreg(MDCCSR_EL0) "Monitor DCC Status Register" {
	_	1  mbz "Reserved, RES0.";
	RXfull	1   "DTRRX full. Read-only view of the equivalent bit in the EDSCR.";
	TXfull	1   "DTRTX full. Read-only view of the equivalent bit in the EDSCR.";
	_	10  mbz "Reserved, RES0.";
	_	4  mbz "RAZ/WI. Hardware must implement this field as RAZ/WI. Software must not rely on the register reading as zero, and must use a read-modify-write sequence to write to the register.";
	_	2  mbz "Reserved, RES0.";
	_	1  mbz "RAZ/WI. Hardware must implement this field as RAZ/WI. Software must not rely on the register reading as zero, and must use a read-modify-write sequence to write to the register.";
	_	6  mbz "Reserved, RES0.";
	_	4  mbz "RAZ/WI. Hardware must implement this field as RAZ/WI. Software must not rely on the register reading as zero, and must use a read-modify-write sequence to write to the register.";
	_	2  mbz "Reserved, RES0.";
};

/* Source: AArch64-ttbr0_el1.xml */
register TTBR0_EL1 rw armv8_sysreg(TTBR0_EL1) "Translation Table Base Register 0 (EL1)" {
	ASID	16   "An ASID for the translation table base address. The TCR_EL1.A1 field selects either TTBR0_EL1.ASID or TTBR1_EL1.ASID.";
	BADDR	47   "Translation table base address, A[47:x] or A[51:x], bits[47:1].";
	CnP	1   "Common not Private. In an implementation that includes , indicates whether each entry that is pointed to by TTBR0_EL1 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of TTBR0_EL1.CnP is 1.";
};

/* Source: AArch64-pmceid1_el0.xml */
register PMCEID1_EL0 ro armv8_sysreg(PMCEID1_EL0) "Performance Monitors Common Event Identification register 1" {
	ID_hi	32   "PMCEID1_EL0[63:32] maps to common events 0x4020 to 0x403F. For a list of event numbers and descriptions, see .";
	ID_lo	32   "PMCEID1_EL0[31:0] maps to common events 0x0020 to 0x003F. For a list of event numbers and descriptions, see .";
};

/* Source: AArch64-ich_ap1rn_el2.xml */
regtype ICH_AP1R_EL2_type "Interrupt Controller Hyp Active Priorities Group 1 Registers" {
	P	32   "Group 1 interrupt active priorities. Possible values of each bit are:";
};
register ICH_AP1R0_EL2 rw armv8_sysreg(ICH_AP1R0_EL2) "Interrupt Controller Hyp Active Priorities Group 1 Registers" type(ICH_AP1R_EL2_type);
register ICH_AP1R1_EL2 rw armv8_sysreg(ICH_AP1R1_EL2) "Interrupt Controller Hyp Active Priorities Group 1 Registers" type(ICH_AP1R_EL2_type);
register ICH_AP1R2_EL2 rw armv8_sysreg(ICH_AP1R2_EL2) "Interrupt Controller Hyp Active Priorities Group 1 Registers" type(ICH_AP1R_EL2_type);

/* Source: AArch64-icc_pmr_el1.xml */
register ICC_PMR_EL1 rw armv8_sysreg(ICC_PMR_EL1) "Interrupt Controller Interrupt Priority Mask Register" {
	_	24  mbz "Reserved, RES0.";
	Priority	8   "The priority mask level for the CPU interface. If the priority of an interrupt is higher than the value indicated by this field, the interface signals the interrupt to the PE.";
};

/* Source: AArch64-hacr_el2.xml */
register HACR_EL2 rw armv8_sysreg(HACR_EL2) "Hypervisor Auxiliary Control Register" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-icc_ap1rn_el1.xml */
regtype ICC_AP1R_EL1_type "Interrupt Controller Active Priorities Group 1 Registers" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};
register ICC_AP1R0_EL1 rw armv8_sysreg(ICC_AP1R0_EL1) "Interrupt Controller Active Priorities Group 1 Registers" type(ICC_AP1R_EL1_type);
register ICC_AP1R1_EL1 rw armv8_sysreg(ICC_AP1R1_EL1) "Interrupt Controller Active Priorities Group 1 Registers" type(ICC_AP1R_EL1_type);
register ICC_AP1R2_EL1 rw armv8_sysreg(ICC_AP1R2_EL1) "Interrupt Controller Active Priorities Group 1 Registers" type(ICC_AP1R_EL1_type);

/* Source: AArch64-ich_misr_el2.xml */
register ICH_MISR_EL2 ro armv8_sysreg(ICH_MISR_EL2) "Interrupt Controller Maintenance Interrupt State Register" {
	_	24  mbz "Reserved, RES0.";
	VGrp1D	1   "vPE Group 1 Disabled.";
	VGrp1E	1   "vPE Group 1 Enabled.";
	VGrp0D	1   "vPE Group 0 Disabled.";
	VGrp0E	1   "vPE Group 0 Enabled.";
	NP	1   "No Pending.";
	LRENP	1   "List Register Entry Not Present.";
	U	1   "Underflow.";
	EOI	1   "End Of Interrupt.";
};

/* Source: AArch64-id_aa64isar1_el1.xml */
register ID_AA64ISAR1_EL1 ro armv8_sysreg(ID_AA64ISAR1_EL1) "AArch64 Instruction Set Attribute Register 1" {
	_	60  mbz "Reserved, RES0.";
	DPB	4   "Indicates support for the DC CVAP instruction in AArch64 state. Defined values are:";
};

/* Source: AArch64-cptr_el3.xml */
register CPTR_EL3 rw armv8_sysreg(CPTR_EL3) "Architectural Feature Trap Register (EL3)" {
	TCPAC	1   "Traps all of the following to EL3, from both Security states and both Execution states.";
	_	10  mbz "Reserved, RES0.";
	TTA	1   "Traps System register accesses to the trace registers, from all Exception levels, both Security states, and both Execution states, to EL3.";
	_	9  mbz "Reserved, RES0.";
	TFP	1   "Traps all accesses to SVE, Advanced SIMD and floating-point functionality, from all Exception levels, both Security states, and both Execution states, to EL3. Defined values are:";
	_	1  mbz "Reserved, RES0.";
	EZ	1   "Present only if  is implemented.";
	_	8  mbz "Reserved, RES0.";
};

/* Source: AArch64-hcr_el2.xml */
register HCR_EL2 rw armv8_sysreg(HCR_EL2) "Hypervisor Configuration Register" {
	_	25  mbz "Reserved, RES0.";
	MIOCNCE	1   "Mismatched Inner/Outer Cacheable Non-Coherency Enable, for the Non-secure EL1&0 translation regime.";
	TEA	1   "Route synchronous External Abort exceptions to EL2. If the RAS Extension is implemented, the possible values of this bit are:";
	TERR	1   "Trap Error record accesses. If the RAS Extension is implemented, the possible values of this bit are:";
	TLOR	1   "Trap LOR registers. Traps accesses to the LORSA_EL1, LOREA_EL1, LORN_EL1, LORC_EL1, and LORID_EL1 registers from Non-secure EL1 to EL2.";
	E2H	1   "EL2 Host. Enables a configuration where a Host Operating System is running in EL2, and the Host Operating System's applications are running in EL0.";
	ID	1   "Stage 2 Instruction access cacheability disable. For the Non-secure EL1&0 translation regime, when HCR_EL2.VM==1, this control forces all stage 2 translations for instruction accesses to Normal memory to be Non-cacheable.";
	CD	1   "Stage 2 Data access cacheability disable. For the Non-secure EL1&0 translation regime, when HCR_EL2.VM==1, this control forces all stage 2 translations for data accesses and translation table walks to Normal memory to be Non-cacheable.";
	RW	1   "Execution state control for lower Exception levels:";
	TRVM	1   "Trap Reads of Virtual Memory controls. Traps Non-secure EL1 reads of the virtual memory control registers to EL2, from both Execution states. The registers for which read accesses are trapped are as follows:";
	HCD	1   "HVC instruction disable. Disables Non-secure state execution of HVC instructions, from both Execution states.";
	TDZ	1   "Trap DC ZVA instructions. Traps Non-secure EL0 and EL1 execution of DC ZVA instructions to EL2, from AArch64 state only.";
	TGE	1   "Trap General Exceptions, from Non-secure EL0.";
	TVM	1   "Trap Virtual Memory controls. Traps Non-secure EL1 writes to the virtual memory control registers to EL2, from both Execution states. The registers for which write accesses are trapped are as follows:";
	TTLB	1   "Trap TLB maintenance instructions. Traps Non-secure EL1 execution of TLB maintenance instructions to EL2, from both Execution states. This applies to the following instructions:";
	TPU	1   "Trap cache maintenance instructions that operate to the Point of Unification. Traps execution of those cache maintenance instructions at Non-secure EL1 or EL0 using AArch64, and at Non-secure EL1 using AArch32, to EL2. This applies to the following instructions:";
	TPCP	1   "Trap data or unified cache maintenance instructions that operate to the Point of Coherency or Persistence. Traps execution of those cache maintenance instructions at Non-secure EL1 or EL0 using AArch64, and at Non-secure EL1 using AArch32, to EL2. This applies to the following instructions:";
	TSW	1   "Trap data or unified cache maintenance instructions that operate by Set/Way. Traps execution of those cache maintenance instructions at Non-secure EL1 using AArch64, and at Non-secure EL1 using AArch32, to EL2. This applies to the following instructions:";
	TACR	1   "Trap Auxiliary Control Registers. Traps Non-secure EL1 accesses to the Auxiliary Control Registers to EL2, from both Execution states. This applies to the following register accesses:";
	TIDCP	1   "Trap IMPLEMENTATION DEFINED functionality. Traps Non-secure EL1 accesses to the encodings reserved for IMPLEMENTATION DEFINED functionality to EL2. This applies to the following register accesses:";
	TSC	1   "Trap SMC instructions. Traps Non-secure EL1 execution of SMC instructions to EL2, from both Execution states.";
	TID3	1   "Trap ID group 3. Traps Non-secure EL1 reads of the following registers to EL2:";
	TID2	1   "Trap ID group 2. Traps the following register accesses to EL2:";
	TID1	1   "Trap ID group 1. Traps Non-secure EL1 reads of the following registers are trapped to EL2:";
	TID0	1   "Trap ID group 0.  Traps the following register accesses to EL2:";
	TWE	1   "Traps Non-secure EL0 and EL1 execution of WFE instructions to EL2, from both Execution states.";
	TWI	1   "Traps Non-secure EL0 and EL1 execution of WFI instructions to EL2, from both Execution states.";
	DC	1   "This field is permitted to be cached in a TLB.";
	BSU	2   "Barrier Shareability upgrade. This field determines the minimum shareability domain that is applied to any barrier instruction executed from Non-secure EL1 or Non-secure EL0:";
	FB	1   "Force broadcast. Causes the following instructions to be broadcast within the Inner Shareable domain when executed from Non-secure EL1:";
	VSE	1   "Virtual SError interrupt.";
	VI	1   "Virtual IRQ Interrupt.";
	VF	1   "Virtual FIQ Interrupt.";
	AMO	1   "Physical SError Interrupt routing.";
	IMO	1   "Physical IRQ Routing.";
	FMO	1   "Physical FIQ Routing.";
	PTW	1   "Protected Table Walk. In the Non-secure EL1&0 translation regime, a translation table access made as part of a stage 1 translation table walk is subject to a stage 2 translation. The combining of the memory type attributes from the two stages of translation means the access might be made to a type of Device memory. If this occurs then the value of this bit determines the behavior:";
	SWIO	1   "Set/Way Invalidation Override. Causes Non-secure EL1 execution of the data cache invalidate by set/way instructions to perform a data cache clean and invalidate by set/way:";
	VM	1   "Virtualization enable. Enables stage 2 address translation for the Non-secure EL1&0 translation regime. Possible values of this bit are:";
};

/* Source: AArch64-sctlr_el2.xml */
register SCTLR_EL2 rw armv8_sysreg(SCTLR_EL2) "System Control Register (EL2)" {
	_	2  mbz "Reserved, RES0.";
	_	2  mb1 "Reserved, RES1.";
	_	2  mbz "Reserved, RES0.";
	EE	1   "Endianness of data accesses at EL2, stage 1 translation table walks in the EL2 or EL2&0 translation regime, and stage 2 translation table walks in the EL1&0 translation regime.";
	_	1  mbz "Reserved, RES0.";
	_	2  mb1 "Reserved, RES1.";
	_	2  mbz "Reserved, RES0.";
	WXN	1   "Write permission implies XN (Execute-never). For the EL2 or EL2&0 translation regime, this bit can force all memory regions that are writable to be treated as XN. The possible values of this bit are:";
	_	1  mb1 "Reserved, RES1.";
	_	1  mbz "Reserved, RES0.";
	_	1  mb1 "Reserved, RES1.";
	_	3  mbz "Reserved, RES0.";
	I	1   "Instruction access Cacheability control, for accesses at EL2:";
	_	1  mb1 "Reserved, RES1.";
	_	5  mbz "Reserved, RES0.";
	_	2  mb1 "Reserved, RES1.";
	SA	1   "SP Alignment check enable. When set to 1, if a load or store instruction executed at EL2 uses the SP as the base address and the SP is not aligned to a 16-byte boundary, then a SP alignment fault exception is generated. For more information, see .";
	C	1   "Cacheability control, for data accesses.";
	A	1   "Alignment check enable. This is the enable bit for Alignment fault checking at EL2:";
	M	1   "MMU enable for EL2 stage 1 address translation. Possible values of this bit are:";
};

/* Source: AArch64-rvbar_el3.xml */
register RVBAR_EL3 ro armv8_sysreg(RVBAR_EL3) "Reset Vector Base Address Register (if EL3 implemented)" type(uint64);

/* Source: AArch64-mpidr_el1.xml */
register MPIDR_EL1 ro armv8_sysreg(MPIDR_EL1) "Multiprocessor Affinity Register" {
	_	24  mbz "Reserved, RES0.";
	Aff3	8   "Affinity level 3. Highest level affinity field.";
	_	1  mb1 "Reserved, RES1.";
	U	1   "Indicates a Uniprocessor system, as distinct from PE 0 in a multiprocessor system. The possible values of this bit are:";
	_	5  mbz "Reserved, RES0.";
	MT	1   "Indicates whether the lowest level of affinity consists of logical PEs that are implemented using a multithreading type approach. The possible values of this bit are:";
	Aff2	8   "Affinity level 2. Second highest level affinity field.";
	Aff1	8   "Affinity level 1. Third highest level affinity field.";
	Aff0	8   "Affinity level 0. Lowest level affinity field.";
};

/* Source: AArch64-dbgclaimset_el1.xml */
register DBGCLAIMSET_EL1 rw armv8_sysreg(DBGCLAIMSET_EL1) "Debug Claim Tag Set register" {
	_	24  mbz "Reserved, RAZ/SBZ. Software can rely on these bits reading as zero, and must use a should-be-zero policy on writes. Implementations must ignore writes.";
	CLAIM	8   "Set CLAIM tag bits. RAO.";
};

/* Source: AArch64-id_aa64dfr0_el1.xml */
register ID_AA64DFR0_EL1 ro armv8_sysreg(ID_AA64DFR0_EL1) "AArch64 Debug Feature Register 0" {
	_	28  mbz "Reserved, RES0.";
	PMSVer	4   "Statistical Profiling Extension version. When the Statistical Profiling Extension is implemented, the defined values of this field are:";
	CTX_CMPs	4   "Number of breakpoints that are context-aware, minus 1. These are the highest numbered breakpoints.";
	_	4  mbz "Reserved, RES0.";
	WRPs	4   "Number of watchpoints, minus 1. The value of 0b0000 is reserved.";
	_	4  mbz "Reserved, RES0.";
	BRPs	4   "Number of breakpoints, minus 1. The value of 0b0000 is reserved.";
	PMUVer	4   "Performance Monitors Extension version. Indicates whether System register interface to Performance Monitors extension is implemented. Defined values are:";
	TraceVer	4   "Trace support. Indicates whether System register interface to a trace macrocell is implemented. Defined values are:";
	DebugVer	4   "Debug architecture version. Indicates presence of ARMv8 debug architecture.";
};

/* Source: AArch64-id_pfr1_el1.xml */
register ID_PFR1_EL1 ro armv8_sysreg(ID_PFR1_EL1) "AArch32 Processor Feature Register 1" {
	GIC	4   "System register GIC CPU interface. Defined values are:";
	Virt_frac	4   "Virtualization fractional field. When the Virtualization field is 0000, determines the support for features from the ARMv7 Virtualization Extensions. Defined values are:";
	Sec_frac	4   "Security fractional field. When the Security field is 0000, determines the support for features from the ARMv7 Security Extensions. Defined values are:";
	GenTimer	4   "Generic Timer support. Defined values are:";
	Virtualization	4   "Virtualization support. Defined values are:";
	MProgMod	4   "M profile programmers' model support. Defined values are:";
	Security	4   "Security support. Defined values are:";
	ProgMod	4   "Support for the standard programmers' model for ARMv4 and later. Model must support User, FIQ, IRQ, Supervisor, Abort, Undefined, and System modes. Defined values are:";
};

/* Source: AArch64-vmpidr_el2.xml */
register VMPIDR_EL2 rw armv8_sysreg(VMPIDR_EL2) "Virtualization Multiprocessor ID Register" {
	_	24  mbz "Reserved, RES0.";
	Aff3	8   "Affinity level 3. Highest level affinity field.";
	_	1  mb1 "Reserved, RES1.";
	U	1   "Indicates a Uniprocessor system, as distinct from PE 0 in a multiprocessor system. The possible values of this bit are:";
	_	5  mbz "Reserved, RES0.";
	MT	1   "Indicates whether the lowest level of affinity consists of logical PEs that are implemented using a multithreading type approach. The possible values of this bit are:";
	Aff2	8   "Affinity level 2. Second highest level affinity field.";
	Aff1	8   "Affinity level 1. Third highest level affinity field.";
	Aff0	8   "Affinity level 0. Lowest level affinity field.";
};

/* Source: AArch64-afsr0_el1.xml */
register AFSR0_EL1 rw armv8_sysreg(AFSR0_EL1) "Auxiliary Fault Status Register 0 (EL1)" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-dbgwvrn_el1.xml */
regtype DBGWVR_EL1_type "Debug Watchpoint Value Registers" {
	RESS_lo	11   "Reserved, Sign extended. Hardware and software must treat this field as RES0 if the most significant bit of VA is 0 or RES0, and as RES1 if the most significant bit of VA is 1.";
	VA_hi	4   "Extension to VA[48:2]. See VA[48:2] for more details.";
	VA_lo	47   "Bits[48:2] of the address value for comparison.";
	_	2  mbz "Reserved, RES0.";
};
register DBGWVR0_EL1 rw armv8_sysreg(DBGWVR0_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR1_EL1 rw armv8_sysreg(DBGWVR1_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR2_EL1 rw armv8_sysreg(DBGWVR2_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR3_EL1 rw armv8_sysreg(DBGWVR3_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR4_EL1 rw armv8_sysreg(DBGWVR4_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR5_EL1 rw armv8_sysreg(DBGWVR5_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR6_EL1 rw armv8_sysreg(DBGWVR6_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR7_EL1 rw armv8_sysreg(DBGWVR7_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR8_EL1 rw armv8_sysreg(DBGWVR8_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR9_EL1 rw armv8_sysreg(DBGWVR9_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR10_EL1 rw armv8_sysreg(DBGWVR10_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR11_EL1 rw armv8_sysreg(DBGWVR11_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR12_EL1 rw armv8_sysreg(DBGWVR12_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR13_EL1 rw armv8_sysreg(DBGWVR13_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);
register DBGWVR14_EL1 rw armv8_sysreg(DBGWVR14_EL1) "Debug Watchpoint Value Registers" type(DBGWVR_EL1_type);

/* Source: AArch64-pmccntr_el0.xml */
register PMCCNTR_EL0 rw armv8_sysreg(PMCCNTR_EL0) "Performance Monitors Cycle Count Register" {
	CCNT	64   "Cycle count. Depending on the values of PMCR_EL0.{LC,D}, this field increments in one of the following ways:";
};

/* Source: AArch64-nzcv.xml */
register NZCV rw armv8_sysreg(NZCV) "Condition Flags" {
	N	1   "Negative condition flag. Set to 1 if the result of the last flag-setting instruction was negative.";
	Z	1   "Zero condition flag. Set to 1 if the result of the last flag-setting instruction was zero, and to 0 otherwise. A result of zero often indicates an equal result from a comparison.";
	C	1   "Carry condition flag. Set to 1 if the last flag-setting instruction resulted in a carry condition, for example an unsigned overflow on an addition.";
	V	1   "Overflow condition flag. Set to 1 if the last flag-setting instruction resulted in an overflow condition, for example a signed overflow on an addition.";
	_	28  mbz "Reserved, RES0.";
};

/* Source: AArch64-mdccint_el1.xml */
register MDCCINT_EL1 rw armv8_sysreg(MDCCINT_EL1) "Monitor DCC Interrupt Enable Register" {
	_	1  mbz "Reserved, RES0.";
	RX	1   "DCC interrupt request enable control for DTRRX. Enables a common COMMIRQ interrupt request to be signaled based on the DCC status flags.";
	TX	1   "DCC interrupt request enable control for DTRTX. Enables a common COMMIRQ interrupt request to be signaled based on the DCC status flags.";
	_	29  mbz "Reserved, RES0.";
};

/* Source: AArch64-icc_hppir1_el1.xml */
register ICC_HPPIR1_EL1 ro armv8_sysreg(ICC_HPPIR1_EL1) "Interrupt Controller Highest Priority Pending Interrupt Register 1" {
	_	8  mbz "Reserved, RES0.";
	INTID	24   "The INTID of the highest priority pending interrupt, if that interrupt is observable at the current Security state and Exception level.";
};

/* Source: AArch64-osdtrrx_el1.xml */
register OSDTRRX_EL1 rw armv8_sysreg(OSDTRRX_EL1) "OS Lock Data Transfer Register, Receive" type(uint32);

/* Source: AArch64-csselr_el1.xml */
register CSSELR_EL1 rw armv8_sysreg(CSSELR_EL1) "Cache Size Selection Register" {
	_	28  mbz "Reserved, RES0.";
	Level	3   "Cache level of required cache. Permitted values are:";
	InD	1   "Instruction not Data bit. Permitted values are:";
};

/* Source: AArch64-pmcntenset_el0.xml */
register PMCNTENSET_EL0 rw armv8_sysreg(PMCNTENSET_EL0) "Performance Monitors Count Enable Set register" {
	C	1   "PMCCNTR_EL0 enable bit. Enables the cycle counter register. Possible values are:";
	P	31   "Event counter enable bit for PMEVCNTR<n>_EL0.";
};

/* Source: AArch64-afsr1_el3.xml */
register AFSR1_EL3 rw armv8_sysreg(AFSR1_EL3) "Auxiliary Fault Status Register 1 (EL3)" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-cnthp_cval_el2.xml */
register CNTHP_CVAL_EL2 rw armv8_sysreg(CNTHP_CVAL_EL2) "Counter-timer Hypervisor Physical Timer CompareValue register" {
	CompareValue	64   "Holds the EL2 physical timer CompareValue.";
};

/* Source: AArch64-mvfr2_el1.xml */
register MVFR2_EL1 ro armv8_sysreg(MVFR2_EL1) "AArch32 Media and VFP Feature Register 2" {
	_	24  mbz "Reserved, RES0.";
	FPMisc	4   "Indicates whether the floating-point implementation provides support for miscellaneous VFP features.";
	SIMDMisc	4   "Indicates whether the Advanced SIMD implementation provides support for miscellaneous Advanced SIMD features.";
};

/* Source: AArch64-oslar_el1.xml */
register OSLAR_EL1 wo armv8_sysreg(OSLAR_EL1) "OS Lock Access Register" {
	_	31  mbz "Reserved, RES0.";
	OSLK	1   "On writes to OSLAR_EL1, bit[0] is copied to the OS lock.";
};

/* Source: AArch64-ttbr1_el1.xml */
register TTBR1_EL1 rw armv8_sysreg(TTBR1_EL1) "Translation Table Base Register 1 (EL1)" {
	ASID	16   "An ASID for the translation table base address. The TCR_EL1.A1 field selects either TTBR0_EL1.ASID or TTBR1_EL1.ASID.";
	BADDR	47   "Translation table base address, A[47:x] or A[51:x], bits[47:1].";
	CnP	1   "Common not Private. In an implementation that includes , indicates whether each entry that is pointed to by TBR1_EL1 is a member of a common set that can be used by every PE in the Inner Shareable domain for which the value of TTBR1_EL1.CnP is 1.";
};

/* Source: AArch64-fpexc32_el2.xml */
register FPEXC32_EL2 rw armv8_sysreg(FPEXC32_EL2) "Floating-Point Exception Control register" {
	EX	1   "Exception bit. In ARMv8, this bit is RAZ/WI.";
	EN	1   "Enables access to the Advanced SIMD and floating-point functionality from all Exception levels, except that setting this field to 0 does not disable the following:";
	DEX	1   "Defined synchronous exception on floating-point execution.";
	FP2V	1   "FPINST2 instruction valid bit. In ARMv8, this bit is RES0.";
	VV	1   "VECITR valid bit. In ARMv8, this bit is RES0.";
	TFV	1   "Trapped Fault Valid bit. Valid only when the value of FPEXC.DEX is 1. When valid, it indicates the cause of the exception and therefore whether the FPEXC.{IDF, IXF, UFF, OFF, DZF, IOF} bits are valid.";
	_	15  mbz "Reserved, RES0.";
	VECITR	3   "Vector iteration count. In ARMv8, this field is RES1.";
	IDF	1   "Input Denormal trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Input Denormal exception occurred while FPSCR.IDE was 1:";
	_	2  mbz "Reserved, RES0.";
	IXF	1   "Inexact trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Inexact exception occurred while FPSCR.IXE was 1:";
	UFF	1   "Underflow trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Underflow exception occurred while FPSCR.UFE was 1:";
	OFF	1   "Overflow trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Overflow exception occurred while FPSCR.OFE was 1:";
	DZF	1   "Divide by Zero trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether a Divide by Zero exception occurred while FPSCR.DZE was 1:";
	IOF	1   "Invalid Operation trapped exception bit. Valid only when the value of FPEXC.TFV is 1. When valid, it indicates whether an Invalid Operation exception occurred while FPSCR.IOE was 1:";
};

/* Source: AArch64-id_aa64mmfr2_el1.xml */
register ID_AA64MMFR2_EL1 ro armv8_sysreg(ID_AA64MMFR2_EL1) "AArch64 Memory Model Feature Register 2" {
	_	44  mbz "Reserved, RES0.";
	VARange	4   "Indicates support for a larger virtual address. Defined values are:";
	IESB	4   "Indicates whether the implicit Error Synchronization Barrier operations are implemented. Defined values are:";
	LSM	4   "Indicates support for LSMAOE and nTLSMD bits in SCTLR_EL1 and SCTLR_EL2. Defined values are:";
	UAO	4   "User Access Override. Defined values are:";
	CnP	4   "Common not Private translations. Defined values are:";
};

/* Source: AArch64-cntv_cval_el0.xml */
register CNTV_CVAL_EL0 rw armv8_sysreg(CNTV_CVAL_EL02) "Counter-timer Virtual Timer CompareValue register" {
	CompareValue	64   "Holds the EL1 virtual timer CompareValue.";
};

/* Source: AArch64-tpidr_el1.xml */
register TPIDR_EL1 rw armv8_sysreg(TPIDR_EL1) "EL1 Software Thread ID Register" type(uint64);

/* Source: AArch64-ich_eisr_el2.xml */
register ICH_EISR_EL2 ro armv8_sysreg(ICH_EISR_EL2) "Interrupt Controller End of Interrupt Status Register" {
	_	16  mbz "Reserved, RES0.";
	Status	16   "EOI maintenance interrupt status bit for List register <n>:";
};

/* Source: AArch64-ccsidr_el1.xml */
register CCSIDR_EL1 ro armv8_sysreg(CCSIDR_EL1) "Current Cache Size ID Register" {
	UNKNOWN	4   "Reserved, UNKNOWN.";
	NumSets	15   "(Number of sets in cache) - 1, therefore a value of 0 indicates 1 set in the cache. The number of sets does not have to be a power of 2.";
	Associativity	10   "(Associativity of cache) - 1, therefore a value of 0 indicates an associativity of 1. The associativity does not have to be a power of 2.";
	LineSize	3   "(Log2(Number of bytes in cache line)) - 4. For example:";
};

/* Source: AArch64-cntp_ctl_el0.xml */
register CNTP_CTL_EL0 rw armv8_sysreg(CNTP_CTL_EL0) "Counter-timer Physical Timer Control register" {
	_	29  mbz "Reserved, RES0.";
	ISTATUS	1   "The status of the timer. This bit indicates whether the timer condition is met:";
	IMASK	1   "Timer interrupt mask bit. Permitted values are:";
	ENABLE	1   "Enables the timer. Permitted values are:";
};

/* Source: AArch64-id_mmfr1_el1.xml */
register ID_MMFR1_EL1 ro armv8_sysreg(ID_MMFR1_EL1) "AArch32 Memory Model Feature Register 1" {
	BPred	4   "Branch Predictor. Indicates branch predictor management requirements. Defined values are:";
	L1TstCln	4   "Level 1 cache Test and Clean. Indicates the supported Level 1 data cache test and clean operations, for Harvard or unified cache implementations. Defined values are:";
	L1Uni	4   "Level 1 Unified cache. Indicates the supported entire Level 1 cache maintenance operations for a unified cache implementation. Defined values are:";
	L1Hvd	4   "Level 1 Harvard cache. Indicates the supported entire Level 1 cache maintenance operations for a Harvard cache implementation. Defined values are:";
	L1UniSW	4   "Level 1 Unified cache by Set/Way. Indicates the supported Level 1 cache line maintenance operations by set/way, for a unified cache implementation. Defined values are:";
	L1HvdSW	4   "Level 1 Harvard cache by Set/Way. Indicates the supported Level 1 cache line maintenance operations by set/way, for a Harvard cache implementation. Defined values are:";
	L1UniVA	4   "Level 1 Unified cache by Virtual Address. Indicates the supported Level 1 cache line maintenance operations by VA, for a unified cache implementation. Defined values are:";
	L1HvdVA	4   "Level 1 Harvard cache by Virtual Address. Indicates the supported Level 1 cache line maintenance operations by VA, for a Harvard cache implementation. Defined values are:";
};

/* Source: AArch64-ich_elrsr_el2.xml */
register ICH_ELRSR_EL2 ro armv8_sysreg(ICH_ELRSR_EL2) "Interrupt Controller Empty List Register Status Register" {
	_	16  mbz "Reserved, RES0.";
	Status	16   "Status bit for List register <n>, ICH_LR<n>_EL2:";
};

/* Source: AArch64-sp_el1.xml */
register SP_EL1 rw armv8_sysreg(SP_EL1) "Stack Pointer (EL1)" type(uint64);

/* Source: AArch64-cnthctl_el2.xml */
register CNTHCTL_EL2 rw armv8_sysreg(CNTHCTL_EL2) "Counter-timer Hypervisor Control register" {
	_	24  mbz "Reserved, RES0.";
	EVNTI	4   "Selects which bit (0 to 15) of the counter register CNTPCT_EL0 is the trigger for the event stream generated from that counter, when that stream is enabled.";
	EVNTDIR	1   "Controls which transition of the counter register CNTPCT_EL0 trigger bit, defined by EVNTI, generates an event when the event stream is enabled:";
	EVNTEN	1   "Enables the generation of an event stream from the counter register CNTPCT_EL0:";
	EL1PCEN	1   "Traps Non-secure EL0 and EL1 accesses to the physical timer registers to EL2.";
	EL1PCTEN	1   "Traps Non-secure EL0 and EL1 accesses to the physical counter register to EL2.";
};

/* Source: AArch64-pmcr_el0.xml */
register PMCR_EL0 rw armv8_sysreg(PMCR_EL0) "Performance Monitors Control Register" {
	IMP	8   "Implementer code. This field is RO with an IMPLEMENTATION DEFINED value.";
	IDCODE	8   "Identification code. This field is RO with an IMPLEMENTATION DEFINED value.";
	N	5   "Number of event counters. A RO field that indicates the number counters implemented. A value of 0b00000 in this field indicates that only the Cycle Count Register PMCCNTR_EL0 is implemented.";
	_	4  mbz "Reserved, RES0.";
	LC	1   "Long cycle counter enable. Determines which PMCCNTR_EL0 bit generates an overflow recorded by PMOVSR[31].";
	DP	1   "Disable cycle counter when event counting is prohibited. The possible values of this bit are:";
	X	1   "Enable export of events in an IMPLEMENTATION DEFINED event stream. The possible values of this bit are:";
	D	1   "Clock divider. The possible values of this bit are:";
	C	1   "Cycle counter reset. This bit is WO. The effects of writing to this bit are:";
	P	1   "Event counter reset. This bit is WO. The effects of writing to this bit are:";
	E	1   "Enable. The possible values of this bit are:";
};

/* Source: AArch64-dbgwcrn_el1.xml */
regtype DBGWCR_EL1_type "Debug Watchpoint Control Registers" {
	_	3  mbz "Reserved, RES0.";
	MASK	5   "Address mask. Only objects up to 2GB can be watched using a single mask.";
	_	3  mbz "Reserved, RES0.";
	WT	1   "Watchpoint type. Possible values are:";
	LBN	4   "Linked breakpoint number. For Linked data address watchpoints, this specifies the index of the Context-matching breakpoint linked to.";
	SSC	2   "Security state control. Determines the Security states under which a Watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the HMC and PAC fields.";
	HMC	1   "Higher mode control. Determines the debug perspective for deciding when a Watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and PAC fields.";
	BAS	8   "Byte address select. Each bit of this field selects whether a byte from within the word or double-word addressed by DBGWVR<n>_EL1 is being watched.";
	LSC	2   "Load/store control. This field enables watchpoint matching on the type of access being made. Possible values of this field are:";
	PAC	2   "Privilege of access control. Determines the Exception level or levels at which a Watchpoint debug event for watchpoint n is generated. This field must be interpreted along with the SSC and HMC fields.";
	E	1   "Enable watchpoint n. Possible values are:";
};
register DBGWCR0_EL1 rw armv8_sysreg(DBGWCR0_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR1_EL1 rw armv8_sysreg(DBGWCR1_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR2_EL1 rw armv8_sysreg(DBGWCR2_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR3_EL1 rw armv8_sysreg(DBGWCR3_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR4_EL1 rw armv8_sysreg(DBGWCR4_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR5_EL1 rw armv8_sysreg(DBGWCR5_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR6_EL1 rw armv8_sysreg(DBGWCR6_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR7_EL1 rw armv8_sysreg(DBGWCR7_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR8_EL1 rw armv8_sysreg(DBGWCR8_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR9_EL1 rw armv8_sysreg(DBGWCR9_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR10_EL1 rw armv8_sysreg(DBGWCR10_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR11_EL1 rw armv8_sysreg(DBGWCR11_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR12_EL1 rw armv8_sysreg(DBGWCR12_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR13_EL1 rw armv8_sysreg(DBGWCR13_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);
register DBGWCR14_EL1 rw armv8_sysreg(DBGWCR14_EL1) "Debug Watchpoint Control Registers" type(DBGWCR_EL1_type);

/* Source: AArch64-clidr_el1.xml */
register CLIDR_EL1 ro armv8_sysreg(CLIDR_EL1) "Cache Level ID Register" {
	_	31  mbz "Reserved, RES0.";
	ICB	3   "Inner cache boundary. This field indicates the boundary for caching Inner Cacheable memory regions.";
	LoUU	3   "Level of Unification Uniprocessor for the cache hierarchy.";
	LoC	3   "Level of Coherence for the cache hierarchy.";
	LoUIS	3   "Level of Unification Inner Shareable for the cache hierarchy.";
	Ctype	21   "Cache Type fields. Indicate the type of cache that is implemented and can be managed using the architected cache maintenance instructions that operate by set/way at each level, from Level 1 up to a maximum of seven levels of cache hierarchy. Possible values of each field are:";
};

/* Source: AArch64-sp_el0.xml */
register SP_EL0 rw armv8_sysreg(SP_EL0) "Stack Pointer (EL0)" type(uint64);

/* Source: AArch64-cntfrq_el0.xml */
register CNTFRQ_EL0 rw armv8_sysreg(CNTFRQ_EL0) "Counter-timer Frequency register" type(uint32);

/* Source: AArch64-cntp_cval_el0.xml */
register CNTP_CVAL_EL0 rw armv8_sysreg(CNTP_CVAL_EL0) "Counter-timer Physical Timer CompareValue register" {
	CompareValue	64   "Holds the EL1 physical timer CompareValue.";
};

/* Source: AArch64-cntvct_el0.xml */
register CNTVCT_EL0 ro armv8_sysreg(CNTVCT_EL0) "Counter-timer Virtual Count register" type(uint64);

/* Source: AArch64-midr_el1.xml */
register MIDR_EL1 ro armv8_sysreg(MIDR_EL1) "Main ID Register" {
	Implementer	8   "The Implementer code. This field must hold an implementer code that has been assigned by ARM. Assigned codes include the following:";
	Variant	4   "An IMPLEMENTATION DEFINED variant number. Typically, this field is used to distinguish between different product variants, or major revisions of a product.";
	Architecture	4   "The permitted values of this field are:";
	PartNum	12   "An IMPLEMENTATION DEFINED primary part number for the device.";
	Revision	4   "An IMPLEMENTATION DEFINED revision number for the device.";
};

/* Source: AArch64-icc_sre_el3.xml */
register ICC_SRE_EL3 rw armv8_sysreg(ICC_SRE_EL3) "Interrupt Controller System Register Enable register (EL3)" {
	_	28  mbz "Reserved, RES0.";
	Enable	1   "Enable. Enables lower Exception level access to ICC_SRE_EL1 and ICC_SRE_EL2.";
	DIB	1   "Disable IRQ bypass.";
	DFB	1   "Disable FIQ bypass.";
	SRE	1   "System Register Enable.";
};

/* Source: AArch64-id_mmfr3_el1.xml */
register ID_MMFR3_EL1 ro armv8_sysreg(ID_MMFR3_EL1) "AArch32 Memory Model Feature Register 3" {
	Supersec	4   "Supersections. On a VMSA implementation, indicates whether Supersections are supported. Defined values are:";
	CMemSz	4   "Cached Memory Size. Indicates the physical memory size supported by the caches. Defined values are:";
	CohWalk	4   "Coherent Walk. Indicates whether Translation table updates require a clean to the point of unification. Defined values are:";
	PAN	4   "Privileged Access Never. Indicates support for the PAN bit in CPSR, SPSR, and DSPSR in AArch32. Defined values are:";
	MaintBcst	4   "Maintenance Broadcast. Indicates whether Cache, TLB, and branch predictor operations are broadcast. Defined values are:";
	BPMaint	4   "Branch Predictor Maintenance. Indicates the supported branch predictor maintenance operations in an implementation with hierarchical cache maintenance operations. Defined values are:";
	CMaintSW	4   "Cache Maintenance by Set/Way. Indicates the supported cache maintenance operations by set/way, in an implementation with hierarchical caches. Defined values are:";
	CMaintVA	4   "Cache Maintenance by  Virtual Address. Indicates the supported cache maintenance operations by VA, in an implementation with hierarchical caches. Defined values are:";
};

/* Source: AArch64-esr_el2.xml */
register ESR_EL2 rw armv8_sysreg(ESR_EL2) "Exception Syndrome Register (EL2)" {
	EC	6   "Exception Class. Indicates the reason for the exception that this register holds information about. Possible values of this field are:";
	IL	1   "Instruction Length for synchronous exceptions. Possible values of this bit are:";
	ISS	25   "Instruction Specific Syndrome. Architecturally, this field can be defined independently for each defined Exception class. However, in practice, some ISS encodings are used for more than one Exception class.";
};

/* Source: AArch64-afsr1_el1.xml */
register AFSR1_EL1 rw armv8_sysreg(AFSR1_EL1) "Auxiliary Fault Status Register 1 (EL1)" {
	IMPLEMENTATION_DEFINED	32   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-pmcntenclr_el0.xml */
register PMCNTENCLR_EL0 rw armv8_sysreg(PMCNTENCLR_EL0) "Performance Monitors Count Enable Clear register" {
	C	1   "PMCCNTR_EL0 disable bit. Disables the cycle counter register. Possible values are:";
	P	31   "Event counter disable bit for PMEVCNTR<n>_EL0.";
};

/* Source: AArch64-dbgbcrn_el1.xml */
regtype DBGBCR_EL1_type "Debug Breakpoint Control Registers" {
	_	8  mbz "Reserved, RES0.";
	BT	4   "Breakpoint Type. Possible values are:";
	LBN	4   "Linked breakpoint number. For Linked address matching breakpoints, this specifies the index of the Context-matching breakpoint linked to.";
	SSC	2   "Security state control. Determines the Security states under which a Breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the HMC and PMC fields, and there are constraints on the permitted values of the {HMC, SSC, PMC} fields. For more information, including the effect of programming the fields to a reserved set of values, see .";
	HMC	1   "Higher mode control. Determines the debug perspective for deciding when a Breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and PMC fields, and there are constraints on the permitted values of the {HMC, SSC, PMC} fields. For more information see the SSC, bits [15:14] description.";
	_	4  mbz "Reserved, RES0.";
	BAS	4   "Byte address select. Defines which half-words an address-matching breakpoint matches, regardless of the instruction set and Execution state. In an AArch64-only implementation, this field is reserved, RES1.";
	_	2  mbz "Reserved, RES0.";
	PMC	2   "Privilege mode control. Determines the Exception level or levels at which a Breakpoint debug event for breakpoint n is generated. This field must be interpreted along with the SSC and HMC fields, and there are constraints on the permitted values of the {HMC, SSC, PMC} fields. For more information see the DBGBCR<n>_EL1.SSC description.";
	E	1   "Enable breakpoint DBGBVR<n>_EL1. Possible values are:";
};
register DBGBCR0_EL1 rw armv8_sysreg(DBGBCR0_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR1_EL1 rw armv8_sysreg(DBGBCR1_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR2_EL1 rw armv8_sysreg(DBGBCR2_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR3_EL1 rw armv8_sysreg(DBGBCR3_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR4_EL1 rw armv8_sysreg(DBGBCR4_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR5_EL1 rw armv8_sysreg(DBGBCR5_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR6_EL1 rw armv8_sysreg(DBGBCR6_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR7_EL1 rw armv8_sysreg(DBGBCR7_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR8_EL1 rw armv8_sysreg(DBGBCR8_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR9_EL1 rw armv8_sysreg(DBGBCR9_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR10_EL1 rw armv8_sysreg(DBGBCR10_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR11_EL1 rw armv8_sysreg(DBGBCR11_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR12_EL1 rw armv8_sysreg(DBGBCR12_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR13_EL1 rw armv8_sysreg(DBGBCR13_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);
register DBGBCR14_EL1 rw armv8_sysreg(DBGBCR14_EL1) "Debug Breakpoint Control Registers" type(DBGBCR_EL1_type);

/* Source: AArch64-isr_el1.xml */
register ISR_EL1 ro armv8_sysreg(ISR_EL1) "Interrupt Status Register" {
	_	23  mbz "Reserved, RES0.";
	A	1   "SError interrupt pending bit:";
	I	1   "IRQ pending bit. Indicates whether an IRQ interrupt is pending:";
	F	1   "FIQ pending bit. Indicates whether an FIQ interrupt is pending.";
	_	6  mbz "Reserved, RES0.";
};

/* Source: AArch64-id_aa64afr0_el1.xml */
register ID_AA64AFR0_EL1 ro armv8_sysreg(ID_AA64AFR0_EL1) "AArch64 Auxiliary Feature Register 0" {
	_	32  mbz "Reserved, RES0.";
	IMPLEMENTATION_DEFINED_8	4   "IMPLEMENTATION DEFINED.";
	IMPLEMENTATION_DEFINED_7	4   "IMPLEMENTATION DEFINED.";
	IMPLEMENTATION_DEFINED_6	4   "IMPLEMENTATION DEFINED.";
	IMPLEMENTATION_DEFINED_5	4   "IMPLEMENTATION DEFINED.";
	IMPLEMENTATION_DEFINED_4	4   "IMPLEMENTATION DEFINED.";
	IMPLEMENTATION_DEFINED_3	4   "IMPLEMENTATION DEFINED.";
	IMPLEMENTATION_DEFINED_2	4   "IMPLEMENTATION DEFINED.";
	IMPLEMENTATION_DEFINED_1	4   "IMPLEMENTATION DEFINED.";
};

/* Source: AArch64-dbgbvrn_el1.xml */
regtype DBGBVR_EL1_type "Debug Breakpoint Value Registers" {
	RESS_lo	11   "Reserved, Sign extended. Software must treat this field as RES0 if the most significant bit of VA is 0 or RES0, and as RES1 if the most significant bit of VA is 1.";
	VA_hi	4   "Extension to VA[48:2]. See VA[48:2] for more details.";
	VA_lo	47   "Bits[48:2] of the address value for comparison.";
	_	2  mbz "Reserved, RES0.";
};
register DBGBVR0_EL1 rw armv8_sysreg(DBGBVR0_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR1_EL1 rw armv8_sysreg(DBGBVR1_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR2_EL1 rw armv8_sysreg(DBGBVR2_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR3_EL1 rw armv8_sysreg(DBGBVR3_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR4_EL1 rw armv8_sysreg(DBGBVR4_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR5_EL1 rw armv8_sysreg(DBGBVR5_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR6_EL1 rw armv8_sysreg(DBGBVR6_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR7_EL1 rw armv8_sysreg(DBGBVR7_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR8_EL1 rw armv8_sysreg(DBGBVR8_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR9_EL1 rw armv8_sysreg(DBGBVR9_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR10_EL1 rw armv8_sysreg(DBGBVR10_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR11_EL1 rw armv8_sysreg(DBGBVR11_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR12_EL1 rw armv8_sysreg(DBGBVR12_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR13_EL1 rw armv8_sysreg(DBGBVR13_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);
register DBGBVR14_EL1 rw armv8_sysreg(DBGBVR14_EL1) "Debug Breakpoint Value Registers" type(DBGBVR_EL1_type);

/* Source: AArch64-pmccfiltr_el0.xml */
register PMCCFILTR_EL0 rw armv8_sysreg(PMCCFILTR_EL0) "Performance Monitors Cycle Count Filter Register" {
	P	1   "Privileged filtering bit. Controls counting in EL1. If EL3 is implemented, then counting in Non-secure EL1 is further controlled by the NSK bit. The possible values of this bit are:";
	U	1   "User filtering bit. Controls counting in EL0. If EL3 is implemented, then counting in Non-secure EL0 is further controlled by the NSU bit. The possible values of this bit are:";
	NSK	1   "Non-secure EL1 (kernel) modes filtering bit. Controls counting in Non-secure EL1. If EL3 is not implemented, this bit is RES0.";
	NSU	1   "Non-secure EL0 (Unprivileged) filtering. Controls counting in Non-secure EL0. If EL3 is not implemented, this bit is RES0.";
	NSH	1   "Non-secure EL2 (Hypervisor) filtering bit. Controls counting in Non-secure EL2. If EL2 is not implemented, this bit is RES0.";
	M	1   "Secure EL3 filtering bit. If EL3 is not implemented, this bit is RES0.";
	_	26  mbz "Reserved, RES0.";
};

/* Source: AArch64-cntv_tval_el0.xml */
register CNTV_TVAL_EL0 rw armv8_sysreg(CNTV_TVAL_EL02) "Counter-timer Virtual Timer TimerValue register" {
	TimerValue	32   "The TimerValue view of the EL1 virtual timer.";
};

/* Source: AArch64-icc_bpr1_el1.xml */
register ICC_BPR1_EL1 rw armv8_sysreg(ICC_BPR1_EL1) "Interrupt Controller Binary Point Register 1" {
	_	29  mbz "Reserved, RES0.";
	BinaryPoint	3   "If the GIC is configured to use separate binary point fields for Group 0 and Group 1 interrupts, the value of this field controls how the 8-bit interrupt priority field is split into a group priority field, that determines interrupt preemption, and a subpriority field. For more information about priorities, see .";
};

/* Source: AArch64-elr_el2.xml */
register ELR_EL2 rw armv8_sysreg(ELR_EL2) "Exception Link Register (EL2)" type(uint64);

/* Source: AArch64-icc_sre_el1.xml */
register ICC_SRE_EL1 rw armv8_sysreg(ICC_SRE_EL1) "Interrupt Controller System Register Enable register (EL1)" {
	_	29  mbz "Reserved, RES0.";
	DIB	1   "Disable IRQ bypass.";
	DFB	1   "Disable FIQ bypass.";
	SRE	1   "System Register Enable.";
};

/* Source: AArch64-lorsa_el1.xml */
register LORSA_EL1 rw armv8_sysreg(LORSA_EL1) "LORegion Start Address (EL1)" {
	_	12  mbz "Reserved, RES0.";
	SA_hi	4   "Extension to SA[47:16]. See SA[47:16] for more details.";
	SA_lo	32   "Bits [47:16] of the start physical address of the LORegion described in the current LORegion descriptor selected by LORC_EL1.DS. Bits[15:0] of this address are defined to be 0x0000.";
	_	15  mbz "Reserved, RES0.";
	Valid	1   "Indicates whether the current LORegion Descriptor is enabled.";
};

/* Source: AArch64-cntp_tval_el0.xml */
register CNTP_TVAL_EL0 rw armv8_sysreg(CNTP_TVAL_EL0) "Counter-timer Physical Timer TimerValue register" {
	TimerValue	32   "The TimerValue view of the EL1 physical timer.";
};

/* Source: AArch64-mdscr_el1.xml */
register MDSCR_EL1 rw armv8_sysreg(MDSCR_EL1) "Monitor Debug System Control Register" {
	_	1  mbz "Reserved, RES0.";
	RXfull	1   "Used for save/restore of EDSCR.RXfull.";
	TXfull	1   "Used for save/restore of EDSCR.TXfull.";
	_	1  mbz "Reserved, RES0.";
	RXO	1   "Used for save/restore of EDSCR.RXO.";
	TXU	1   "Used for save/restore of EDSCR.TXU.";
	_	2  mbz "Reserved, RES0.";
	INTdis	2   "Used for save/restore of EDSCR.INTdis.";
	TDA	1   "Used for save/restore of EDSCR.TDA.";
	_	1  mbz "Reserved, RES0.";
	_	1  mbz "Reserved, RES0.";
	_	3  mbz "RAZ/WI. Hardware must implement this field as RAZ/WI. Software must not rely on the register reading as zero, and must use a read-modify-write sequence to write to the register.";
	MDE	1   "Monitor debug events. Enable Breakpoint, Watchpoint, and Vector Catch exceptions.";
	HDE	1   "Used for save/restore of EDSCR.HDE.";
	KDE	1   "Local (kernel) debug enable. If ELD is using AArch64, enable debug exceptions within ELD. Permitted values are:";
	TDCC	1   "Traps EL0 accesses to the DCC registers to EL1, from both Execution states:";
	_	5  mbz "Reserved, RES0.";
	ERR	1   "Used for save/restore of EDSCR.ERR.";
	_	5  mbz "Reserved, RES0.";
	SS	1   "Software step control bit. If ELD is using AArch64, enable Software step. Permitted values are:";
};

/* Source: AArch64-cnthv_ctl_el2.xml */
register CNTHV_CTL_EL2 rw armv8_sysreg(CNTHV_CTL_EL2) "Counter-timer Virtual Timer Control register (EL2)" {
	_	29  mbz "Reserved, RES0.";
	ISTATUS	1   "The status of the timer. This bit indicates whether the timer condition is met:";
	IMASK	1   "Timer interrupt mask bit. Permitted values are:";
	ENABLE	1   "Enables the timer. Permitted values are:";
};

/* Source: AArch64-icc_asgi1r_el1.xml */
register ICC_ASGI1R_EL1 wo armv8_sysreg(ICC_ASGI1R_EL1) "Interrupt Controller Alias Software Generated Interrupt Group 1 Register" {
	_	8  mbz "Reserved, RES0.";
	Aff3	8   "The affinity 3 value of the affinity path of the cluster for which SGI interrupts will be generated.";
	_	7  mbz "Reserved, RES0.";
	IRM	1   "Interrupt Routing Mode. Determines how the generated interrupts are distributed to PEs. Possible values are:";
	Aff2	8   "The affinity 2 value of the affinity path of the cluster for which SGI interrupts will be generated.";
	_	4  mbz "Reserved, RES0.";
	INTID	4   "The INTID of the SGI.";
	Aff1	8   "The affinity 1 value of the affinity path of the cluster for which SGI interrupts will be generated.";
	TargetList	16   "Target List. The set of PEs for which SGI interrupts will be generated. Each bit corresponds to the PE within a cluster with an Affinity 0 value equal to the bit number.";
};

/* Source: AArch64-pmovsset_el0.xml */
register PMOVSSET_EL0 rw armv8_sysreg(PMOVSSET_EL0) "Performance Monitors Overflow Flag Status Set register" {
	C	1   "PMCCNTR_EL0 overflow bit. Possible values are:";
	P	31   "Event counter overflow set bit for PMEVCNTR<n>_EL0.";
};

/* Source: AArch64-pmovsclr_el0.xml */
register PMOVSCLR_EL0 rw armv8_sysreg(PMOVSCLR_EL0) "Performance Monitors Overflow Flag Status Clear Register" {
	C	1   "PMCCNTR_EL0 overflow bit. Possible values are:";
	P	31   "Event counter overflow clear bit for PMEVCNTR<n>_EL0.";
};

/* Source: AArch64-lorea_el1.xml */
register LOREA_EL1 rw armv8_sysreg(LOREA_EL1) "LORegion End Address (EL1)" {
	_	12  mbz "Reserved, RES0.";
	EA_hi	4   "Extension to EA[47:16]. See EA[47:16] for more details.";
	EA_lo	32   "Bits [47:16] of the end physical address of an LORegion described in the current LORegion descriptor selected by LORC_EL1.DS. Bits[15:0] of this address are defined to be 0xFFFF.";
	_	16  mbz "Reserved, RES0.";
};

/* Source: AArch64-cpacr_el1.xml */
register CPACR_EL1 rw armv8_sysreg(CPACR_EL1) "Architectural Feature Access Control Register" {
	_	3  mbz "Reserved, RES0.";
	TTA	1   "Traps EL0 and EL1 System register accesses to all implemented trace registers to EL1, or to EL2 when SCR_EL3.NS is 1 and HCR_EL2.TGE is 1,  from both Execution states.";
	_	6  mbz "Reserved, RES0.";
	FPEN	2 type(fpen)  "Traps EL0 and EL1 accesses to the SVE, Advanced SIMD, and floating-point registers to EL1, or to EL2 when SCR_EL3.NS is 1 and HCR_EL2.TGE is 1, from both Execution states, unless SVE is implemented and they are trapped by CPACR_EL1.ZEN.";
	_	2  mbz "Reserved, RES0.";
	ZEN	2   "Traps SVE instructions and instructions that access SVE System registers at EL0 and EL1 to EL1, or to EL2 when SCR_EL3.NS and HCR_EL2.TGE are both 1. Defined values are:";
	_	16  mbz "Reserved, RES0.";
};

/* Source: AArch64-vbar_el2.xml */
register VBAR_EL2 rw armv8_sysreg(VBAR_EL2) "Vector Base Address Register (EL2)" {
	None	53   "Vector Base Address. Base address of the exception vectors for exceptions taken to EL2.";
	_	11  mbz "Reserved, RES0.";
};

};