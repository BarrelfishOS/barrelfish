/*
 * Copyright (c) 2016, 2017 ETH Zurich. All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich. Attn: Systems Group.
 */

/*
 * armv8.dev
 *
 * DESCRIPTION: ARMv8 architecture definitions
 * 
 * See:
 *   ARM Architecture Reference Manual
 */

device armv8 msbfirst () "ARMv8 architecture registers" {

    space sysreg(name) registerwise "System registers";
    space cache_ctrl(name) registerwise "Cache control register";

    register CurrentEL ro sysreg(current_el) "Current Exception Level" {
        _       28 mbz;
        EL       2 "Current Exception level";
        _        2 mbz;
    };

    register DAIF rw sysreg(daif) "Interrupt Mask Bits" {
        _       22 mbz;
        D        1 "Process state D mask";
        A        1 "SError interrupt mask bit";
        I        1 "IRQ mask bit";
        F        1 "FIQ mask bit";
        _        6 mbz;
    };

    register DLR_EL0 rw sysreg(dlr_el0) "Debug Link Register" {
        addr    64 "Restart address";
    };

    register DSPSR_EL0 rw sysreg(dspsr_el0) "Debug Saved Program Status Register" {
        N        1 "N condition flag";
        Z        1 "Z condition flag";
        C        1 "C condition flag";
        V        1 "V condition flag";
        _        6 mbz;
        SS       1 "Software step";
        IL       1 "Illegal Execution state bit";
        _       10 mbz;
        D        1 "Process state D mask";
        A        1 "SError interrupt mask bit";
        I        1 "IRQ mask bit";
        F        1 "FIQ mask bit";
        _        1;
        M4       1 "Execution state that debug state was entered from (AArch64=0)";
        M        4 "AArch64 mode";
    };

    register ELR_EL1 rw sysreg(elr_el1) "Exception Link Register (EL1)" {
        addr    64 "Return address";
    };

    register ELR_EL2 rw sysreg(elr_el2) "Exception Link Register (EL2)" {
        addr    64 "Return address";
    };

    register ELR_EL3 rw sysreg(elr_el3) "Exception Link Register (EL3)" {
        addr    64 "Return address";
    };

    register FCPR rw sysreg(fpcr) "Floating-point Control Register" {
        _        5 mbz;
        AHP      1 "Alternate half-precision control bit";
        DN       1 "Default NaN mode control bit";
        FZ       1 "Flush-to-zero mode control bit";
        RMode    2 "Rounding mode control field";
        Stride   2 "Ignored on AArch64";
        _        1 mbz;
        Len      3 "Ignored on AArch64";
        IDE      1 "Input Denormal exception trap enable";
        _        2  mbz;
        IXE      1 "Inexact exception trap enable";
        UFE      1 "Underflow exception trap enable";
        OFE      1 "Overflow exception trap enable";
        DZE      1 "Division by Zero exception trap enable";
        IOE      1 "Invalid Operation exception trap enable";
        _        8 mbz;
    };

    register FPSR rw sysreg(fpsr) "Floating-point Status Register" {
        N        1 "Negative condition flag for AArch32 floating-poin";
        Z        1 "Zero condition flag for AArch32";
        C        1 "Carry condition flag for AArch32 floating-point comparison operation";
        V        1 "Overflow condition flag for AArch32 floating-poin";
        QC       1 "Cumulative saturation bit, Advanced SIMD only";
        _       19 mbz;
        IDC      1 "Input Denormal cumulative exception bit.";
        _        2 mbz;
        IXC      1 "Inexact cumulative exception bit";
        UFC      1 "Underflow cumulative exception bit.";
        OFC      1 "Overflow cumulative exception bit";
        DZC      1 "Division by Zero cumulative exception bit.";
        IOC      1 "Invalid Operation cumulative exception bit.";
    };

    register NZCV rw sysreg(nzcv) "Condition Flags" {
        N        1 "Negative condition flag";
        Z        1 "Zero condition flag";
        C        1 "Carry condition flag";
        V        1 "Overflow condition flag";
        _       28 mbz;
    };

    register SP_EL0 rw sysreg(sp_el0) "Stack Pointer (EL0)" {
        addr    64 "Stack pointer";
    };

    register SP_EL1 rw sysreg(sp_el1) "Stack Pointer (EL1)" {
        addr    64 "Stack pointer";
    };

    register SP_EL2 rw sysreg(sp_el2) "Stack Pointer (EL2)" {
        addr    64 "Stack pointer";
    };

    register SP_EL3 rw sysreg(sp_el3) "Stack Pointer (EL3)" {
        addr    64 "Stack pointer";
    };

    register SPSel rw sysreg(spsel) "Stack Pointer Select" {
        _       31 mbz;
        SP       1 "Stack pointer use (1=Use SP_ELx at Exception level ELx)";
    };
    
    register SPSR_abt rw sysreg(spsr_abt) "Saved Program Status Register (Abort mode)" {
        N     1 "Set to the value of CPSR.N on taking an exception to Abort mode";
        Z     1 "Set to the value of CPSR.Z on taking an exception to Abort mode";
        C     1 "Set to the value of CPSR.C on taking an exception to Abort mode,";
        V     1 "Set to the value of CPSR.V on taking an exception to Abort mode,";
        Q     1 "Cumulative saturation bit. Set to 1 to indicate that overflow";
        IT_lo 2 "IT block state bits for the T32 IT (If-Then) instruction.";
        _     4 mbz;
        IL    1 "Illegal Execution state bi";
        GE    4 "Greater than or Equal flags";
        IT_hi 6 "IT block state bits for the T32 IT (If-Then) instruction. Th";
        E     1 "Endianness state bit. C";
        A     1 "SError interrupt mask bit.";
        I     1 "IRQ mask bit";
        F     1 "FIQ mask bit.";
        T     1 "T32 Instruction set state bit. D";
        M32   1 "Exception taken from AArch32.";
        M     4 "AArch32 mode that an exception was taken from";
    };
    
    register SPSR_EL1 rw sysreg(spsr_el1) "Saved Program Status Register (EL1)" {
        N     1 "Set to the value of the N condition flag on taking an exception to EL1";
        Z     1 "Set to the value of the Z condition flag on taking an exception to EL1,";
        C     1 "Set to the value of the C condition flag on taking an exception to EL1,,";
        V     1 "Set to the value of the V condition flag on taking an exception to EL1";
        _     6 mbz;
        SS    1 "Software step. Shows the value of PSTATE.SS immediately before the exception was taken.";
        IL    1 "Illegal Execution state bi";
        _    10 mbz;
        D     1 "Process state D mask.";
        A     1 "SError interrupt mask bit.";
        I     1 "IRQ mask bit";
        F     1 "FIQ mask bit.";
        _     2 mbz;
        M     4 "AArch32 mode that an exception was taken from";
    };
    
    register SPSR_EL2 rw sysreg(spsr_el2) "Saved Program Status Register (EL2)" {
        N     1 "Set to the value of the N condition flag on taking an exception to EL2";
        Z     1 "Set to the value of the Z condition flag on taking an exception to EL2,";
        C     1 "Set to the value of the C condition flag on taking an exception to EL2,,";
        V     1 "Set to the value of the V condition flag on taking an exception to EL2";
        _     6 mbz;
        SS    1 "Software step. Shows the value of PSTATE.SS immediately before the exception was taken.";
        IL    1 "Illegal Execution state bi";
        _    10 mbz;
        D     1 "Process state D mask.";
        A     1 "SError interrupt mask bit.";
        I     1 "IRQ mask bit";
        F     1 "FIQ mask bit.";
        _     2 mbz;
        M     4 "AArch32 mode that an exception was taken from";
    };
    
    register SPSR_EL3 rw sysreg(spsr_el3) "Saved Program Status Register (EL3)" {
        N     1 "Set to the value of the N condition flag on taking an exception to EL2";
        Z     1 "Set to the value of the Z condition flag on taking an exception to EL2,";
        C     1 "Set to the value of the C condition flag on taking an exception to EL2,,";
        V     1 "Set to the value of the V condition flag on taking an exception to EL2";
        _     6 mbz;
        SS    1 "Software step. Shows the value of PSTATE.SS immediately before the exception was taken.";
        IL    1 "Illegal Execution state bi";
        _    10 mbz;
        D     1 "Process state D mask.";
        A     1 "SError interrupt mask bit.";
        I     1 "IRQ mask bit";
        F     1 "FIQ mask bit.";
        _     2 mbz;
        M     4 "AArch32 mode that an exception was taken from";
    };
    
    
    register SPSR_fiq rw sysreg(spsr_fiq) "Saved Program Status Register (fiq mode)" {
        N     1 "Set to the value of CPSR.N on taking an exception to FIQ mode";
        Z     1 "Set to the value of CPSR.Z on taking an exception to FIQ mode";
        C     1 "Set to the value of CPSR.C on taking an exception to FIQ mode,";
        V     1 "Set to the value of CPSR.V on taking an exception to FIQ mode,";
        Q     1 "Cumulative saturation bit. Set to 1 to indicate that overflow";
        IT_lo 2 "IT block state bits for the T32 IT (If-Then) instruction.";
        _     4 mbz;
        IL    1 "Illegal Execution state bi";
        GE    4 "Greater than or Equal flags";
        IT_hi 6 "IT block state bits for the T32 IT (If-Then) instruction. Th";
        E     1 "Endianness state bit. C";
        A     1 "SError interrupt mask bit.";
        I     1 "IRQ mask bit";
        F     1 "FIQ mask bit.";
        T     1 "T32 Instruction set state bit. D";
        M32   1 "Exception taken from AArch32.";
        M     4 "AArch32 mode that an exception was taken from";
    };
    
    register SPSR_irq rw sysreg(spsr_irq) "Saved Program Status Register (IRQ mode)" {
        N     1 "Set to the value of CPSR.N on taking an exception to IRQ mode";
        Z     1 "Set to the value of CPSR.Z on taking an exception to IRQ mode";
        C     1 "Set to the value of CPSR.C on taking an exception to IRQ mode,";
        V     1 "Set to the value of CPSR.V on taking an exception to IRQ mode,";
        Q     1 "Cumulative saturation bit. Set to 1 to indicate that overflow";
        IT_lo 2 "IT block state bits for the T32 IT (If-Then) instruction.";
        _     4 mbz;
        IL    1 "Illegal Execution state bi";
        GE    4 "Greater than or Equal flags";
        IT_hi 6 "IT block state bits for the T32 IT (If-Then) instruction. Th";
        E     1 "Endianness state bit. C";
        A     1 "SError interrupt mask bit.";
        I     1 "IRQ mask bit";
        F     1 "FIQ mask bit.";
        T     1 "T32 Instruction set state bit. D";
        M32   1 "Exception taken from AArch32.";
        M     4 "AArch32 mode that an exception was taken from";
    };
    
    register SPSR_und rw sysreg(spsr_und) "Saved Program Status Register (Undefined mode)" {
        N     1 "Set to the value of CPSR.N on taking an exception to Undefined mode";
        Z     1 "Set to the value of CPSR.Z on taking an exception to Undefined mode";
        C     1 "Set to the value of CPSR.C on taking an exception to Undefined mode,";
        V     1 "Set to the value of CPSR.V on taking an exception to Undefined mode,";
        Q     1 "Cumulative saturation bit. Set to 1 to indicate that overflow";
        IT_lo 2 "IT block state bits for the T32 IT (If-Then) instruction.";
        _     4 mbz;
        IL    1 "Illegal Execution state bi";
        GE    4 "Greater than or Equal flags";
        IT_hi 6 "IT block state bits for the T32 IT (If-Then) instruction. Th";
        E     1 "Endianness state bit. C";
        A     1 "SError interrupt mask bit.";
        I     1 "IRQ mask bit";
        F     1 "FIQ mask bit.";
        T     1 "T32 Instruction set state bit. D";
        M32   1 "Exception taken from AArch32.";
        M     4 "AArch32 mode that an exception was taken from";
    };

    constants shareability width(2) "Shareability" {
        non_shareable   = 0b00 "Non-shareable";
        outer_shareable = 0b10 "Outer Shareable";
        inner_shareable = 0b11 "Inner Shareable";
    };

    constants cacheability width(2) "Cacheability" {
        non_cacheable   = 0b00 "Normal memory, Outer Non-cacheable";
        WbRaWa_cache    = 0b01 "Normal memory, Outer Write-Back Read-Allocate Write-Allocate Cacheable";
        WtRanWa_cache   = 0b10 "Normal memory, Outer Write-Through Read-Allocate No Write-Allocate Cacheable";
        WbRanWa_cache   = 0b11 "Normal memory, Outer Write-Back Read-Allocate No Write-Allocate Cacheable";
    };

    constants ASID_size width(1) "ASID size" {
        bit_8   = 0b0 "8 bit ASID size";
        bit_16  = 0b1 "16 bit ASID size";
    };

    constants granule width(2) "Granule size" {
        KB_4    = 0b00;
        KB_64   = 0b01;
        KB_16   = 0b10;
    };

    register TCR_EL1 rw sysreg(TCR_EL1) "Translation Control Register (EL1)" {
        _       25;
        TBI1     1 "Top Byte ignored bit (TTBR1)";
        TBI0     1 "Top Byte ignored bit (TTBR0)";
        AS       1 type(ASID_size) "ASID size (0=8 bit, 1=16 bit)";
        _        1;
        IPS      3 "Intermediate Physical Address Size";
        TG1      2 type(granule) "Granule size for the TTBR1_EL1";
        SH1      2 type(shareability) "TTBR1 shareability";
        ORGN1    2 type(cacheability) "Outer TTBR1 cacheability";
        IRGN1    2 type(cacheability) "Inner TTBR1 cacheability";
        EPD1     1 "TTBR1 disable";
        A1       1 "ASID selection (0=TTBR0, 1=TTBR1)";
        T1SZ     6 "TTBR1_EL1 region size is 2^(64-T1SZ)";
        TG0      2 type(granule) "Granule size fo the TTBR0_EL1";
        SH0      2 type(shareability) "TTBR0 shareability";
        ORGN0    2 type(cacheability) "Outer TTBR0 cacheability";
        IRGN0    2 type(cacheability) "Inner TTBR0 cacheability";
        EPD0     1 "TTBR0 disable";
        _        1;
        T0SZ     6 "TTBR0_EL1 region size is 2^(64-T0SZ)";
    };
    
    register TCR_EL2 rw sysreg(TCR_EL2) "Translation Control Register (EL2)" {
        _       11 "";
        TBI      1 "Top Byte Ignored";
        _        1 "";
        PS       3 "Physical address size.";
        TG0      2 "TTBR0_EL2 granule size";
        SH0      2 "Shareability attribute for memory";
        ORGN0    2 "Outer cacheability attribute for memory associated";
        IRGN0    2 "Inner cacheability attribute for memory ";
        _        2;
        T0SZ     6 "TTBR0_EL1 region size is 2^(64-T0SZ)";
    };


    register TTBCR rw sysreg(TTBCR) "Translation Table Base Control Register (32 bit)" {
        EAE      1 "Extended Address Enable (1=Long-descriptor translation table)";
        imp_def  1;
        SH1      2 type(shareability) "TTBR1 shareability";
        ORGN1    2 type(cacheability) "Outer TTBR1 cacheability";
        IRGN1    2 type(cacheability) "Inner TTBR1 cacheability";
        EPD1     1 "TTBR1 disable";
        A1       1 "ASID selection (0=TTBR0, 1=TTBR1)";
        _        3;
        T1SZ     3 "Translation Table 1 format";
        _        2;
        SH0      2 type(shareability) "TTBR0 shareability";
        ORGN0    2 type(cacheability) "Outer TTBR0 cacheability";
        IRGN0    2 type(cacheability) "Inner TTBR0 cacheability";
        EPD0     1 "TTBR0 disable";
        _        4;
        T0SZ     3 "Translation Table 0 format";
    };
    
    register TTBR0_EL1 rw sysreg(ttbr0_el1) "Translation Table Base Register 0 (EL1)" {
        asid  16 "An ASID for the translation table base address.";
        baddr 48 "Translation table base address";
    };
    
    register TTBR0_EL2 rw sysreg(ttbr0_el2) "Translation Table Base Register 0 (EL2)" {
        _     16 mbz;
        baddr 48 "Translation table base address";
    };
    
    register TTBR0_EL3 rw sysreg(ttbr0_el3) "Translation Table Base Register 0 (EL3)" {
        _     16 mbz;
        baddr 48 "Translation table base address";
    };
    
    register TTBR1_EL1 rw sysreg(ttbr1_el1) "Translation Table Base Register 1 (EL1)" {
        asid  16 "An ASID for the translation table base address.";
        baddr 48 "Translation table base address";
    };

    constants endianness width(1) "Endianness configuration" {
        little  = 0b0 "Little endian";
        big     = 0b1 "Big endian";
    };

    register SCTLR_EL1 rw sysreg(SCTLR_EL1) "System Control Register (EL1)" {
        _        2 mbz;
        _        2 mb1;
        _        1 mbz;
        UCI      1 "Trap cache maintenance instruction to EL1";
        EE       1 type(endianness) "EL1 endianness";
        E0E      1 type(endianness) "EL0 endianness";
        _        2 mb1;
        _        1 mbz;
        _        1 mb1;
        WXN      1 "Write permission implies XN (Execute-never)";
        nTWE     1 "Disable trap EL0 WFE instructions to EL1";
        _        1 mbz;
        nTWI     1 "Disable trap EL0 WFI instructions to EL1";
        UCT      1 "Disable trap EL0 CTR_EL0 access to EL1";
        DZE      1 "Disable trap EL0 DC ZVA access to EL1";
        _        1 mbz;
        I        1 "Instruction access Cacheability control (0=non-cacheable)";
        _        1 mb1;
        _        1 mbz;
        UMA      1 "User Mask Access. Disable trapping EL0 MSR/MRS to EL1";
        SED      1 "SETEND instruction disable";
        ITD      1 "IT Disable";
        _        1 mbz;
        CP15BEN  1 "System instruciton memory barrier enable";
        SA0      1 "Enable SP Alignment check for EL0";
        SA       1 "Enable SP Alignment check for EL1";
        C        1 "Data cacheability control";
        A        1 "Alignment check enable";
        M        1 "MMU enable";
    };
    
    register SCTLR_EL2 rw sysreg(SCTLR_EL2) "System Control Register (EL2)" {
        _        2 mbz;
        _        2 mb1;
        _        2 mbz;
        EE       1 "Exception Endianess";
        _        1 mbz;
        _        2 mb1;
        _        2 mbz;
        WZN      1 "Force treatment of all memory regions with write permissions as XN";
        _        1 mb1;
        _        1 mbz;
        _        1 mb1;
        _        3 mbz;
        I        1 "Instruction cache enable";
        _        1 mb1;
        _        5 mbz;
        _        2 mb1;
        SA       1 "Enable SP Alignment check";
        C        1 "Data cacheability control";
        A        1 "Alignment check enable";
        M        1 "MMU enable";
    };
    
    register SCTLR_EL3 rw sysreg(SCTLR_EL3) "System Control Register (EL3)" {
        _        2 mbz;
        _        2 mb1;
        _        2 mbz;
        EE       1 "Exception Endianess";
        _        1 mbz;
        _        2 mb1;
        _        2 mbz;
        WZN      1 "Force treatment of all memory regions with write permissions as XN";
        _        1 mb1;
        _        1 mbz;
        _        1 mb1;
        _        3 mbz;
        I        1 "Instruction cache enable";
        _        1 mb1;
        _        5 mbz;
        _        2 mb1;
        SA       1 "Enable SP Alignment check";
        C        1 "Data cacheability control";
        A        1 "Alignment check enable";
        M        1 "MMU enable";
    };

    constants fpen width(1) "Endianness configuration" {
        fpen_trap_any  = 0b00 "Trap any FP and SIMD instructions in EL0 or EL1";
        fpen_trap_el0  = 0b01 "Trap any FP and SIMD in EL0 to EL21";
        fpen_trap_el1  = 0b10 "Trap any FP and SIMD instructions in EL0 or EL1";
        fpen_trap_none = 0b11 "Does not cause any instruction to be trapped.";
    };

    register CPACR_EL1 rw sysreg(CPACR_EL1) "Architectural Feature Access Control Register" {
        _        3 mbz;
        TTA      1 "Traps EL0 and EL1 System register accesses to all implemented trace registers to EL1";
        _        6 mbz;
        FPEN     2 type(endianness) "Traps EL0 and EL1 accesses to the SIMD and floating-point registers to EL1";
        _       20 mbz;
    };

    register ICC_AP0R0_EL1 rw sysreg(ICC_AP0R0_EL1) "" {
        impl    32;
    };
    register ICC_AP0R1_EL1 rw sysreg(ICC_AP0R1_EL1) "" {
        impl    32;
    };
    register ICC_AP0R2_EL1 rw sysreg(ICC_AP0R2_EL1) "" {
        impl    32;
    };
    register ICC_AP0R3_EL1 rw sysreg(ICC_AP0R3_EL1) "" {
        impl    32;
    };

    register ICC_AP1R0_EL1 rw sysreg(ICC_AP1R0_EL1) "" {
        impl    32;
    };
    register ICC_AP1R1_EL1 rw sysreg(ICC_AP1R1_EL1) "" {
        impl    32;
    };
    register ICC_AP1R2_EL1 rw sysreg(ICC_AP1R2_EL1) "" {
        impl    32;
    };
    register ICC_AP1R3_EL1 rw sysreg(ICC_AP1R3_EL1) "" {
        impl    32;
    };

    register ICC_BPR0_EL1 rw sysreg(ICC_BPR0_EL1) "Interrupt Controller Binray Point Register 0" {
        _            29;
        binary_point  3;
    };

    register ICC_BPR1_EL1 rw sysreg(ICC_BPR1_EL1) "" {
        _            29;
        binary_point  3;
    };

    register ICC_CTLR_EL1 rw sysreg(ICC_CTLR_EL1) "" {
        _           16;
        a3v          1 "Affinity 3 Valid";
        seis         1 ro "SEI Support";
        IDbits       3 "Identifier bits";
        PRIbits      3 "Priority bits";
        _            1;
        pmhe         1 "Priority Mask Hint Enable";
        _            4;
        EOImode      1 "EOI mode";
        cbpr         1 "Common Binary Point Regsiter";
    };

    register ICC_DIR_EL1 rw sysreg(ICC_DIR_EL1) "Interrupt Controller Deactivate Interrupt Register" {
        _            8;
        intid       24 "INTID of the interrupt to be deactivated";
    };

    register ICC_EOIR0_EL1 rw sysreg(ICC_EOIR0_EL1) "Interrupt Controller End Of Interrupt Register 0" {
        _            8;
        intid       24 "INTID from the corresponding ICC_IAR0_EL1 access";
    };

    register ICC_EOI1_EL1 rw sysreg(ICC_EOI1_EL1) "Interrupt Controller End Of Interrupt Register 1" {
        _            8;
        intid       24 "INTID from the corresponding ICC_IAR1_EL1 access";
    };

    register ICC_HPPIR0_EL1 rw sysreg(ICC_HPPIR0_EL1) "Interrupt Controller Highest Priority Pending Interrupt Register 0" {
        _            8;
        intid       24 "INTID of the highest priority pending interrupt";
    };

    register ICC_HPPIR1_EL1 rw sysreg(ICC_HPPIR1_EL1) "Interrupt Controller Highest Priority Pending Interrupt Register 1" {
        _            8;
        intid       24 "INTID of the highest priority pending interrupt";
    };

    register ICC_IAR0_EL1 rw sysreg(ICC_IAR0_EL1) "Interrupt Controller Interrupt Acknowledge Register 0" {
        _            8;
        intid       24 "INTID of the signaled interrupt";
    };

    register ICC_IAR1_EL1 rw sysreg(ICC_IAR1_EL1) "Interrupt Controller Interrupt Acknowledge Register 1" {
        _            8;
        intid       24 "INTID of the signaled interrupt";
    };

    register ICC_IGRPEN0_EL1 rw sysreg(ICC_IGRPEN0_EL1) "Interrupt Controller Interrupt Group 0 Enable Register" {
        _           31;
        enable       1 "Enables Group 0 interrupts";
    };

    register ICC_IGRPEN1_EL1 rw sysreg(ICC_IGRPEN1_EL1) "Interrupt Controller Interrupt Group 1 Enable Register" {
        _           31;
        enable       1 "Enables Group 1 interrupts";
    };


    register ICC_PMR_EL1 rw sysreg(ICC_PMR_EL1) "Interrupt Controller Interrupt Priority Mask Register" {
        _          24;
        priority    8 "Priority mask level";
    };

    register ICC_RPR_EL1 rw sysreg(ICC_RPR_EL1) "Interrupt Controller Running Priority Register" {
        _          24;
        priority    8 "Running priority";
    };


    register ICC_SGI0R_EL1 wo sysreg(ICC_SGI0R_EL1) "Interrupt Controller Software Generated Interrupt Group 0 Register" {
        _           8;
        aff3        8 "Affinity Path 3";
        _           7;
        irm         1 "Interrupt Routing Mode";
        aff2        8 "Affinity Path 2";
        _           4;
        intid       4 "INTID of the SGI";
        aff1        8 "Affinity Path 1";
        target     16 "Target List";
    };

    register ICC_SGI1R_EL1 wo sysreg(ICC_SGI1R_EL1) "Interrupt Controller Software Generated Interrupt Group 1 Register" {
        _           8;
        aff3        8 "Affinity Path 3";
        _           7;
        irm         1 "Interrupt Routing Mode";
        aff2        8 "Affinity Path 2";
        _           4;
        intid       4 "INTID of the SGI";
        aff1        8 "Affinity Path 1";
        target     16 "Target List";
    };

    register ICC_SRE_EL1 rw sysreg(ICC_SRE_EL1) "Interrupt Controller System Register Enable" {
        _       29;
        DIB     1 "Disable IRQ bypass";
        DFB     1 "Disable FIQ bypass";
        SRE     1 "System Register Enable";
    };
    
   
    register DC_CSIW wo cache_ctrl(cisw) "Data or unified Cache line Clean and Invalidate by Set/Way" {
        _       32 mbz;
        SetWay  28 "Set and ways. depends on the cache settings";
        Level    3 "Cache level to operate on, minus 1.";
        _        1 mbz;
    };
    
    register DC_CIVAC wo cache_ctrl(civac) "Data or unified Cache line Clean and Invalidate by VA to PoC" {
        addr 64 "Virtual address to use.";
    };
    
    register DC_CSW wo cache_ctrl(csw) "Data or unified Cache line Clean by Set/Way" {
        _       32 mbz;
        SetWay  28 "Set and ways. depends on the cache settings";
        Level    3 "Cache level to operate on, minus 1.";
        _        1 mbz;
    };
    
    register DC_CVAC wo cache_ctrl(cvac) "Data or unified Cache line Clean by VA to PoC" {
        addr 64 "Virtual address to use.";
    };
    
    register DC_CVAU wo cache_ctrl(cvau) "Data or unified Cache line Clean by VA to PoU" {
        addr 64 "Virtual address to use.";
    };
    
    register DC_ISW wo cache_ctrl(isw) "Data or unified Cache line Invalidate by Set/Way" {
        _       32 mbz;
        SetWay  28 "Set and ways. depends on the cache settings";
        Level    3 "Cache level to operate on, minus 1.";
        _        1 mbz;
    };
    
    register DC_IVAC wo cache_ctrl(ivac) "Data or unified Cache line Invalidate by VA to PoC" {
        addr 64 "Virtual address to use.";
    };
    
    register DC_ZVA wo cache_ctrl(zva) "Data or unified Cache line Invalidate by VA to PoC" {
        addr 64 "Virtual address to use.";
    };
    
};
