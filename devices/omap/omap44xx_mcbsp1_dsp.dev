/*
 * Copyright (c) 2013 ETH Zurich. All rights reserved.
 *
 * This file is distributed under the terms in the attached LICENSE file.
 * If you do not find this file, copies can be found by writing to:
 * ETH Zurich D-INFK, CAB F.78, Universitaetstrasse 6, CH-8092 Zurich,
 * Attn: Systems Group.
 */

/*
 * omap44xx_mcbsp1_dsp.dev
 *
 * DESCRIPTION: 
 *
 * NOTE: This file has been automatically generated based on the
 * XML files extracted from the TI RDT v1.0.0.4p Tool.
 * Download from here: http://www.ti.com/product/omap4460
 * This means that the file might not be optimal in terms of naming
 * conventions for constants and registers (duplicated
 * namespaces in register and device name etc.).
 * Also, because of the underlying structure from the original XML
 * it's possible that some constants appear multiple times (if they
 * have slightly different descriptions for example).
 *
 * You want to clean that up before using the files for the first time!
 */
 
device omap44xx_mcbsp1_dsp msbfirst ( addr base ) "" {
    
    
    register mcbsplp_drr_reg ro addr(base, 0x0) "McBSPLP data receive register" type(uint32);
    
    register mcbsplp_dxr_reg wo addr(base, 0x8) "McBSPLP data transmit register" type(uint32);

    constants free_status width(1) "" {
        FREE_0 = 0 "Free running mode is disabled";
        FREE_1 = 1 "Free running mode is enabled";
    };

    constants soft_status width(1) "" {
        SOFT_0 = 0 "SOFT mode is disabled: the module stops its activity immediately following MSuspend assertion";
        SOFT_1 = 1 "SOFT mode is enabled: the module freezes its state after completion of the current operation when MSuspend is asserted";
    };

    constants frst_status width(1) "" {
        FRST_0 = 0 "Frame-sync logic is reset. Frame-sync signal FSG is not generated by the sample-rate generator";
        FRST_1 = 1 "Frame-sync signal FSG is generated after (FPER+1) number of CLKG clocks; that is, all frame counters are loaded with their programmed values";
    };

    constants grst_status width(1) "" {
        GRST_0 = 0 "SRG is reset";
        GRST_1 = 1 "SRG is pulled out of reset. CLKG is driven as per programmed value in SRG registers (SRGR[1,2])";
    };

    constants xintm_status width(2) "" {
        XINTM_0 = 0 "XINT is driven by XRDY";
        XINTM_1 = 1 "XINT generated by end-of-frame";
        XINTM_2 = 2 "XINT generated by a new frame synchronization";
        XINTM_3 = 3 "XINT generated by XSYNCERR";
    };

    constants xsyncerr_status width(1) "" {
        XSYNCERR_0 = 0 "No synchronization error";
        XSYNCERR_1 = 1 "Synchronization error detected by McBSP";
    };

    constants xempty_status width(1) "" {
        XEMPTY_0_r = 0 "XSR is empty";
        XEMPTY_1_r = 1 "XSR is not empty";
    };

    constants xrdy_status width(1) "" {
        XRDY_0_r = 0 "Transmitter is not ready.";
        XRDY_1_r = 1 "Transmitter is ready for new data in DXR";
    };

    constants xrst_status width(1) "" {
        XRST_0 = 0 "The serial port transmitter is disabled and in reset state.";
        XRST_1 = 1 "The serial port transmitter is enabled.";
    };
    
    register mcbsplp_spcr2_reg addr(base, 0x10) "McBSPLP serial port control register 2" {
        _ 22 mbz;
        free 1 rw type(free_status) "Free Running Mode (When this bit is set, the module ignores the Msuspend input)";
        soft 1 rw type(soft_status) "Soft Bit";
        frst 1 rw type(frst_status) "Frame-Sync Generator Reset";
        grst 1 rw type(grst_status) "Sample-Rate Generator Reset";
        xintm 2 rw type(xintm_status) "Transmit Interrupt Mode (legacy)";
        xsyncerr 1 rw type(xsyncerr_status) "Transmit Synchronization Error (writing 0 to this bit clear the legacy transmit interrupt if asserted due to XSYNCERR condition)";
        xempty 1 ro type(xempty_status) "Transmit Shift Register XSR Empty";
        xrdy 1 ro type(xrdy_status) "Transmitter ready";
        xrst 1 rw type(xrst_status) "Transmitter reset. This resets and enables the transmitter.";
    };

    constants alb_status width(1) "" {
        ALB_0 = 0 "Analog loopback mode disabled";
        ALB_1 = 1 "Analog loopback mode enabled";
    };

    constants rjust_status width(2) "" {
        RJUST_0 = 0 "Right-justify and zero-fill MSBs in DRR";
        RJUST_1 = 1 "Right-justify and sign-extend MSBs in DRR";
        RJUST_2 = 2 "Left-justify and zero-fill LSBs in DRR";
        RJUST_3 = 3 "Reserved";
    };

    constants dxena_status width(1) "" {
        DXENA_0 = 0 "DX enabler is off";
        DXENA_1 = 1 "DX enabler is on";
    };

    constants rintm_status width(2) "" {
        RINTM_0 = 0 "RINT driven by RRDY (that is, end of word) and end of frame in A-bis mode";
        RINTM_1 = 1 "RINT generated by end-of-block or end-of-frame in multichannel operation";
        RINTM_2 = 2 "RINT generated by a new frame synchronization";
        RINTM_3 = 3 "RINT generated by RSYNCERR";
    };

    constants rfull_status width(1) "" {
        RFULL_0_r = 0 "DRR is not read, RB is full and RSR is also full with new word";
        RFULL_1_r = 1 "RB is not in overrun condition";
    };

    constants rrdy_status width(1) "" {
        RRDY_0_r = 0 "Receiver is not ready";
        RRDY_1_r = 1 "Receiver is ready with data to be read from DRR";
    };

    constants rrst_status width(1) "" {
        RRST_0 = 0 "The serial port receiver is disabled and in reset state.";
        RRST_1 = 1 "The serial port receiver is enabled.";
    };
    
    register mcbsplp_spcr1_reg addr(base, 0x14) "McBSPLP serial port control register 1" {
        _ 16 mbz;
        alb 1 rw type(alb_status) "Analog Loopback Mode";
        rjust 2 rw type(rjust_status) "Receive Sign-Extension and Justification Mode";
        _ 5 mbz;
        dxena 1 rw type(dxena_status) "DX Enabler";
        _ 1 mbz;
        rintm 2 rw type(rintm_status) "Receive Interrupt Mode (legacy)";
        rsyncerr 1 rw type(xsyncerr_status) "Receive Synchronization Error (writing 0 to this bit clear the legacy receive interrupt if asserted due to RSYNCERR condition)";
        rfull 1 ro type(rfull_status) "Receive Shift Register (RSR]) Full";
        rrdy 1 ro type(rrdy_status) "Receiver Ready";
        rrst 1 rw type(rrst_status) "Receiver reset. This resets and enables the receiver.";
    };

    constants rphase_status width(1) "" {
        RPHASE_0 = 0 "Single-phase frame";
        RPHASE_1 = 1 "Dual-phase frame";
    };

    constants rwdlen2_status width(3) "" {
        RWDLEN2_0 = 0 "8 bits";
        RWDLEN2_1 = 1 "12 bits";
        RWDLEN2_2 = 2 "16 bits";
        RWDLEN2_3 = 3 "20 bits";
        RWDLEN2_4 = 4 "24 bits";
        RWDLEN2_5 = 5 "32 bits";
        RWDLEN2_6 = 6 "Reserved (do not use)";
        RWDLEN2_7 = 7 "Reserved (do not use)";
    };

    constants rreverse_status width(2) "" {
        RREVERSE_0 = 0 "Data transfer starts with MSB first.";
        RREVERSE_1 = 1 "Data transfer starts with LSB first.";
        RREVERSE_2 = 2 "Reserved (do not use)";
        RREVERSE_3 = 3 "Reserved (do not use)";
    };

    constants rdatdly_status width(2) "" {
        RDATDLY_0 = 0 "0-bit data delay";
        RDATDLY_1 = 1 "1-bit data delay";
        RDATDLY_2 = 2 "2-bit data delay";
        RDATDLY_3 = 3 "Reserved";
    };
    
    register mcbsplp_rcr2_reg addr(base, 0x18) "McBSPLP receive control register 2" {
        _ 16 mbz;
        rphase 1 rw type(rphase_status) "Receive Phases";
        rfrlen2 7 rw "Receive Frame Length 2 Single-phase frame selected: RFRLEN2=don't care Dual-phase frame selected: RFRLEN2=000 0000 - 1 word per second phase (other values are reserved)";
        rwdlen2 3 rw type(rwdlen2_status) "Receive Word Length 2";
        rreverse 2 rw type(rreverse_status) "Receive reverse mode.";
        _ 1 mbz;
        rdatdly 2 rw type(rdatdly_status) "Receive Data Delay";
    };
    
    register mcbsplp_rcr1_reg addr(base, 0x1C) "McBSPLP receive control register 1" {
        _ 17 mbz;
        rfrlen1 7 rw "Receive Frame Length 1 Single-phase frame selected: RFRLEN1=000 0000 - 1 word per frame RFRLEN1=000 0001 - 2 words per frame RFRLEN1=111 1111 - 128 words per frame Dual-phase frame selected: RFRLEN1=000 0000 - 1 word per phase (other values are reserved)";
        rwdlen1 3 rw type(rwdlen2_status) "Receive Word Length 1";
        _ 5 mbz;
    };
    
    register mcbsplp_xcr2_reg addr(base, 0x20) "McBSPLP transmit control register 2" {
        _ 16 mbz;
        xphase 1 rw type(rphase_status) "Transmit Phases";
        xfrlen2 7 rw "Transmit Frame Length 2 Single-phase frame selected: XFRLEN2=don't care Dual-phase frame selected: XFRLEN2=000 0000 - 1 word per second phase (other values are reserved)";
        xwdlen2 3 rw type(rwdlen2_status) "Transmit Word Length 2";
        xreverse 2 rw type(rreverse_status) "Transmit reverse mode.";
        _ 1 mbz;
        xdatdly 2 rw type(rdatdly_status) "Transmit Data Delay";
    };
    
    register mcbsplp_xcr1_reg addr(base, 0x24) "McBSPLP transmit control register 1" {
        _ 17 mbz;
        xfrlen1 7 rw "Transmit Frame Length 1 Single-phase frame selected: XFRLEN1=000 0000 - 1 word per frame XFRLEN1=000 0001 - 2 words per frame XFRLEN1=111 1111 - 128 words per frame Dual-phase frame selected: XFRLEN1=000 0000 - 1 word per phase (other values are reserved)";
        xwdlen1 3 rw type(rwdlen2_status) "Transmit Word Length 1";
        _ 5 mbz;
    };

    constants gsync_status width(1) "" {
        GSYNC_0 = 0 "The SRG clock (CLKG) is free running.";
        GSYNC_1 = 1 "The SRG clock (CLKG) is running. But CLKG is resynchronized and frame-sync signal (FSG) is generated only after detecting the receive frame-sync signal (FSR). Also, frame period, FPER, is a don't care because the period is dictated by the external frame-sync pulse.";
    };

    constants clksp_status width(1) "" {
        CLKSP_0 = 0 "Rising edge of CLKG and FSG.";
        CLKSP_1 = 1 "Falling edge of CLKG and FSG.";
    };

    constants clksm_status width(1) "" {
        CLKSM_0 = 0 "SCLKME=0: SRG clock derived from the CLKS pin. SCLKME=1: SRG clock derived from the CLKRI pin.";
        CLKSM_1 = 1 "SCLKME=0: SRG clock derived from the CPU clock. SCLKME=1: SRG clock derived from the CLKXI clock.";
    };

    constants fsgm_status width(1) "" {
        FSGM_0 = 0 "Transmit frame-sync signal (FSX) is generated when transmit buffer is not empty When FSGM=0, FPER and FWID are used to determine the frame-sync period and width (external FSX is gated by the buffer empty condition).";
        FSGM_1 = 1 "Transmit frame-sync signal driven by the SRG frame-sync signal, FSG.";
    };
    
    register mcbsplp_srgr2_reg addr(base, 0x28) "McBSPLP sample rate generator register 2" {
        _ 16 mbz;
        gsync 1 rw type(gsync_status) "";
        clksp 1 rw type(clksp_status) "CLKS Polarity Clock Edge Select Only used when the external clock CLKS drives the SRG clock (CLKSM=0).";
        clksm 1 rw type(clksm_status) "McBSPLP Sample Rate Generator Clock Mode";
        fsgm 1 rw type(fsgm_status) "Sample Rate Generator Transmit Frame-Synchronization Mode Used when FSXM=1 in the PCR.";
        fper 12 rw "Frame Period. This field plus 1 determines when the next frame-sync signal becomes active. Range: 1 to 4096 CLKG periods";
    };
    
    register mcbsplp_srgr1_reg addr(base, 0x2C) "McBSPLP sample rate generator register 1" {
        _ 16 mbz;
        fwid 8 rw "Frame Width. This field plus 1 determines the width of the frame-sync pulse, FSG, during its active period. Range: 1 to 256 CLKG periods.";
        clkgdv 8 rw "Sample Rate Generator Clock Divider This value is used as the divide-down number to generate the required SRG clock frequency. Default value is 1.";
    };

    constants xmcme_status width(1) "" {
        XMCME_0 = 0 "2-partition mode: Only partitions A and B are used. You can control up to 32 channels in the transmit multichannel selection mode selected with the XMCM bits. If XMCM = 01b or 10b, assign 16 channels to partition A with the XPABLK bits. Assign 16 channels to partition B with the XPBBLK bits. If XMCM = 11b (for symmetric transmission and reception), assign 16 channels to receive partition A with the RPABLK bits. Assign 16 channels to receive partition B with the RPBBLK bits. You control the channels with the appropriate transmit channel enable registers: XCERA: Channels in partition A XCERB: Channels in partition B";
        XMCME_1 = 1 "8-partition mode: All partitions (A through H) are used. You can control up to 128 channels in the transmit multichannel selection mode selected with the XMCM bits. You control the channels with the appropriate transmit channel enable registers: XCERA: Channels 0 through 15 XCERB: Channels 16 through 31 XCERC: Channels 32 through 47 XCERD: Channels 48 through 63 XCERE: Channels 64 through 79 XCERF: Channels 80 through 95 XCERG: Channels 96 through 111 XCERH: Channels 112 through 127";
    };

    constants xpbblk_status width(2) "" {
        XPBBLK_0 = 0 "Block 1. Channel 16 to channel 31";
        XPBBLK_1 = 1 "Block 3. Channel 48 to channel 63";
        XPBBLK_2 = 2 "Block 5. Channel 80 to channel 95";
        XPBBLK_3 = 3 "Block 7. Channel 112 to channel 127";
    };

    constants xpablk_status width(2) "" {
        XPABLK_0 = 0 "Block 0. Channel 0 to channel 15";
        XPABLK_1 = 1 "Block 2. Channel 32 to channel 47";
        XPABLK_2 = 2 "Block 4. Channel 64 to channel 79";
        XPABLK_3 = 3 "Block 6. Channel 96 to channel 111";
    };

    constants xmcm_status width(2) "" {
        XMCM_0 = 0 "All channels enabled without masking (DX is always driven during transmission of data).";
        XMCM_1 = 1 "All channels disabled and therefore masked by default. Required channels are selected by enabling XP(A/B)BLK and XCER(A/B) appropriately. Also, these selected channels are not masked and therefore DX is always driven.";
        XMCM_2 = 2 "All channels enabled, but masked. Selected channels enabled via XP(A/B)BLK and XCER(A/B) are unmasked.";
        XMCM_3 = 3 "All channels disabled and therefore masked by default. Required channels are selected by enabling RP(A/B)BLK and RCER(A/B) appropriately. Selected channels can be unmasked by RP(A/B)BLK and XCER(A/B). This mode is used for symetric transmit and receive operation.";
    };
    
    register mcbsplp_mcr2_reg addr(base, 0x30) "McBSPLP multi channel register 2" {
        _ 22 mbz;
        xmcme 1 rw type(xmcme_status) "";
        xpbblk 2 rw type(xpbblk_status) "Transmit Partition B Block (legacy)";
        xpablk 2 rw type(xpablk_status) "Transmit Partition A Block (legacy)";
        _ 3 mbz;
        xmcm 2 rw type(xmcm_status) "Transmit Multichannel Selection Enable";
    };

    constants rmcme_status width(1) "" {
        RMCME_0 = 0 "2-partition mode. Only partitions A and B are used. You can control up to 32 channels in the receive multichannel selection mode (RMCM = 1). Assign 16 channels to partition A with the RPABLK bits. Assign 16 channels to partition B with the RPBBLK bits. You control the channels with the apropriate receive channel enable registers: RCERA: Channels in partition A RCERB: Channels in partition B";
        RMCME_1 = 1 "8-partition mode: All partitions (A through H) are used. You can control up to 128 channels in the receive multichannel selection mode. You control the channels with the appropriate receive channel enable registers: RCERA: Channels 0 through 15 RCERB: Channels 16 through 31 RCERC: Channels 32 through 47 RCERD: Channels 48 through 63 RCERE: Channels 64 through 79 RCERF: Channels 80 through 95 RCERG: Channels 96 through 111 RCERH: Channels 112 through 127";
    };

    constants rmcm_status width(1) "" {
        RMCM_0 = 0 "All 128 channels";
        RMCM_1 = 1 "All channels disabled by default. Required channels are selected by enabling RP(A/B)BLK and RCER(A/B) appropriately";
    };
    
    register mcbsplp_mcr1_reg addr(base, 0x34) "McBSPLP multi channel register 1" {
        _ 22 mbz;
        rmcme 1 rw type(rmcme_status) "(legacy)";
        rpbblk 2 rw type(xpbblk_status) "Receive Partition B Block (legacy)";
        rpablk 2 rw type(xpablk_status) "Receive Partition A Block (legacy)";
        _ 4 mbz;
        rmcm 1 rw type(rmcm_status) "Receive Multichannel Selection Enable";
    };
    
    register mcbsplp_rcera_reg addr(base, 0x38) "McBSPLP receive channel enable register partition A" {
        _ 16 mbz;
        rcera 16 rw "Receive Channel Enable RCERA n=0 Disables reception of n-th channel in an even-numbered block in partition A RCERA n=1 Enables reception of n-th channel in an even-numbered block in partition A";
    };
    
    register mcbsplp_rcerb_reg addr(base, 0x3C) "McBSPLP receive channel enable register partition B" {
        _ 16 mbz;
        rcerb 16 rw "Receive Channel Enable RCERB n=0 Disables reception of n-th channel in a even-numbered block in partition B RCERB n=1 Enables reception of n-th channel in a even-numbered block in partition B";
    };
    
    register mcbsplp_xcera_reg addr(base, 0x40) "McBSPLP transmit channel enable register partition A" {
        _ 16 mbz;
        xcera 16 rw "Transmit Channel Enable XCERA n=0 Disables transmission of n-th channel in an event-numbered block in partition A XCERA n=1 Enables transmission of n-th channel in an event-numbered block in partition A";
    };
    
    register mcbsplp_xcerb_reg addr(base, 0x44) "McBSPLP transmit channel enable register partition B" {
        _ 16 mbz;
        xcerb 16 rw "Transmit Channel Enable XCERB n=0 Disables transmission of n-th channel in an even-numbered block in partition B XCERB n=1 Enables transmission of n-th channel in an even-numbered block in partition B";
    };

    constants idle_en_status width(1) "" {
        IDLE_EN_0 = 0 "The McBSP is running";
        IDLE_EN_1 = 1 "The clocks in the McBSP are shut off when both IDLE_EN=1 and peripheral domain is in idle mode";
    };

    constants xioen_status width(1) "" {
        XIOEN_0 = 0 "DX, FSX and CLKX are configured as serial port pins and do not function as general-purpose I/Os.";
        XIOEN_1 = 1 "DX pin is a general purpose output. FSX and CLKX are general purpose I/Os. These serial port pins do not perform serial port operation.";
    };

    constants rioen_status width(1) "" {
        RIOEN_0 = 0 "DR, FSR, CLKR and CLKS are configured as serial port pins and do not function as general-purpose I/Os.";
        RIOEN_1 = 1 "DR and CLKS pins are general purpose inputs; FSR and CLKR are general purpose I/Os. These serial port pins do not perform serial port operation. The CLKS pin is affected by a combination of RRST and RIOEN signals of the receiver.";
    };

    constants fsxm_status width(1) "" {
        FSXM_0 = 0 "Frame-sync signal derived from an external source";
        FSXM_1 = 1 "Frame synchronization is determined by the SRG frame-sync mode bit FSGM in SRGR2.";
    };

    constants fsrm_status width(1) "" {
        FSRM_0 = 0 "Frame-sync pulses generated by an external device. FSR is an input pin.";
        FSRM_1 = 1 "Frame synchronization generated internally by SRG. FSR is an output pin except when GSYNC=1 in SRGR.";
    };

    constants clkxm_status width(1) "" {
        CLKXM_0 = 0 "Transmitter clock is driven by an external clock with CLKX as an input pin.";
        CLKXM_1 = 1 "CLKX is an output pin and is driven by the internal sample rate generator.";
    };

    constants clkrm_status width(1) "" {
        CLKRM_0 = 0 "Case 1: Digital loopback mode not set (DLB=0) in SPCR1: Receive clock (CLKR) is an input driven by an externaal clock. Case 2: Digital loopback mode set (DLB=1) in SPCR1: Receive clock (not the CLKR pin) is driven by transmit clock (CLKX) which is based on the CLKXM bit in the PCR. CLKR pin is in high-impedance.";
        CLKRM_1 = 1 "Case 1: Digital loopback mode not set (DLB=0) in SPCR1: CLKR is an output pin and is driven by the internal SRG. Case 2: Digital loopback mode set (DLB=1) in SPCR1: CLKR is an output pin and is driven by the transmit clock. The transmit clock is derived based on the CLKRM bit in the PCR.";
    };

    constants sclkme_status width(1) "" {
        SCLKME_0 = 0 "CLKSM = 0: Signal on CLKS pin CLKSM = 1: CPU clock";
        SCLKME_1 = 1 "CLKSM = 0: Signal on CLKR pin CLKSM = 1: Signal on CLKX pin";
    };

    constants clks_stat_status width(1) "" {
        CLKS_STAT_0_r = 0 "The signal on the CLKS pin is low";
        CLKS_STAT_1_r = 1 "The signal on the CLKS pin is high";
    };

    constants dx_stat_status width(1) "" {
        DX_STAT_0 = 0 "Drive the signal on the DX pin low";
        DX_STAT_1 = 1 "Drive the signal on the DX pin high";
    };

    constants dr_stat_status width(1) "" {
        DR_STAT_0_r = 0 "The signal on DR pin is low";
        DR_STAT_1_r = 1 "The signal on DR pin is high";
    };

    constants fsxp_status width(1) "" {
        FSXP_0 = 0 "Frame-sync pulse FSX is active high";
        FSXP_1 = 1 "Frame-sync pulse FSX is active low";
    };

    constants fsrp_status width(1) "" {
        FSRP_0 = 0 "Frame-sync pulse FSR is active high";
        FSRP_1 = 1 "Frame-sync pulse FSR is active low";
    };

    constants clkrp_status width(1) "" {
        CLKRP_0 = 0 "Receive data sampled on falling edge of CLKR";
        CLKRP_1 = 1 "Receive data sampled on rising edge of CLKR";
    };
    
    register mcbsplp_pcr_reg addr(base, 0x48) "McBSPLP pin control register" {
        _ 17 mbz;
        idle_en 1 rw type(idle_en_status) "Idle enable. This bit allows stopping all the clocks in the MCBSPLP. (legacy)";
        xioen 1 rw type(xioen_status) "Transmit General Purpose I/O Mode only when XRST=0 in SPCR[1,2] (legacy)";
        rioen 1 rw type(rioen_status) "Receive General Purpose I/O Mode when RRST=0 in SPCR[1,2] (legacy)";
        fsxm 1 rw type(fsxm_status) "Transmit Frame-Synchronization Mode";
        fsrm 1 rw type(fsrm_status) "Receive Frame-Synchronization Mode";
        clkxm 1 rw type(clkxm_status) "Transmitter Clock Mode";
        clkrm 1 rw type(clkrm_status) "Receiver Clock Mode";
        sclkme 1 rw type(sclkme_status) "The frequency of CLKG is: CLKG frequency = (Input clock frequency) / (CLKGDV + 1) SCLKME is used in conjunction with the CLKSM bit to select the input clock:";
        clks_stat 1 ro type(clks_stat_status) "CLKS pin status. Reflects value on CLKS pin when selected as a general purpose input. (legacy)";
        dx_stat 1 rw type(dx_stat_status) "DX pin status. Reflects value driven on to DX pin when selected as a general purpose output. (legacy)";
        dr_stat 1 ro type(dr_stat_status) "DR pin status. Reflects value on DR pin when selected as a general purpose input. (legacy)";
        fsxp 1 rw type(fsxp_status) "Transmit Frame-Synchronization Polarity";
        fsrp 1 rw type(fsrp_status) "Receive Frame-Synchronization Polarity";
        clkxp 1 rw type(clkxm_status) "Transmit Clock Polarity";
        clkrp 1 rw type(clkrp_status) "Receive Clock Polarity";
    };
    
    register mcbsplp_rcerc_reg addr(base, 0x4C) "McBSPLP receive channel enable register partition C" {
        _ 16 mbz;
        rcerc 16 rw "Receive Channel Enable RCERC n=0 Disables reception of n-th channel in an even-numbered block in partition C RCERC n=1 Enables reception of n-th channel in an even-numbered block in partition C";
    };
    
    register mcbsplp_rcerd_reg addr(base, 0x50) "McBSPLP receive channel enable register partition D" {
        _ 16 mbz;
        rcerd 16 rw "Receive Channel Enable RCERD n=0 Disables reception of n-th channel in an even-numbered block in partition D RCERD n=1 Enables reception of n-th channel in an even-numbered block in partition D";
    };
    
    register mcbsplp_xcerc_reg addr(base, 0x54) "McBSPLP transmit channel enable register partition C" {
        _ 16 mbz;
        xcerc 16 rw "Transmit Channel Enable XCERC n=0 Disables transmission of n-th channel in an event-numbered block in partition C XCERC n=1 Enables transmission of n-th channel in an event-numbered block in partition C";
    };
    
    register mcbsplp_xcerd_reg addr(base, 0x58) "McBSPLP transmit channel enable register partition D" {
        _ 16 mbz;
        xcerd 16 rw "Transmit Channel Enable XCERD n=0 Disables transmission of n-th channel in an even-numbered block in partition D XCERD n=1 Enables transmission of n-th channel in an even-numbered block in partition D";
    };
    
    register mcbsplp_rcere_reg addr(base, 0x5C) "McBSPLP receive channel enable register partition E" {
        _ 16 mbz;
        rcere 16 rw "Receive Channel Enable RCERE n=0 Disables reception of n-th channel in an even-numbered block in partition E RCERE n=1 Enables reception of n-th channel in an even-numbered block in partition E";
    };
    
    register mcbsplp_rcerf_reg addr(base, 0x60) "McBSPLP receive channel enable register partition F" {
        _ 16 mbz;
        rcerf 16 rw "Receive Channel Enable RCERF n=0 Disables reception of n-th channel in an even-numbered block in partition F RCERF n=1 Enables reception of n-th channel in an even-numbered block in partition F";
    };
    
    register mcbsplp_xcere_reg addr(base, 0x64) "McBSPLP transmit channel enable register partition E" {
        _ 16 mbz;
        xcere 16 rw "Transmit Channel Enable XCERE n=0 Disables transmission of n-th channel in an event-numbered block in partition E XCERE n=1 Enables transmission of n-th channel in an event-numbered block in partition E";
    };
    
    register mcbsplp_xcerf_reg addr(base, 0x68) "McBSPLP transmit channel enable register partition F" {
        _ 16 mbz;
        xcerf 16 rw "Transmit Channel Enable XCERF n=0 Disables transmission of n-th channel in an even-numbered block in partition F XCERF n=1 Enables transmission of n-th channel in an even-numbered block in partition F";
    };
    
    register mcbsplp_rcerg_reg addr(base, 0x6C) "McBSPLP receive channel enable register partition G" {
        _ 16 mbz;
        rcerg 16 rw "Receive Channel Enable RCERG n=0 Disables reception of n-th channel in an even-numbered block in partition G RCERG n=1 Enables reception of n-th channel in an even-numbered block in partition G";
    };
    
    register mcbsplp_rcerh_reg addr(base, 0x70) "McBSPLP receive channel enable register partition H" {
        _ 16 mbz;
        rcerh 16 rw "Receive Channel Enable RCERH n=0 Disables reception of n-th channel in an even-numbered block in partition H RCERH n=1 Enables reception of n-th channel in an even-numbered block in partition H";
    };
    
    register mcbsplp_xcerg_reg addr(base, 0x74) "McBSPLP transmit channel enable register partition G" {
        _ 16 mbz;
        xcerg 16 rw "Transmit Channel Enable XCERG n=0 Disables transmission of n-th channel in an event-numbered block in partition G XCERG n=1 Enables transmission of n-th channel in an event-numbered block in partition G";
    };
    
    register mcbsplp_xcerh_reg addr(base, 0x78) "McBSPLP transmit channel enable register partition H" {
        _ 16 mbz;
        xcerh 16 rw "Transmit Channel Enable XCERH n=0 Disables transmission of n-th channel in an even-numbered block in partition H XCERH n=1 Enables transmission of n-th channel in an even-numbered block in partition H";
    };
    
    register mcbsplp_rev_reg addr(base, 0x7C) "MCBSPLP Revision number register" {
        _ 24 mbz;
        rev 8 ro "Revision number";
    };
    
    register mcbsplp_rintclr_reg rw addr(base, 0x80) "McBSPLP receive interrupt clear" type(uint32);
    
    register mcbsplp_xintclr_reg rw addr(base, 0x84) "McBSPLP transmit interrupt clear (legacy)" type(uint32);
    
    register mcbsplp_rovflclr_reg rw addr(base, 0x88) "McBSPLP receive overflow interrupt clear" type(uint32);

    constants clockactivity_status width(2) "" {
        CLOCKACTIVITY_0 = 0 "The MCBSPi_ICLK clock can be switched off. The PRCM functional clock can be switched off.";
        CLOCKACTIVITY_1 = 1 "The MCBSPi_ICLK clock must be maintained during wakeup. The PRCM functional clock can be switched off.";
        CLOCKACTIVITY_2 = 2 "The MCBSPi_ICLK clock can be switched off. The PRCM functional clock must be maintained during wakeup.";
        CLOCKACTIVITY_3 = 3 "The MCBSPi_ICLK clock must be maintained during wakeup. The PRCM functional clock must be maintained during wakeup";
    };

    constants sidlemode_status width(2) "" {
        SIDLEMODE_0 = 0 "Force-idle. An idle request is acknowledged unconditionally.";
        SIDLEMODE_1 = 1 "No-idle. An idle request is never acknowledged.";
        SIDLEMODE_2 = 2 "Smart-idle. Acknowledgement to an idle request is given based on the internal activity of the module";
        SIDLEMODE_3 = 3 "Reserved";
    };

    constants enawakeup_status width(1) "" {
        ENAWAKEUP_0 = 0 "WakeUp is disabled";
        ENAWAKEUP_1 = 1 "WakeUp capability is enabled";
    };

    constants softreset_status width(1) "" {
        SOFTRESET_0 = 0 "NO soft reset";
        SOFTRESET_1 = 1 "Soft reset triggered";
    };
    
    register mcbsplp_sysconfig_reg addr(base, 0x8C) "McBSPLP System Configuration register" {
        _ 22 mbz;
        clockactivity 2 rw type(clockactivity_status) "";
        _ 3 mbz;
        sidlemode 2 rw type(sidlemode_status) "Slave interface power management, req/ack control:";
        enawakeup 1 rw type(enawakeup_status) "WakeUp feature control:";
        softreset 1 rw type(softreset_status) "McBSPLP global software reset";
        _ 1 mbz;
    };
    
    register mcbsplp_thrsh2_reg addr(base, 0x90) "McBSPLP transmit buffer threshold (DMA or IRQ trigger)" {
        _ 25 mbz;
        xthreshold 7 rw "Transmit buffer threshold value. The DMA request (if enabled) of interrupt assertion (if enabled) will be triggered if the number of free locations inside transmit buffer are above or equal to the XTHRESHOLD value + 1. Also, this value (XTHRESHOLD value + 1) indicates the number of words transferred during a transmit data DMA request, if transmit DMA is enabled";
    };
    
    register mcbsplp_thrsh1_reg addr(base, 0x94) "McBSPLP receive buffer threshold (DMA or IRQ trigger)" {
        _ 25 mbz;
        rthreshold 7 rw "Receive buffer threshold value. The DMA request (if enabled) of interrupt assertion (if enabled) will be triggered if the number of occupied locations inside receive buffer are above or equal to the RTHRESHOLD value + 1. Also, this value (RTHRESHOLD value + 1) indicates the number of words transferred during a receive data DMA request, if receive DMA is enabled.";
    };

    constants xemptyeof_status width(1) "" {
        XEMPTYEOF_0 = 0 "XEMPTYEOF is NOT set to when a complete frame was transmitted and the transmit buffer is empty";
        XEMPTYEOF_1 = 1 "XEMPTYEOF is set to 1 when a complete frame was transmitted and the transmit buffer is empty. Writing 1 to this bit clears the bit.";
    };

    constants xovflstat_status width(1) "" {
        XOVFLSTAT_0 = 0 "Transmit buffer NOT overflow";
        XOVFLSTAT_1 = 1 "Transmit buffer overflow; Writing 1 to this bit clears the bit.";
    };

    constants xundflstat_status width(1) "" {
        XUNDFLSTAT_0 = 0 "the transmit data buffer is NOT empty new data is required to be transmitted.";
        XUNDFLSTAT_1 = 1 "the transmit data buffer is empty new data is required to be transmitted. Writing 1 to this bit clears the bit.";
    };

    constants xrdy_status1 width(1) "" {
        XRDY_0 = 0 "Transmit buffer occupied locations are below the THRSH2_REG value).";
        XRDY_1 = 1 "Transmit buffer occupied locations are equal or above the THRSH2_REG value). Writing 1 to this bit clears the bit.";
    };

    constants xeof_status width(1) "" {
        XEOF_0 = 0 "complete frame was NOT transmitted";
        XEOF_1 = 1 "complete frame was transmitted; Writing 1 to this bit clears the bit.";
    };

    constants rovflstat_status width(1) "" {
        ROVFLSTAT_0 = 0 "receive buffer NOT overflow";
        ROVFLSTAT_1 = 1 "receive buffer overflow; Writing 1 to this bit clears the bit.";
    };

    constants rrdy_status1 width(1) "" {
        RRDY_0 = 0 "receive buffer occupied locations are below the THRSH1_REG value).";
        RRDY_1 = 1 "receive buffer occupied locations are equal or above the THRSH1_REG value). Writing 1 to this bit clears the bit.";
    };

    constants reof_status width(1) "" {
        REOF_0 = 0 "complete frame was NOT received";
        REOF_1 = 1 "complete frame was received; Writing 1 to this bit clears the bit.";
    };
    
    register mcbsplp_irqstatus_reg addr(base, 0xA0) "McBSPLP Interrupt Status register (interconnect compliant IRQ line)" {
        _ 17 mbz;
        xemptyeof 1 rw type(xemptyeof_status) "Transmit Buffer Empty at end of frame (XEMPTYEOF is set to 1 when a complete frame was transmitted and the transmit buffer is empty).";
        _ 1 mbz;
        xovflstat 1 rw type(xovflstat_status) "Transmit Buffer Overflow (XOVFLSTAT bit is set to 1 when transmit buffer overflow; the data which is written while overflow condition is discarded). Writing 1 to this bit clears the bit.";
        xundflstat 1 rw type(xundflstat_status) "Transmit Buffer Underflow (XUNDFLSTAT bit is set to 1 when the transmit data buffer is empty new data is required to be transmitted). Writing 1 to this bit clears the bit.";
        xrdy 1 rw type(xrdy_status1) "Transmit Buffer Threshold Reached (XRDY bit is set to 1 when the transmit buffer free locations are equal or above the THRSH2_REG value). Writing 1 to this bit clears the bit.";
        xeof 1 rw type(xeof_status) "Transmit End Of Frame (XEOF is set to 1 when a complete frame was transmitted). Writing 1 to this bit clears the bit.";
        xfsx 1 rw type(xundflstat_status) "Transmit Frame Synchronization (XFSX bit is set to 1 when a new transmit frame synchronization is asserted). Writing 1 to this bit clears the bit.";
        xsyncerr 1 rw type(xundflstat_status) "Transmit Frame Synchronization Error (XSYNCERR is set to 1 when a transmit frame-sync error is detected). Writing 1 to this bit clears the bit.";
        _ 1 mbz;
        rovflstat 1 rw type(rovflstat_status) "Receive Buffer Overflow (ROVFLSTAT bit is set to 1 when receive buffer overflow; the data which is written while overflow condition is discarded). Writing 1 to this bit clears the bit.";
        rundflstat 1 rw type(xundflstat_status) "Receive Buffer Underflow (RUNDFLSTAT bit is set to 1 when read operation is performed to the receive data register while receive buffer is empty; data read while underflow condition is undefined). Writing 1 to this bit clears the bit.";
        rrdy 1 rw type(rrdy_status1) "Receive Buffer Threshold Reached (RRDY bit is set to 1 when the receive buffer occupied locations are equal or above the THRSH1_REG value). Writing 1 to this bit clears the bit.";
        reof 1 rw type(reof_status) "Receive End Of Frame (REOF is set to 1 when a complete frame was received). Writing 1 to this bit clears the bit.";
        rfsr 1 rw type(xundflstat_status) "Receive Frame Synchronization (RFSR bit is set to 1 when a new receive frame synchronization is asserted). Writing 1 to this bit clears the bit.";
        rsyncerr 1 rw type(xundflstat_status) "Receive Frame Synchronization Error (RSYNCERR is set to 1 when a receive frame-sync error is detected). Writing 1 to this bit clears the bit.";
    };

    constants xovflen_status width(1) "" {
        XOVFLEN_0 = 0 "Transmit Buffer Overflow NOT enabled";
        XOVFLEN_1 = 1 "Transmit Buffer Overflow enabled";
    };

    constants xundflen_status width(1) "" {
        XUNDFLEN_0 = 0 "Transmit Buffer Underflow NOT enabled";
        XUNDFLEN_1 = 1 "Transmit Buffer Underflow enabled";
    };

    constants xeofen_status width(1) "" {
        XEOFEN_0 = 0 "Transmit End Of Frame NOT enabled";
        XEOFEN_1 = 1 "Transmit End Of Frame enabled";
    };

    constants xfsxen_status width(1) "" {
        XFSXEN_0 = 0 "Transmit Frame Synchronization NOT enabled";
        XFSXEN_1 = 1 "Transmit Frame Synchronization enabled";
    };

    constants rovflen_status width(1) "" {
        ROVFLEN_0 = 0 "Receive Buffer Overflow NOT enabled";
        ROVFLEN_1 = 1 "Receive Buffer Overflow enabled";
    };

    constants rundflen_status width(1) "" {
        RUNDFLEN_0 = 0 "Receive Buffer Underflow NOT enabled";
        RUNDFLEN_1 = 1 "Receive Buffer Underflow enabled";
    };

    constants rrdyen_status width(1) "" {
        RRDYEN_0 = 0 "Receive Buffer Threshold NOT enabled";
        RRDYEN_1 = 1 "Receive Buffer Threshold enabled";
    };

    constants reofen_status width(1) "" {
        REOFEN_0 = 0 "Receive End Of Frame NOT enabled";
        REOFEN_1 = 1 "Receive End Of Frame enabled";
    };

    constants rfsren_status width(1) "" {
        RFSREN_0 = 0 "Receive Frame Synchronization NOT enabled";
        RFSREN_1 = 1 "Receive Frame Synchronization enabled";
    };
    
    register mcbsplp_irqenable_reg addr(base, 0xA4) "McBSPLP Interrupt Enable register (interconnect compliant IRQ line)" {
        _ 17 mbz;
        xemptyeofen 1 rw type(xundflstat_status) "Transmit buffer empty at end of frame enable bit.";
        _ 1 mbz;
        xovflen 1 rw type(xovflen_status) "Transmit Buffer Overflow enable bit.";
        xundflen 1 rw type(xundflen_status) "Transmit Buffer Underflow enable bit.";
        xrdyen 1 rw type(xundflstat_status) "Transmit Buffer Threshold Reached enable bit.";
        xeofen 1 rw type(xeofen_status) "Transmit End Of Frame enable bit.";
        xfsxen 1 rw type(xfsxen_status) "Transmit Frame Synchronization enable bit.";
        xsyncerren 1 rw type(xundflstat_status) "Transmit Frame Synchronization Error enable bit.";
        _ 1 mbz;
        rovflen 1 rw type(rovflen_status) "Receive Buffer Overflow enable bit.";
        rundflen 1 rw type(rundflen_status) "Receive Buffer Underflow enable bit.";
        rrdyen 1 rw type(rrdyen_status) "Receive Buffer Threshold enable bit.";
        reofen 1 rw type(reofen_status) "Receive End Of Frame enable bit.";
        rfsren 1 rw type(rfsren_status) "Receive Frame Synchronization enable bit. RW";
        rsyncerren 1 rw type(xundflstat_status) "Receive Frame Synchronization Error enable bit.";
    };

    constants xemptyeofen_status width(1) "" {
        XEMPTYEOFEN_0_1 = 0 "Transmit Buffer Empty at End Of Frame WK enable is NOT active";
        XEMPTYEOFEN_1_1 = 1 "Transmit Buffer Empty at End Of Frame WK enable is active";
    };
    
    register mcbsplp_wakeupen_reg addr(base, 0xA8) "McBSPLP Wakeup Enable register" {
        _ 17 mbz;
        xemptyeofen 1 rw type(xemptyeofen_status) "Transmit Buffer Empty at End Of Frame enable bit.";
        _ 3 mbz;
        xrdyen 1 rw type(xemptyeofen_status) "Transmit Buffer Threshold Reached WK enable bit.";
        xeofen 1 rw type(xemptyeofen_status) "Transmit End Of Frame WK enable bit.";
        xfsxen 1 rw type(xemptyeofen_status) "Transmit Frame Synchronization WK enable bit.";
        xsyncerren 1 rw type(xemptyeofen_status) "Transmit Frame Synchronization Error WK enable bit.";
        _ 3 mbz;
        rrdyen 1 rw type(xemptyeofen_status) "Receive Buffer Threshold wakeup enable bit.";
        reofen 1 rw type(xemptyeofen_status) "Receive End Of Frame WK enable bit.";
        rfsren 1 rw type(xemptyeofen_status) "Receive Frame Synchronization WK enable bit.";
        rsyncerren 1 rw type(xemptyeofen_status) "Receive Frame Synchronization Error WK enable bit.";
    };

    constants extclkgate_status width(1) "" {
        EXTCLKGATE_0 = 0 "External clock gating disabled.";
        EXTCLKGATE_1 = 1 "External clock gating enable.";
    };

    constants ppconnect_status width(1) "" {
        PPCONNECT_0 = 0 "Pair to pair connection. When set the DXENO pin is always set to 0 regardless of the frame boundary, setting the tree state buffer as output";
        PPCONNECT_1 = 1 "Pair to pair connection. When set the DXENO pin is always set to 0 regardless of the frame boundary, setting the tree state buffer as output";
    };

    constants dxendly_status width(2) "" {
        DXENDLY_0 = 0 "80 ps";
        DXENDLY_1 = 1 "160 ps (default)";
        DXENDLY_2 = 2 "240 ps";
        DXENDLY_3 = 3 "320 ps";
    };

    constants dlb_status width(1) "" {
        DLB_0 = 0 "No DLB";
        DLB_1 = 1 "DLB";
    };

    constants xdmaen_status width(1) "" {
        XDMAEN_0 = 0 "When set to 0 this bit will gate the external transmit DMA request,";
        XDMAEN_1 = 1 "When set to 1 this bit will NOT gate the external transmit DMA request,";
    };
    
    register mcbsplp_xccr_reg addr(base, 0xAC) "McBSPLP transmit configuration control register" {
        _ 16 mbz;
        extclkgate 1 rw type(extclkgate_status) "External clock gating enable (CLKX and FSX master only). When this bit is set and the transmit clock and FSX are set as output, the CLKX is enabled when FSX is active plus 3 clock cycles after (clock is provided for FWID + 4 clock cycles, assuming that the FSX width, active, is FWID + 1 clock cycles); outside this window the external transmit clock is gated. The receive use the same gated transmit clock and transmit frame synchronization signals regardless of the CLKRM/FSRM settings. When using this mode the frame synchronization signal must be active during reception of the entire frame (FWID must be programmed accordingly) to ensure the proper receive process, which requires at least 3 cycles after the frame complete to transfer the data into the receive buffer.";
        ppconnect 1 rw type(ppconnect_status) "Pair to pair connection. When set the DXENO pin is always set to 0 regardless of the frame boundary, setting the tree state buffer as output";
        dxendly 2 rw type(dxendly_status) "When DXENA bit in SPCR1 is set to 1 this field selects the added delay as follow:";
        xfull_cycle 1 rw type(sidlemode_status) "Transmit full-cycle mode select.";
        _ 5 mbz;
        dlb 1 rw type(dlb_status) "Digital Loop-Back";
        _ 1 mbz;
        xdmaen 1 rw type(xdmaen_status) "Transmit DMA Enable bit. When set to 0 this bit will gate the external transmit DMA request, without resetting the DMA state machine. It is recommended to change this bit value only during transmit reset.";
        _ 2 mbz;
        xdisable 1 rw type(xundflstat_status) "Transmit Disable bit. When this bit is set the transmit process will stop at the next frame boundary.";
    };
    
    register mcbsplp_rccr_reg addr(base, 0xB0) "McBSPLP receive configuration control register" {
        _ 20 mbz;
        rfull_cycle 1 rw type(sidlemode_status) "Receive full-cycle mode select.";
        _ 7 mbz;
        rdmaen 1 rw type(xdmaen_status) "Receive DMA Enable bit. When set to 0 this bit will gate the external transmit DMA request, without resetting the DMA state machine. It is recommended to change this bit value only during receive reset.";
        _ 2 mbz;
        rdisable 1 rw type(xundflstat_status) "Receive Disable bit. When this bit is set the receive process will stop at the next frame boundary.";
    };
    
    register mcbsplp_xbuffstat_reg addr(base, 0xB4) "McBSPLP transmit buffer status" {
        _ 24 mbz;
        xbuffstat 8 ro "Transmit Buffer Status (indicates the number of free locations inside transmit buffer). The XBUFFSTAT value reflects the buffer status on the interface clock domain and it can be smaller than the number of free locations which are seen by the transmit state machine.";
    };
    
    register mcbsplp_rbuffstat_reg addr(base, 0xB8) "McBSPLP receive buffer status" {
        _ 24 mbz;
        rbuffstat 8 ro "Receive Buffer Status (indicates the number of occupied locations inside receive buffer). The RBUFFSTAT value reflects the buffer status on the interface clock domain and it can be smaller than the real number of the occupied locations which are seen by the receive state machine.";
    };
};