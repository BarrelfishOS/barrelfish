{-
  SkateBackendHeader: Backend for generating C header files

  Part of Skate: a Schema specification languge

  Copyright (c) 2017, ETH Zurich.
  All rights reserved.

  This file is distributed under the terms in the attached LICENSE file.
  If you do not find this file, copies can be found by writing to:
  ETH Zurich D-INFK, Universit\"atstr. 6, CH-8092 Zurich. Attn: Systems Group.
-}

module SkateBackendHeader where

import Data.List
import Data.Char

import qualified CAbsSyntax as C
import SkateParser
import SkateSchema
import SkateTypes

import SkateBackendCommon



compile :: String -> String -> SchemaRecord -> String
compile infile outfile s = unlines $ C.pp_unit $ skate_header_file s infile

skate_header_file :: SchemaRecord -> String -> C.Unit
skate_header_file sr infile =
    let
        Schema n d decls imps = (schema sr)
        sym = "SKATE__" ++ (map toUpper n) ++ "_SCHEMA_H_"
    in
      C.IfNDef sym ([ C.Define sym [] "1"] ++ (skate_header_body sr infile)) []

{-----------------------------------------------------------------------------
- The Header File
------------------------------------------------------------------------------}

skate_header_body :: SchemaRecord -> String -> [ C.Unit ]
skate_header_body sr infile =
    let
        Schema n d decls imps = (schema sr)
    in
    [C.Blank, C.Blank] ++
    [(skate_c_preamble n d)] ++
    [C.Blank, C.Blank] ++
    (skate_c_headerfiles imps) ++
    [C.Blank, C.Blank] ++
    [C.MultiComment [
        "====================================================================",
        "Flags",
        "===================================================================="
    ], C.Blank] ++
    (skate_c_header_decls (flags sr)) ++
    [C.Blank, C.Blank] ++
    [C.MultiComment [
        "====================================================================",
        "Constants",
        "===================================================================="
    ], C.Blank] ++
    (skate_c_header_decls (constants sr)) ++
    [C.Blank, C.Blank] ++
    [C.MultiComment [
        "====================================================================",
        "Enumerations",
        "===================================================================="
    ], C.Blank] ++
    (skate_c_header_decls (enumerations sr)) ++
    [C.Blank, C.Blank] ++
    [C.MultiComment [
        "====================================================================",
        "Facts",
        "===================================================================="
    ], C.Blank] ++
    (skate_c_header_decls (facts sr)) ++
    [C.Blank, C.Blank]


{-----------------------------------------------------------------------------
- Premable and Imports
------------------------------------------------------------------------------}

skate_c_preamble :: String -> String -> C.Unit
skate_c_preamble n d = C.MultiComment [
    "SCHEMA DEFINITION: " ++ (map toUpper d) ++ " (" ++ n ++ ")",
    "",
    "Copyright (c) 2017, ETH Zurich.",
    "All rights reserved.",
    "",
    "This file is distributed under the terms in the attached LICENSE",
    "file. If you do not find this file, copies can be found by",
    "writing to:",
    "ETH Zurich D-INFK, Universitaetstr. 6, CH-8092 Zurich.",
    "Attn: Systems Group.",
    "",
    "THIS FILE IS AUTOMATICALLY GENERATED BY SKATE: DO NOT EDIT!"];

-- Header files info
skate_c_headerfiles :: [String] -> [ C.Unit ]
skate_c_headerfiles [] = [C.MultiComment ["No Imports"]]
skate_c_headerfiles imps = [C.MultiComment ["Imports"]] ++
    map (C.Include C.Standard) [ i ++ "_sks.h" | i <- imps ]


{-----------------------------------------------------------------------------
- Premable and Imports
------------------------------------------------------------------------------}

skate_c_header_one_attrib :: String -> FactAttrib -> [C.Param]
skate_c_header_one_attrib p e@(FactAttrib i d t) = [
  C.ParamDoxyComment d,
  C.Param (typeref_to_ctype t) i]

skate_c_header_fact :: String -> String -> [ FactAttrib ]-> [C.Unit]
skate_c_header_fact i d attrib = [
    (skate_c_type_comment "Fact" d i),
    C.StructDecl ttype $ concat (intersperse [C.ParamBlank] [skate_c_header_one_attrib i a | a <- attrib]),
    C.TypeDef (C.Struct ttype) ttype,
    C.Blank]
    where
        tname = (make_qualified_name i)
        ttype = (make_type_name tname)


skate_c_header_one_flag :: String -> FlagDef -> C.TypeSpec -> C.Unit
skate_c_header_one_flag p f@(FlagDef i d v) t = C.UnitList [
    C.DoxyComment d,
    C.Define (flagdef) [] (C.pp_expr $ C.Cast t $
            C.Binary C.LeftShift (C.NumConstant 1) (C.NumConstant v)) ]
        where
            flag = make_qualified_type p i
            flagdef = map toUpper (make_qualified_name flag)


skate_c_header_flags :: String -> String -> Integer ->[ FlagDef ]-> [C.Unit]
skate_c_header_flags i d w defs = [
    (skate_c_type_comment "Flags" d i),
    C.TypeDef (C.TypeName ttype) tname,
    C.Blank]
    ++ [skate_c_header_one_flag i def (C.TypeName tname) | def <- defs]
    ++ [C.Blank]
    where
        ttype = "uint" ++ show(w) ++ "_t"
        tname = (make_type_name (make_qualified_name i))



skate_c_header_one_const :: String -> ConstantDef -> C.TypeSpec -> C.Unit
skate_c_header_one_const p f@(ConstantDefInt i d v) t = C.UnitList [
    C.DoxyComment d,
    C.Define (constdef) [] (C.pp_expr $ C.Cast t $ C.NumConstant v) ]
    where
        c = make_qualified_type p i
        constdef = map toUpper (make_qualified_name c)
skate_c_header_one_const p f@(ConstantDefStr i d v) t = C.UnitList [
    C.DoxyComment d,
    C.Define (constdef) [] (C.pp_expr $ C.Cast t $ C.StringConstant v) ]
        where
            c = make_qualified_type p i
            constdef = map toUpper (make_qualified_name c)

skate_c_header_const :: String -> String -> TypeRef ->[ ConstantDef ] -> [C.Unit]
skate_c_header_const i d t@(TBuiltIn tref) defs = [
    (skate_c_type_comment "Constants" d i),
    C.TypeDef (typeref_to_ctype t) tname,
    C.Blank]
    ++ [skate_c_header_one_const i def (C.TypeName tname) | def <- defs]
    ++ [C.Blank]
    where
        tname = (make_type_name (make_qualified_name i))


skate_c_header_one_enum :: String -> EnumDef -> C.EnumItem
skate_c_header_one_enum p e@(EnumDef i d) = C.EnumItem name d Nothing
    where
        enum = make_qualified_type p i
        name = map toUpper (make_qualified_name enum)


skate_c_header_enum :: String -> String -> [ EnumDef ] -> [C.Unit]
skate_c_header_enum i d defs = [
    (skate_c_type_comment "Enumeration" d i),
    C.EnumDecl ttype [skate_c_header_one_enum i def | def <- defs],
    C.Blank]
    where
        tname = (make_qualified_name i)
        ttype = (make_type_name tname)


skate_c_type_comment :: String -> String -> String -> C.Unit
skate_c_type_comment t desc defined = C.MultiDoxy [
    "@brief " ++ desc,
    "",
    "Type: " ++ t,
    "Defined in " ++ defined]

skate_c_header_one_decl :: Declaration -> [ C.Unit ]
skate_c_header_one_decl de@(Fact i d a) = skate_c_header_fact i d a
skate_c_header_one_decl de@(Flags i d w f) = skate_c_header_flags i d w f
skate_c_header_one_decl de@(Constants i d t f) = skate_c_header_const i d t f
skate_c_header_one_decl de@(Enumeration i d f) = skate_c_header_enum i d f
skate_c_header_one_decl _  = []


skate_c_header_decls :: [Declaration] -> [ C.Unit ]
skate_c_header_decls decls = [C.UnitList $ skate_c_header_one_decl d | d <- decls]
