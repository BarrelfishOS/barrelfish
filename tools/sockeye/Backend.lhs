%include polycode.fmt

%if false
  Sockeye: an even more simpler IDL for Barrelfish
   
  Copyright (c) 2015 ETH Zurich.
  All rights reserved.
  
  This file is distributed under the terms in the attached LICENSE file.
  If you do not find this file, copies can be found by writing to:
  ETH Zurich D-INFK, Universitaetsstrasse 6, CH-8092 Zurich. 
  Attn: Systems Group.
%endif

\section{General Functions for Back-ends}


In this module, we define some general functions. These functions are
used in both Code and Header back-ends. They are quite simple, so we
can afford to present them out of their context.


> module Backend where

%if false

> import Data.List

> import SockeyeSyntax

%endif



\subsection{The Preamble}

In both cases, we will have to emit a long, tedious copyright
notice. So, here it is done once and for all.

> preamble :: Schema -> String -> String
> preamble schema filename =
>     let name = 
>             case schema of
>                    Schema _ desc _ -> desc
>                    _ -> ""
>     in
>     {-" \mbox{and so on\ldots} "-}

%if false

>     "/*\n * Schema Definition: " ++ name ++ "\n\
>     \ * Generated from: " ++ filename ++ "\n\
>     \ * \n\
>     \ * Copyright (c) 2015, ETH Zurich.\n\
>     \ * All rights reserved.\n\
>     \ * \n\
>     \ * This file is distributed under the terms in the attached LICENSE\n\
>     \ * file. If you do not find this file, copies can be found by\n\
>     \ * writing to:\n\
>     \ * ETH Zurich D-INFK, Universitaetsstrasse 6, CH-8092 Zurich.\n\
>     \ *  Attn: Systems Group.\n\
>     \ * \n\
>     \ * THIS FILE IS AUTOMATICALLY GENERATED: DO NOT EDIT!\n\
>     \ */\n\n"

%endif


\subsection{Dealing with Namespace Issues}


In order to avoid name clashes, we qualify type names with the
interface name, excepted when it is a built-in type.

> qualifyName :: String -> TypeRef -> String
> qualifyName schemaName (Builtin t) = show t
> qualifyName schemaName (TypeVar t) = schemaName ++ "_" ++ t 
> qualifyName schemaName (TypeAlias t _) = schemaName ++ "_" ++ t

When we are declarating real C types, we have to add a @_t@ at the
end.

> qualifyType :: String -> TypeRef -> String
> qualifyType qualifier (Builtin String) = "char *"
> qualifyType qualifier (TypeAlias name _) = name ++ "_t"
> qualifyType qualifier typeDef =
>     qualifyName qualifier typeDef ++ "_t"

When we are generating stubs, we will need to qualify exported procedures:
@qualifyProcName@ corresponds to the interface namespace, along with a
@_fn@ specifier.

> qualifyProcName :: String -> TypeRef -> String
> qualifyProcName schemaName typeDef = 
>     qualifyName schemaName typeDef ++ "_fn"



\subsection{Dealing with Declarations}


Often (always), we treat types and messages separately. Hence,
@partitionTypesFacts@ takes a list of declarations and partitions
it into two lists: one containing the type declarations, the other
containing the message declarations.

> partitionTypesFactsQueries :: [Declaration] -> ([TypeDef], [FactDef], [QueryDef])
> partitionTypesFactsQueries declarations = 
>     let (types, facts, queries) = foldl' typeFilter ([],[],[]) declarations in
>         (types, reverse facts, reverse queries)
>         where typeFilter (types, facts, queries) (Factdef f) = (types, f : facts, queries)
>               typeFilter (types, facts, queries) (Typedef t) = (t : types, facts, queries)
>               typeFilter (types, facts, queries) (Querydef q) = (types, facts, q : queries)


\subsection{Dealing with Messages}
